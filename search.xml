<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Markdown--你值得拥有]]></title>
      <url>%2F2017%2F01%2F18%2FMarkdown-%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%2F</url>
      <content type="text"><![CDATA[什么是Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 官方文档创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown工具一般写文章大家会用word，那写makdown用什么呢？ mac平台收费的有： Ulysses Ⅲ， Mou ，Bear 免费的有：Typora Windows平台免费的有：Typora，MarkdownPad，MarkPad 这里推荐使用Typora，通吃Windows、mac和Linux三大平台。Typora 在 Markdown 的基础上，保持了应有的简洁和优雅，又一定程度地改良了 Markdown 本身较为不合理和烦琐的地方，适度地引入一些高级的编辑功能，使得一切都觉得如此顺手。 Markdown语法标题在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3.符号要和文字之间加上一个字符的空格。 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可显示引用格式。 图片与连接插入链接与插入图片的语法很像，区别在一个 !号 插入图片的地址需要图床，这里推荐 u图床 （mac）和MPic （Windows）的服务，生成URL地址即可。 在Typora中支持把图片拖拽进去，自动生成Markdown格式。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 代码框用两个 ` 把中间的代码包裹起来。 代码块输入三个```，选择语言，然后输入代码，你会发现代码块中的代码自动高亮。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可。 表格Markdown 写表格比较累人。 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 生成的表格如下： 但是Typora中提供了比较方便的写表格的方法。通过菜单栏或快捷键 Command+T 可以插入表格，Typora 会弹出一个表格插入设置，你可以预先设定好行数和列数，确定后表格就出现了。每一列上面还有三个按钮，可以控制本列的文字向左、居中、向右对齐。甚至，你可以点击左上角改变表格的行数和列数。 删除线用~~包围住文字： Markdown还支持直接写HTML，例如#标题等价于&lt;h1&gt;标题&lt;/h1&gt;。 格式转化在Typora的file—&gt;Export中可以把md格式文件转化成pdf、word、html等格式文件。转word需要安装插件： Download Page。 md格式： 转化成word格式：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm那些事儿]]></title>
      <url>%2F2017%2F01%2F16%2FWebStorm%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
      <content type="text"><![CDATA[关于webstorm WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 快捷键代码注释注释一行代码：ctrl+/(windows) ​ command+/(mac) 注释大段代码： 1 ctrl+/(windows) command+/(mac) ​ 2 ctrl+shif+/(windows) shift+command+/(mac) 格式化代码格式化代码：ctrl+alt+L(windows) ​ option+command+L(mac) shift+F6shift+F6（windows） shift+fn+F6（mac） 1 替换局部变量 ​ 2 重构函数名 快速跳转​ 快速跳转：ctrl+单击(windows) ​ command+单击（mac） 删除代码删除代码:ctrl+Y(windows) ​ Command+delete(mac) 多行编辑多行编辑：1 鼠标选择时按住alt(windows) ​ 鼠标按住时按住option（mac） ​ 2 长按alt+J，自动选择相同的元素（windows） ​ 选中元素后，按ctrl+g（mac） zencoding按tab键自动展开为完整html标签 后代：&gt; 兄弟：+ 上级：^ 分组：() 乘法：* 自增符号：$想显示几位数就使用几个$,$@-倒序，$@3从3开始计数 ​ ID和类属性:#和. 自定义属性:[] 文本:{} zencoding更多资料参见：zen coding 教程zen coding使用方法，大量实例 自定义模板在setting&gt;Editor&gt;Live Templates中可以自定义模板，方便自己调用。 使用效果： 代码对比不同文件代码对比先把需要对比的代码复制到剪切板，然后右击有个compare with Clipboard，就会有个对话框弹出，里面标记了两个代码不同的地方。 相同文件历史代码对比右击有个Local History，选择Show History]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现（二）]]></title>
      <url>%2F2017%2F01%2F11%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[之前用三目表达式和ng-class实现了按钮切换效果，似乎达到了我的预期，但是我觉得还有改进空间，网上找了一些资料，大概还有以下几种实现方式： 路由12&lt;button class="btn1" routerLink="component1" routerLinkActive="active" type="submit"&gt;btn1&lt;/button&gt;&lt;button class="btn2" routerLink="component2" routerLinkActive="active" type="submit"&gt;btn2&lt;/button&gt; 123.active &#123; background-color: white;&#125; 将button切换的页面写成一个component，通过routerLink链接到对应的component并显示出来，routerLinkActive来控制路由链接激活后button的样式应用的class。 但是这个有局限性，适合button按下去后，整个页面会有大幅变化的应用场景，那么还有其他方法吗？答案是肯定的。 [class]与(click)还是通过ngclass和ngclick配合，不过方法和之前写的略有不同。 字符串数组形式12&lt;button [class]="&#123;true:'btn1',false:'btn2'&#125;[isChange]" (click)="isChange=true"&gt;btn1&lt;/button&gt;&lt;button [class]="&#123;false:'btn1',true:'btn2'&#125;[isChange]" (click)="isChange=false" &gt;btn2&lt;/button&gt; 123456789101112131415161718.btn1&#123; width: 120px; height: 43px; border: 1px solid #EEEEEE; background: white; border-bottom: none; text-align: center;&#125;.btn2&#123; border: 1px solid #EEEEEE; border-top: 2px solid #238FF9; width: 120px; height: 42px; background: white; border-bottom: none; text-align: center;&#125; 字符串数组形式是针对class简单变化，具有排斥性的变化，true是什么class，false是什么class。若要设置初识状态的class，可以在component中的构造函数中预先赋值。 对象key/value处理1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 这种方法可以对多个对象赋不同的class。或者可以实现多个button互斥性变化： 1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn1','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn1','four':'btn2'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn2','four':'btn1'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 参考资料： angularJs的ng-class切换class]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之架构概览]]></title>
      <url>%2F2017%2F01%2F02%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[模块NgModuleNgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是： declarations - 声明本模块中拥有的视图类。 Angular 有三种视图类：组件、指令和管道。 exports - declarations 的子集，可用于其它模块的组件模板（暴露出来供外部使用）。 imports - 本模块声明的组件模板需要的类所在的其它模块（引入所需的其他模块的组件模板）。 providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。 bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。 通过main.ts引导AppModule: 1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); JavaScript模块 JavaScript 也有自己的模块系统，用来管理一组 JavaScript 对象。 它与 Angular 的模块系统完全不同且完全无关。 JavaScript 中，每个文件是一个模块，文件中定义的所有对象都从属于那个模块。 通过export关键字，模块可以把它的某些对象声明为公共的。 其它 JavaScript 模块可以使用import 语句来访问这些公共对象。 12import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component'; 1export class AppModule &#123; &#125; Angular模块库Angular模块库是一组JavaScript模块，名字带有@angular前缀。用 JavaScript 的import语句导入。 组件组件控制视图。在类中定义组件的应用逻辑。 应用可以通过生命周期钩子在组件生命周期的各个时间点上插入自己的操作，例如ngOnInit()`。 模板模板定义组件的视图，以HTML形式存在。 模板除了可以使用典型的HTML元素，还可以使用Angular的模板语法，例如：*ngFor、、(click)、[hero]和&lt;hero-detail&gt;等。 &lt;hero-detail&gt;是HeroDetailComponent组件自定义的HTML标签，HeroDetailComponent是HeroListComponent的子组件。 元数据用装饰器来附加元数据: 123456@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;) @Component的配置项包括： moduleId: 为与模块相关的 URL（例如templateUrl）提供基地址。（简单的理解为给url分配一个当前module的Id，便于区分） selector： CSS 选择器，它告诉 Angular 在父级 HTML 中查找&lt;hero-list&gt;标签，创建并插入该组件。 例如，如果应用的 HTML 包含&lt;hero-list&gt;&lt;/hero-list&gt;， Angular 就会把HeroListComponent的一个实例插入到这个标签中。 templateUrl：组件 HTML 模板的模块相对地址。 providers - 组件所需服务的依赖注入提供商数组。 这是在告诉 Angular：该组件的构造函数需要一个HeroService服务，这样组件就可以从服务中获得英雄数据。 数据绑定数据绑定的语法有以下四种形式。每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。 123&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;&lt;hero-detail [hero]="selectedHero"&gt;&lt;/hero-detail&gt;&lt;li (click)="selectHero(hero)"&gt;&lt;/li&gt; 插值表达式在&lt;li&gt;标签中显示组件的hero.name属性的值。 [hero]属性绑定把父组件HeroListComponent的selectedHero的值传到子组件HeroDetailComponent的hero属性中。 (click) 事件绑定在用户点击英雄的名字时调用组件的selectHero方法。 双向数据绑定是重要的第四种绑定形式，它使用ngModel指令组合了属性绑定和事件绑定的功能。 1&lt;input [(ngModel)]="hero.name"&gt; 在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。 Angular 在每个 JavaScript 事件循环中处理所有的数据绑定，它会从组件树的根部开始，递归处理全部子组件。 双向绑定的应用： 模板与对应组件的交互 父组件与子组件的通讯 指令 指令是一个带有“指令元数据”的类。在 TypeScript 中，要通过@Directive装饰器把元数据附加到类上。Angular根据指令提供的操作对DOM进行转换。（严格来说组件就是一个指令）。 结构型指令结构型指令通过在 DOM 中添加、移除和替换元素来修改布局。 12&lt;li *ngFor="let hero of heroes"&gt;&lt;/li&gt;&lt;hero-detail *ngIf="selectedHero"&gt;&lt;/hero-detail&gt; *ngFor告诉 Angular 为heroes列表中的每个英雄生成一个&lt;li&gt;标签。 *ngIf表示只有在选择的英雄存在时，才会包含HeroDetail组件。 属性型指令属性型指令修改一个现有元素的外观或行为。在模板中，它们看起来就像是标准的 HTML 属性。例如：ngModule。 服务服务是一个广义范畴，包括：值、函数，或应用所需的特性。 组件类应保持精简。组件本身不从服务器获得数据、不进行验证输入，也不直接往控制台写日志。 它们把这些任务委托给服务。 组件的任务就是提供用户体验，仅此而已。它介于视图（由模板渲染）和应用逻辑（通常包括模型的某些概念）之间。 设计良好的组件为数据绑定提供属性和方法，把其它琐事都委托给服务。 依赖注入 Angular 使用依赖注入来提供新组件以及组件所需的服务。Angular 通过查看构造函数的参数类型得知组件需要哪些服务。 1constructor(private service: HeroService) &#123; &#125; 当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。 注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。 当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。 这就是依赖注入 。(注入器将服务作为参数，注入到构造函数中) 当注入器没有服务时，通过provide创建并返回一个服务。 provide可以在根模块上添加provide以便任何地方使用服务的同一个实例，或者在@component元数据中添加provide以便在组件层中使用，把它注册在组件级表示该组件的每一个新实例都会有一个服务的新实例。 需要记住的关于依赖注入的要点是： 依赖注入渗透在整个 Angular 框架中，被到处使用。 注入器 (injector) 是本机制的核心。 注入器负责维护一个容器，用于存放它创建过的服务实例。 注入器能使用提供商创建一个新的服务实例。 提供商是一个用于创建服务的配方。 把提供商注册到注入器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2中的base标签]]></title>
      <url>%2F2016%2F12%2F31%2FAngular2%E4%B8%AD%E7%9A%84base%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[Angular2官方hero教程中，提到了&lt;base href=&quot;/&quot;&gt;，写的很简单，当时我也没有留意，今天写自己的开源项目的时候，突然遇到这个问题，正好讲一下。 我的路由是这样的： 12345const routes: Routes = [ &#123; path: '', redirectTo: '/line', pathMatch: 'full' &#125;, &#123; path: 'line', component: LineComponent &#125;, &#123; path: 'bar', component: BarComponent &#125;,]; 第一次加载页面的时候，url是：http://localhost:3000/line， 如果在&lt;head&gt;里没写&lt;base href=&quot;/&quot;&gt;，那么当你浏览器自动刷新的时候，url会变成：http://localhost:3000/line/line，也就是说，浏览器的前缀没有清空，这样会导致加载时出现404错误。这时候只要在&lt;head&gt;里加上&lt;base href=&quot;/&quot;&gt;，就可以了，或者加上： 1&lt;script&gt;document.write('&lt;base href="' + document.location + '" /&gt;');&lt;/script&gt; 来保护当前的URL，保证当我们导航到深层次的url时候，资源可以被正确加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[愿17可期]]></title>
      <url>%2F2016%2F12%2F27%2F%E6%84%BF17%E5%8F%AF%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[[ti:5.野子-苏运莹] [ar: 是] [al:] [by:] [offset:0] [00:00.10]野子 - 苏运莹 [00:00.20]词：苏运莹 [00:00.30]曲：苏运莹 [00:00.40] [00:25.72]怎么大风越狠 [00:28.82]我心越荡 [00:30.91] [00:31.96]幻如一丝尘土 [00:33.79]随风自由的在狂舞 [00:37.62] [00:38.32]我要握紧手中坚定 [00:41.40]却又飘散的勇气 [00:44.78]我会变成巨人 [00:46.73]踏着力气 踩着梦 [00:49.22] [00:51.22]怎么大风越狠 [00:54.29]我心越荡 [00:57.53]又如一丝消沙 [00:59.38]随风轻飘的在狂舞 [01:03.91]我要深埋心头上秉持 [01:07.10]却又重小的勇气 [01:10.21]一直往大风吹的方向走过去 [01:16.20]吹啊吹啊 我的骄傲放纵 [01:19.58]吹啊吹不毁我纯净花园 [01:22.27]任风吹 任它乱 [01:24.02]毁不灭是我 尽头的展望 [01:29.15]吹啊吹啊 我赤脚不害怕 [01:32.34]吹啊吹啊 无所谓 扰乱我 [01:35.52]你看我在勇敢地微笑 [01:37.98] [01:38.50]你看我在勇敢地去挥手啊 [01:42.88] [01:55.14]是你吗 会给我一扇心房 [01:57.60]让我勇敢前行 [02:00.48] [02:01.47]是你呀 会给我一扇灯窗 [02:04.39]让我让我无所畏惧 [02:07.56]吹啊吹啊 我的骄傲放纵 [02:10.76]吹啊吹不毁我纯净花园 [02:13.54]任风吹 任它乱 [02:15.23]毁不灭是我 尽头的展望 [02:19.72] [02:20.46]吹啊吹啊 我赤脚不害怕 [02:23.53]吹啊吹啊 无所谓 扰乱我 [02:26.62]你看我在勇敢地微笑 [02:29.72]你看我在勇敢地去挥手啊 [02:33.97] [02:40.03]怎么大风越狠 我心越荡 [02:46.28] [02:46.93]我会变成巨人 [02:49.75]踏着力气 踩着梦 new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: true, showlrc: 2, music: { title: "野子", author: "苏运莹", url: "http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a", pic: "http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg", } }); 即将过去的一年对我来说太重要，以至于像我这样害怕写总结的人也拿起键盘，敲下了这一段文字。 记得在15年11月吧，在深圳青旅认识的蔡浩凯大哥来上海出差，正好抽空一起吃了一顿饭，交流了一下工作心得，在诺基亚和IBM就职过的浩凯大哥给了我很多职业规划方面的意见，也给我种下一颗转行的种子。 大概是16年3月，我开始在网上看java，每天上班回来，看一小时一建和一小时java，到后来工作太忙，以至于我下决心彻底放弃一建，专心看java，期间汪汪和田野还给我寄了一大箱java的书，虽然我最后去做前端了，哈哈哈。IT上的版本管理工具、IDE、各种开源论坛、各种资料的分享让我看到了一种自己想要的工作模式。 于是16年8月底辞职，去了趟成都和九寨沟散散心，顺便找昭哥和玉玺小聚了一下。回来后便安心的开始看前端。 辞职后，遇到很多朋友都没有透露我转行的消息。其实，当时自己真的挺迷茫的，要填的坑太多，甚至都不确定自己是否会成功，只晓得沿着自己计划的方向走，至于失败还是成功就留给老天吧。 自学期间顺手搭了这个博客，作为程序猿，有自己搭的博客，赶脚逼格max，哈哈哈。11月，在汪汪童鞋的建议下，我开始投简历，可能运气比较好，第二个面试就被录用了。就这样，我也算跨入了程序猿的行列。 工作一个多月，发现自己的选择是正确的，这种Geek的工作模式让我感到充满动力，每次调完bug，那种如沐春风的感觉，真的很棒。 很庆幸，能做自己想做的事情，不管未来是怎么样，至少自己努力了。 感谢蔡浩凯大哥、汪汪、田野，把我领进了IT的大门。 感谢郑部、王博、超哥在面试后决定录用我，虽然我至今都觉得自己技术漏洞太多，被录用简直是奇迹。 感谢中兴通讯虚拟化上海一部DG2的所有同事，面对我的很多问题都能耐心解答，让我成功避开了很多坑。 感谢家人、女友在这一年的支持，在我迷茫的时候给我继续前进的动力。 最后，愿17可期。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo添加音乐、high一下及一些坑]]></title>
      <url>%2F2016%2F12%2F24%2Fhexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
      <content type="text"><![CDATA[hexo添加音乐需要几个步骤？添加音乐当然可以用其他网站的外链，但是一般外链是&lt;iframe&gt;，这个影响网站的SEO，逼格也不够高。 下面我就隆重介绍一款html5音乐播放器：Aplayer。把Aplayer加入hexo需要用到hexo-tag-aplayer插件。 切换到hexo目录，运行： 1npm install hexo-tag-aplayer@2.0.1 这里直接运行npm install hexo-tag-aplayer只会安装2.0.0，这个版本会出现以下错误： 12FATAL Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;Error: Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos; 作者给出来解决方案是用2.0.1版本，FATAL Cannot find module解决办法。 安装完成后，在需要添加音乐的地方加上： 1&#123;% aplayer "平凡之路" "朴树" "https://ogd99kckh.qnssl.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3" "https://ogd99kckh.qnssl.com/1.jpg" "autoplay" %&#125; 就会出现你想要的音乐啦，这里我把音乐和专辑封面添加到七牛上，加载速度嗖嗖的。 如果你想加入歌单，把上面的代码换成下面代码就行，参数的用法可以参照插件的使用说明。 1&#123;% aplayerlist %&#125;&#123;"narrow": false,"autoplay": true,"showlrc": 3,"mode": "random","music": [&#123;"title": "平凡之路","author": "朴树","url": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic": "https://ogd99kckh.qnssl.com/1.jpg","lrc": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"&#125;,&#123;"title": "野子","author": "苏运莹","url": "http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a","pic": "http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt"&#125;]&#125;&#123;% endaplayerlist %&#125; 当然，Aplayer的作者还有一款html5的视频播放器，叫Dplayer，对应有一款hexo的插件，叫hexo-tag-dplayer，有需求的可以去看看，用法都差不多。 一起high一下这个功能是我在Hexo high一下小功能上看到的，觉得很有意思，于是就引进来，改造了一下。 首先是重新封装了一个high.js文件，代码中注释的地方可下载下来放到七牛，加快国内访问速度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150function shake() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake.mp3"; //可下载下来放到七牛，加快国内访问速度 var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake-style.css";//可下载下来放到七牛，加快国内访问速度 var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125; 把这个文件保存在七牛上，在themes—&gt;next—&gt;layout—&gt;_partials—&gt;head.swig中加入这样一段代码，引入high.js文件(src里的内容请替换成自己的外链)： 1&lt;script type="text/javascript" src="https://ogd99kckh.qnssl.com/high.js"&gt;&lt;/script&gt; 然后在themes—&gt;next—&gt;layout—&gt;_macro—&gt;sidebar.swig中加入注释包围中的代码： 1234567891011121314151617&lt;div class="links-of-author motion-element"&gt; &#123;% if theme.social %&#125; &#123;% for name, link in theme.social %&#125; &lt;span class="links-of-author-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; &#123;% if theme.social_icons.enable %&#125; &lt;i class="fa fa-fw fa-&#123;&#123; theme.social_icons[name] | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;% endif %&#125; &#123;&#123; name &#125;&#125; &lt;/a&gt; &lt;/span&gt; &#123;% endfor %&#125; &lt;!--以下是加入关于high一下的代码--&gt; &lt;span class="links-of-author-item"&gt;&lt;a title="小high一下~" style="underline: none;color:red" rel="alternate" class="mw-harlem_shake_slow wobble shake" href="javascript:shake()"&gt;&lt;i class="fa fa-music"&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;High&lt;/a&gt;&lt;/span&gt; &lt;!--以上是加入关于high一下的代码--&gt; &#123;% endif %&#125; &lt;/div&gt; style中我用了红色，这样显眼一点，不喜欢的话可以改掉。 接下来点击high这个按钮，会出现一下效果： 大坑当我吭哧吭哧的弄完后，突然发现我运行hexo g命令后，出现下面两行提示后就不动了~ 12INFO Start processingINFO Files loaded in 3.9 s 我用了各种方法，包括版本回退，好像都没用。于是我就尝试切换到hexo默认主题，结果又可以hexo g，估计是next主题出问题了，于是我重新下了next主题，把我的配置都重新弄了一遍，结果好了~~，不过页脚的地方与之前博客不同，少了”power by hexo”这几个字眼。 更新next后遇到的第一个问题是，不显示文章发表时间了，github上的解答是这样的,文章标题下的发表时间不见了,在主题配置文件里面加上下面的配置，然后就出来了。 12345# Post meta display settingspost_meta: created_at: true updated_at: false categories: true 第二个问题，我hexo s成功后，登陆localhost:4000，发现出现下面的提示： 原因是，我开了shadowsocks的全局模式，切换到自动代理模式，就可以显示网页了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之hero教程]]></title>
      <url>%2F2016%2F12%2F21%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bhero%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[ES6工具链 systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载 es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块 traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码。systemjs会自动加载 这个模块。 Hello World 根据官方文档的快速起步，按照自己的理解画了上面的流程图（有不对的地方还请指正）。 包括Angular在内的Angular应用通过NgModules分成不同的代码块，需要哪个块，就import，这样可以减少文件体积。 每一个Angular应用都至少有一个模块和组件，组件通过与它相关的模板来控制屏幕上的一小块（视图View），main.ts负责初始化应用平台，进行应用引导。 为了方便测试组件，应用的引导应与组件或者模块分开，这样实现了MVM（model-view-whatever） Hero教程官网的Hero教程是建立在quickstart上的，所以可以把quickstart直接拿过来用。 英雄编辑器class中可以定义一些变量、方法甚至是构造函数（用于初始化），export出来的class可以被外部使用。 在Angular中{{}}用来取值。 一个ts文件中可以定义多个export class，但是官方不提倡。 id:number和hero:Hero = {}都是指定了变量的类型。 template中双引号改成反引号，可以写成多行形式。 表单输入双向绑定需要导入FormsModule模块，@NgModule中的import数组是应用中用到的外部模块列表。 用到Angular自带的模块，在import数组中声明；用到自定义的组件在declarations数组中声明。 主从结构123456789101112const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; 这段代码中的const是ES6中定义变量的关键字，在ES6中， const 代表一个值的常量索引，变量名字在内存中的指针不能够改变，但是指向这个变量的值 可能 改变。例如： 1234567const names = [ ] ;names . push ( “Jordan” ) ;console . log ( names ) ;const names = [ ] ;names = [ ] ; // Error! *ngFor=&quot;let hero of heroes&quot;中ngFor的*前缀表示``及其子元素组成了一个主控模板。 ngFor指令在AppComponent.heroes属性返回的heroes数组上迭代，并输出此模板的实例。 引号中赋值给ngFor的那段文本表示“从heroes数组中取出每个英雄，存入一个局部的hero变量，并让它在相应的模板实例中可用”。 为一个组件指定样式时，它们的作用域将仅限于该组件。 ngIf指令为false则从 DOM 中移除整段 HTML。 [class.selected]=&quot;hero === selectedHero&quot; 这个写法很有意思，.可以理解为css类选择器，在class上为selected类添加一个属性绑定（绑定了style中的.selected这个样式），当后面的表达式为true时，绑定这个样式，false时不绑定。而[]实现了从数据源(hero === selectedHero表达式)到class属性的单向数据流动。 多个组件可以将需要多次引用的类单独写入一个ts文件中。 &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;通过标签中的[hero]=&quot;selectedHero&quot;可以在不同组件之间传递数据。在需要引用hero的地方，用@Input() hero: Hero;来引入hero。 服务当 TypeScript 看到@Injectable()装饰器时，就会记下本服务的元数据。 如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。 HeroService从mock-heroes.ts获取数据，并提供给其他组件使用。其他组件使用HeroService时，用构造函数定义一个私有属性，作为注入HeroService的靶点。 providers数组告诉 Angular，当它创建新的AppComponent组件时，也要创建一个HeroService的新实例。 可以把HeroService看做中转站，而providers数组告诉 Angular，这是中转站。中转站中记录着哪里的有元数据，并随时准备注入所需要的组件中。 OnInit 接口会在组件刚创建时、每次变化时，以及最终被销毁时被Angular调用。OnInit 接口中会有一个带有初始化逻辑的ngOnInit方法，可以用来初始化。 承诺，在有了结果时，它承诺会回调我们。 我们请求一个异步服务去做点什么，并且给它一个回调函数。 它会去做（在某个地方），一旦完成，它就会调用我们的回调函数，并通过参数把工作结果或者错误信息传给我们。 123getHeroes(): void &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);&#125; 这个方法基于承诺的，并在承诺的事情被解决时再行动。 一旦承诺的事情被成功解决，就会显示英雄数据。then方法把回调函数作为参数传给承诺对象。 路由路由告诉路由器，当用户点击链接或者把 URL 粘贴到浏览器地址栏时，应该显示哪个视图。 路由定义包括以下部分： path: 路由器会用它来匹配浏览器地址栏中的地址，如heroes。 component: 导航到此路由时，路由器需要创建的组件（HeroesComponent）。 路由有两种实现方式： 第一种是通过RouterLink指令，绑定到heroes的路由路径，在app.module.ts中指定了&#39;/heroes&#39;就是指向HeroesComponent的那个路由的路径，并且需要告诉路由把激活的组件显示在&lt;router-outlet&gt;里面。 12345template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a routerLink="/heroes"&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; ` 1234567891011121314151617181920212223@NgModule(&#123; imports: [ BrowserModule, FormsModule, RouterModule.forRoot([ &#123; path: 'heroes', component: HeroesComponent &#125; ]) ], declarations: [ AppComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123;&#125; 第二种是通过函数来实现，触发click事件后，调用gotoDetail函数，该函数将路由导航到detail的组件上。 123gotoDetail(): void &#123; this.router.navigate(['/detail', this.selectedHero.id]);&#125; 1&lt;button (click)="gotoDetail()"&gt;View Details&lt;/button&gt; 浏览器启动时，在地址栏中使用的路径是/。如果要在应用启动的时候就显示仪表盘，而且希望在浏览器的地址栏看到一个好看的 URL，比如/dashboard，这就需要用到重定向： 12345&#123; path: '', redirectTo: '/dashboard', pathMatch: 'full'&#125;, 设置moduleId属性到module.id后，才能使用templateUrl。 路径中的冒号 (:) 表示:id是一个占位符: 1234&#123; path: 'detail/:id', component: HeroDetailComponent&#125;, 通过[routerLink]绑定了一个包含链接参数数组的表达式。 该数组有两个元素，目标路由和一个用来设置当前英雄的 id 值的路由参数。这两个元素与上面定义中的 path 和 :id 对应。 1&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt; 典型路由模块值得注意的有： 将路由抽出到一个变量中。你将来可能会导出它，而且它让路由模块模式更加明确。 添加RouterModule.forRoot(routes)到imports。 添加RouterModule到exports，这样关联模块的组件可以访问路由的声明，比如RouterLink和RouterOutlet。 无declarations！声明是关联模块的任务。 如果你有守卫服务，添加模块providers。 Angular路由器提供了routerLinkActive指令，我们可以用它来为匹配了活动路由的 HTML 导航元素自动添加一个 CSS 类。 12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink="/dashboard" routerLinkActive="active"&gt;Dashboard&lt;/a&gt; &lt;a routerLink="/heroes" routerLinkActive="active"&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 123nav a.active &#123; color: #039be5;&#125; 好不容易走到路由这步，我按照我的理解画了一个脑图： HTTP待写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON那些事]]></title>
      <url>%2F2016%2F12%2F18%2FJSON%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[最近用echarts时和json打交道比较多，在此记录一下关于json的一些事情。 什么是JSONw3school上给出的描述是： JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 * JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON数据书写格式是： 1name : value 其中value的值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON对象与JSON数组JSON对象JSON对象在{}中书写，对象可以包含多个键值对； 1&#123;"firstName":"John" , "lastName":"Doe"&#125; 一般JSON对象中有多个键值对时，用,隔开，最后一个键值对结束时可以不写,。 JSON数组JSON数组在[]中书写，数组可以包含多个对象。 举个栗子： 1234567&#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ]&#125; &quot;employees&quot;这个json对象包含了三个json对象的数组。 JSON的操作获取value举个例子: 12345var employees = [&#123; "firstName":"Bill" , "lastName":"Gates" &#125;,&#123; "firstName":"George" , "lastName":"Bush" &#125;,&#123; "firstName":"Thomas" , "lastName": "Carter" &#125;]; 如果要得到Bill的firstName，可以这样写： 1employees[0].firstName; 因为employees是数组，首先通过employees[0]来获取第一个对象，然后用.加要访问的字段名称，就可以获取该字段对应的值。 添加和删除JSON对象1234567var json = &#123;&#125;; //空json对像 json['firstname'] = "cheng"; //添加二个元素 json['lastname'] = "tang"; console.log(json); delete json['lastname']; //删除json中的某个元素 console.log(json); JSON数组123456789var json1 = [&#123;"name":"tang","total":"1"&#125;,&#123;"name":"zhou","total":"2"&#125;,&#123;"name":"he","total":"3"&#125;]; var add = &#123;"name":"may"&#125;; json1.push(add); //添加一个元素 console.log(json1); delete json1[2]; //删除一个元素 console.log(json1); 遍历JSON对象假设有一个JSON对象： 1var data=&#123;'a':10,'b':20,'c':30,'d':40&#125;; 怎么遍历这个对象呢，可以用for-in: 1234567for(var n in data)&#123; console.log(n); //输出 a，b，c，d console.log(data[n]); //输出 10，20，30，40&#125; 在JavaScript中[]等同于. ，所以 data[n]可以理解为data.n，只不过n是变量，用.获取不到对应的值。 JSON数组假设有一个JSON数组： 1var data=[&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125;]; 遍历这个数组： 12345678910for(var n in data)&#123; console.log(n); //输出：0，1，2，3 console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; 或者： 1234567for (var n = 0;n &lt; data.length; n++)&#123; console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; eval()与JSON.parse()eval()可以将字符串转换为 JavaScript 对象： 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = eval('('+test+')'); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 通过这个方法我们就可以动态设置key的值。但是使用这个方法会存在潜在的安全问题，所以可以用JSON.parse()，这个方法需要较高版本的浏览器支持。 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = JSON.parse(test); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 接下来就可以通过json[key] = value来设置key对应的value值。 Object.keys() Object.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。 123456789101112var bookAuthors = &#123; "Farmer Giles of Ham": "J.R.R. Tolkien", "Out of the Silent Planet": "C.S. Lewis", "The Place of the Lion": "Charles Williams", "Poetic Diction": "Owen Barfield"&#125;;var arr = Object.keys(bookAuthors);console.log(arr);//输出: Array [ "Farmer Giles of Ham", "Out of the Silent Planet", "The Place of the Lion", "Poetic Diction" ]console.log(arr.length);//输出: 4 用这个方法可以把json对象转换成数组，这样可以方便的对这个数组进行一些操作。 1234567var test = &#123; "name ": "tangcheng", "value": [1,2,3,4,5]&#125;var arr = Object.keys(test);console.log(arr.length); //输出： 2console.log(test.length) //输出：undefined Object.keys()方法，只能使用在高版本浏览器，IE8及以下是不支持的，如果想支持IE低版本，可以参考Javascript 计算Object的长度中提供的方法。 参考文章： JSON中让key作为参数传入的方法； Javascript 计算Object的长度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰Git教程学习笔记]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%BB%96%E9%9B%AA%E5%B3%B0Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[粗略看过git方面的视频，工作之前自己写的代码量少，管理方便，git方面的知识也够用。但是最近工作的时候用git总是有各种问题，于是拿起廖雪峰老师的教程，开始撸一遍完整的。 创建版本库git创建版本库很简单，只要用以下命令即可 123$ mkdir tangcheng //创建文件夹$ cd tangcheng $ git init //创建版本库 完成后文件夹下面会有一个.git的隐藏目录，这是git的版本库。 版本库管理工作区与暂存区 廖老师的这个图很清楚，工作区就是tangcheng这个文件夹，这个文件夹里面的.git隐藏目录就是版本库。 通过git add告诉git把文件添加到仓库，然后用git commit把文件提交到仓库。 git commit成功后git会记录你的修改，如果不add到暂存区，那就不会加入到commit中。可以多次git add文件，git commit一次提交多个文件。 Git基本命令git status可以参看仓库状态; git diff可以参看difference，显示格式是Unix通用的diff格式; git log可以显示从近到远的提交日志，日志中的一大串字母和数字的组合就是版本号。 git reset --hard HEAD^表示回退版本，上一个版本是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。如果回退到上一个旧版本，当前的版本则会在log中删除，若要从上一个版本回退到已经删除的版本，需要在用回退命令的命令窗口中，通过版本号找回，例如$ git reset --hard 3628164，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 若上一段中的用回退命令的命令窗口已经关闭，可以用git reflog来查看你每一次的命令和对应操作的版本号。 git checkout -- tangcheng.txt意思就是，把tangcheng.txt文件在工作区的修改（包括删除文件的操作）全部撤销，就是让这个文件回到最近一次git commit或git add时的状态。命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。 git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区 git rm从版本库中删除文件。 远程仓库把本地仓库的内容推送到GitHub仓库，在本地的tangcheng仓库下运行命令： 1$ git remote add origin git@github.com:tangcheng/tangcheng.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 $ git push -u origin master是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 1$ git clone git@github.com:tangcheng/tangcheng.git 克隆一个本地库。GitHub给出的地址不止一个，还可以用https://github.com/tangcheng/tangcheng.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理1$ git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 12$ git branch dev$ git checkout dev 用git branch命令查看当前分支。 git branch命令会列出所有分支，当前分支前面会标一个*号。 git merge dev```把`dev`分支的工作成果合并到`master`分支上，`git merge`命令用于合并指定分支到当前分支。1234567删除`dev`分支:```sh$ git branch -d dev 当Git无法自动合并分支时，就必须首先解决冲突。Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 1$ git merge --no-ff -m "merge with no-ff" dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 要查看远程库的信息，用git remote或者，用git remote -v显示更详细的信息。 推送分支： 1$ git push origin master //把master推送到远程分支 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 标签管理git tag &lt;name&gt;就可以打一个新标签。有commit为什么还要标签呢，因为commit是很长一串数字和字母的组合，阅读性差。commit和tag的关系类似于ip和域名。 用命令git tag查看所有标签。默认标签是打在最新提交的commit上的。标签不是按时间顺序列出，而是按字母排序的。 对特定的commit id打标签： 1$ git tag v0.9 6224937 可以用git show查看标签信息 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m "version 0.1 released" 3628164 如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag 'v0.1' (was e078af9) 如果要推送某个标签到远程，使用命令git push origin： 1$ git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1$ git push origin --tags 命令git push origin :refs/tags/可以删除一个远程标签。 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理。 你确实想添加该文件，可以用-f强制添加到Git： 1$ git add -f App.class .gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查 配置别名我们只需要敲一行命令，告诉Git，以后st就表示status： 1$ git config --global alias.st status 这样以后敲git st就表示git status --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 每个仓库的Git配置文件都放在.git/config文件中，别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。 配置一个git last，让其显示最后一次提交信息： 1$ git config --global alias.last 'log -1' 这样，用git last就能显示最近一次的提交： 1234567$ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现]]></title>
      <url>%2F2016%2F12%2F08%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[最近在AngularJS2中要实现一个按钮切换的效果，我采用三目表达式和ng-class的方式来实现了这一效果，比较简单粗暴。 首先，我的项目的XX.Component.ts中的template有个button标签： 12&lt;button type="submit"&gt;列表&lt;/button&gt;&lt;button type="submit"&gt;折线图&lt;/button&gt; 创建XX.Component.css，为标签添加简单的样式（我只是举个例子，这个样式的定义还可以再优化一下）： 12345678910111213141516171819.active &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: #0086FD; padding: 5px; outline: none; width: 55px;&#125;.btn-lt &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: gray; padding: 5px; outline: none; width: 55px;&#125; 然后我需要实现的效果是：加载完页面后，两个按钮都是灰色的，当你点击其中一个按钮时，按钮变成蓝色。 为了实现这个效果，我引入了begin和blue两个变量，分别控制起始状态和点击时的状态。当blue为true且begin===1时按钮变蓝色；当blue为false时或者begin！= 1时按钮变灰色。代码如下： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 这个方法还可以组合出其他不同的效果，比如说点击后当前按钮变灰： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 比如把begin去掉，可以实现加载完成后有一个按钮处于激活状态，这里我就不做gif了，可以自己尝试一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts使用小结]]></title>
      <url>%2F2016%2F12%2F04%2FEcharts%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[这周项目上写了一个基于Angular2.0的Echarts3组件，踩了好几个坑，也算有一点使用心得了。 Echarts是什么鬼 ECharts 是指 Enterprise Charts（商业产品图表库），提供商业产品常用图表库，底层基于 ZRender，创建了坐标系，图例，提示，工具箱等基础组件，并在此上构建出折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、地图、力导向布局图，同时支持任意维度的堆积和多图表混合展现。 Echarts提供了多种图表展示方式： Echarts提供了包括值域漫游、大规模散点图、数据动态添加、数据区域漫游、图例开关、动态类型切换等在内的多种数据操作方式。Echarts升级到3.0后，增加了对移动端的支持，而且体积更小，实乃数据分析必备良药。 Echarts正确打开方式首先来看官方案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 怎么样，是不是觉得很好玩，当然这只是最基本的数据展示功能，下面我们来玩一个进阶一点的Demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="gb2312"&gt; &lt;title&gt;echarts3&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;echarts3 demo&lt;/h1&gt; &lt;!--定义有大小的DOM容器--&gt; &lt;div id="barChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="lineChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="radarChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="pieChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="dotChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;!--导入js代码--&gt; &lt;script type="text/javascript" src='./jquery.js'&gt;&lt;/script&gt; &lt;script type="text/javascript" src='./echarts.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //界面最先运行这个代码块 $(document).ready(function() &#123; initBarEcharts(); initLineEcharts(); initRadarEcharts(); initPieEcharts(); initDotEcharts(); &#125;); //初始化柱状图 function initBarEcharts() &#123; var myChart = echarts.init(document.getElementById('barChart')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, dataZoom: &#123; type: 'slider', show: true, start: 1, end: 35 &#125;, tooltip: &#123;&#125;, toolbox: &#123; show: true, feature: &#123; saveAsImage: &#123; show: true, type: 'jpeg', &#125;, restore: &#123; show: true, &#125;, dataView: &#123; show: true, &#125;, magicType: &#123; show: true, &#125; &#125;, &#125;, legend: &#123; data: ['销量'] &#125;, xAxis: &#123; //x轴数据，数组形式 data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化折线图图 function initLineEcharts() &#123; var myChart = echarts.init(document.getElementById('lineChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '堆叠区域图' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎'] &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis: [&#123; type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] &#125;], yAxis: [&#123; type: 'value' &#125;], series: [&#123; name: '邮件营销', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: '联盟广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: '视频广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: '直接访问', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [320, 332, 301, 334, 390, 330, 320] &#125;, &#123; name: '搜索引擎', type: 'line', stack: '总量', label: &#123; normal: &#123; show: true, position: 'top' &#125; &#125;, areaStyle: &#123; normal: &#123;&#125; &#125;, data: [820, 932, 901, 934, 1290, 1330, 1320] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化雷达图 function initRadarEcharts() &#123; var myChart = echarts.init(document.getElementById('radarChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '基础雷达图' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['预算分配（Allocated Budget）', '实际开销（Actual Spending）'] &#125;, radar: &#123; // shape: 'circle', indicator: [&#123; name: '销售（sales）', max: 6500 &#125;, &#123; name: '管理（Administration）', max: 16000 &#125;, &#123; name: '信息技术（Information Techology）', max: 30000 &#125;, &#123; name: '客服（Customer Support）', max: 38000 &#125;, &#123; name: '研发（Development）', max: 52000 &#125;, &#123; name: '市场（Marketing）', max: 25000 &#125;] &#125;, series: [&#123; name: '预算 vs 开销（Budget vs spending）', type: 'radar', // areaStyle: &#123;normal: &#123;&#125;&#125;, data: [&#123; value: [4300, 10000, 28000, 35000, 50000, 19000], name: '预算分配（Allocated Budget）' &#125;, &#123; value: [5000, 14000, 28000, 31000, 42000, 21000], name: '实际开销（Actual Spending）' &#125;] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化饼图 function initPieEcharts() &#123; var myChart = echarts.init(document.getElementById('pieChart')); // 指定图表的配置项和数据 option = &#123; backgroundColor: '#2c343c', title: &#123; text: 'Customized Pie', left: 'center', top: 20, textStyle: &#123; color: '#ccc' &#125; &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, visualMap: &#123; show: false, min: 80, max: 600, inRange: &#123; colorLightness: [0, 1] &#125; &#125;, series: [&#123; name: '访问来源', type: 'pie', radius: '55%', center: ['50%', '50%'], data: [&#123; value: 335, name: '直接访问' &#125;, &#123; value: 310, name: '邮件营销' &#125;, &#123; value: 274, name: '联盟广告' &#125;, &#123; value: 235, name: '视频广告' &#125;, &#123; value: 400, name: '搜索引擎' &#125;].sort(function(a, b) &#123; return a.value - b.value &#125;), roseType: 'angle', label: &#123; normal: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125;, smooth: 0.2, length: 10, length2: 20 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#c23531', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化散点图 function initDotEcharts() &#123; var myChart = echarts.init(document.getElementById('dotChart')); // 指定图表的配置项和数据 var data = [ [ [28604, 77, 17096869, 'Australia', 1990], [31163, 77.4, 27662440, 'Canada', 1990], [1516, 68, 1154605773, 'China', 1990], [13670, 74.7, 10582082, 'Cuba', 1990], [28599, 75, 4986705, 'Finland', 1990], [29476, 77.1, 56943299, 'France', 1990], [31476, 75.4, 78958237, 'Germany', 1990], [28666, 78.1, 254830, 'Iceland', 1990], [1777, 57.7, 870601776, 'India', 1990], [29550, 79.1, 122249285, 'Japan', 1990], [2076, 67.9, 20194354, 'North Korea', 1990], [12087, 72, 42972254, 'South Korea', 1990], [24021, 75.4, 3397534, 'New Zealand', 1990], [43296, 76.8, 4240375, 'Norway', 1990], [10088, 70.8, 38195258, 'Poland', 1990], [19349, 69.6, 147568552, 'Russia', 1990], [10670, 67.3, 53994605, 'Turkey', 1990], [26424, 75.7, 57110117, 'United Kingdom', 1990], [37062, 75.4, 252847810, 'United States', 1990] ], [ [44056, 81.8, 23968973, 'Australia', 2015], [43294, 81.7, 35939927, 'Canada', 2015], [13334, 76.9, 1376048943, 'China', 2015], [21291, 78.5, 11389562, 'Cuba', 2015], [38923, 80.8, 5503457, 'Finland', 2015], [37599, 81.9, 64395345, 'France', 2015], [44053, 81.1, 80688545, 'Germany', 2015], [42182, 82.8, 329425, 'Iceland', 2015], [5903, 66.8, 1311050527, 'India', 2015], [36162, 83.5, 126573481, 'Japan', 2015], [1390, 71.4, 25155317, 'North Korea', 2015], [34644, 80.7, 50293439, 'South Korea', 2015], [34186, 80.6, 4528526, 'New Zealand', 2015], [64304, 81.6, 5210967, 'Norway', 2015], [24787, 77.3, 38611794, 'Poland', 2015], [23038, 73.13, 143456918, 'Russia', 2015], [19360, 76.5, 78665830, 'Turkey', 2015], [38225, 81.4, 64715810, 'United Kingdom', 2015], [53354, 79.1, 321773631, 'United States', 2015] ] ]; option = &#123; backgroundColor: new echarts.graphic.RadialGradient(0.3, 0.3, 0.8, [&#123; offset: 0, color: '#f7f8fa' &#125;, &#123; offset: 1, color: '#cdd0d5' &#125;]), title: &#123; text: '1990 与 2015 年各国家人均寿命与 GDP' &#125;, legend: &#123; right: 10, data: ['1990', '2015'] &#125;, xAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125; &#125;, yAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125;, scale: true &#125;, series: [&#123; name: '1990', data: data[0], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(120, 36, 50, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(251, 118, 123)' &#125;, &#123; offset: 1, color: 'rgb(204, 46, 72)' &#125;]) &#125; &#125; &#125;, &#123; name: '2015', data: data[1], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(25, 100, 150, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(129, 227, 238)' &#125;, &#123; offset: 1, color: 'rgb(25, 183, 207)' &#125;]) &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Echarts与Angular2.0我做组件的时候定义了ky-line标签，通过&lt;ky-line [data]=&quot;myoption&quot;&gt;&lt;/ky-line&gt;里的data属性来传递option的数据，这样拿到后端的数据后，往myoption里面push数据，并通过ky-line标签，把数据传递给Echarts中的option，这样就可以实现给echarts动态写入数据。不过要注意的是，给echarts中动态增加数据的时候，首先要搞清楚json对象和json数组的概念，不然容易出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oh_My_Zsh-终端改造]]></title>
      <url>%2F2016%2F11%2F28%2FOh-My-Zsh-%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
      <content type="text"><![CDATA[周末的时候无意中看到一篇文章终极 Shell，介绍的就是今天讲的主角Oh My Zsh 。 什么是Oh My Zsh Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 Oh My Zsh这个名字听起来就很有意思，它是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。 Oh My Zsh只是一个对zsh命令行环境的配置包装框架，但它不提供命令行窗口，更不是一个独立的APP。 更详细介绍可到官网了解，Oh My Zsh官网：http://ohmyz.sh 安装Oh My Zsh前提条件：必须已安装ZSH 我们可以在命令行中输入这个命令来查看我们的电脑上是否安装了zsh命令行 1$ zsh --version 如果安装了，这个命令就会输出zsh当前的版本号。确定 zsh 已经安装后，我们就可以继续安装Oh My Zsh了。 安装Oh My Zsh Oh My Zsh 的安装方式非常简单，可以通过curl或wget的方式，用一条命令即可安装。 curl 方式 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; wget 方式 1$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装过程中输出如下 12345678910111213141516171819202122Cloning Oh My Zsh...Cloning into &apos;/root/.oh-my-zsh&apos;...remote: Counting objects: 712, done.remote: Compressing objects: 100% (584/584), done.remote: Total 712 (delta 15), reused 522 (delta 4), pack-reused 0Receiving objects: 100% (712/712), 443.58 KiB | 27.00 KiB/s, done.Resolving deltas: 100% (15/15), done.Checking connectivity... done.Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrcCopying your current PATH and adding it to the end of ~/.zshrc for you.Time to change your default shell to zsh! __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 到这里，Oh My Zsh 就安装成功了。 设置主题安装完毕后，我们就可以使用了，咱们先来简单配置一下。Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格，主题的配置在 ~/.zshrc 文件中可以看到，用一个自己熟悉的编辑器打开这个文件，可以找到这一项： 1ZSH_THEME=&quot;robbyrussel&quot; 可以看到，我们默认使用的主题叫做robbyrussel。 Oh My Zsh默认自带了一些默认主题，存放在~/.oh-my-zsh/themes目录中。我们可以查看这些主题 12345678910111213$ ls ~/.oh-my-zsh/themes3den.zsh-theme essembeh.zsh-theme junkfood.zsh-theme rgm.zsh-themeSoliah.zsh-theme evan.zsh-theme kafeitu.zsh-theme risto.zsh-themeadben.zsh-theme example.zsh-theme kardan.zsh-theme rixius.zsh-themeaf-magic.zsh-theme fino-time.zsh-theme kennethreitz.zsh-theme rkj-repos.zsh-themeafowler.zsh-theme fino.zsh-theme kiwi.zsh-theme rkj.zsh-themeagnoster.zsh-theme fishy.zsh-theme kolo.zsh-theme robbyrussell.zsh-themealanpeabody.zsh-theme flazz.zsh-theme kphoen.zsh-theme sammy.zsh-themeamuse.zsh-theme fletcherm.zsh-theme lambda.zsh-theme simonoff.zsh-themeapple.zsh-theme fox.zsh-theme linuxonly.zsh-theme simple.zsh-themearrow.zsh-theme frisk.zsh-theme lukerandall.zsh-theme skaro.zsh-theme.... 这么多的主题可以满足你的各种偏好了，我们只需在./zshrc文件中配置需要的主题即可，比如我们想用lambda.zsh-theme这个主题，我们只要这样配置 1ZSH_THEME=lambda 请注意好多教程上这边都有&quot;&quot;，但是请把双引号去掉，不然可能安装不成功，这也算是一个小坑。 然后保存这个文件文件，再打开一个新的命令行窗口即可看到效果了。那么这么多的主题如何快速找到哪些是我们喜欢的呢，我们还可以这样设置 1ZSH_THEME=&quot;random&quot; 我们将主题设置为随机，这样在我们每次打开命令行窗口的时候，都会随机在默认主题中选择一个。这样我们如果觉得当前的主题比较喜欢，可以直接使用 echo 命令输出当前主题的名称 1$ echo $ZSH_THEME 然后再将他设置到配置文件中即可。 我使用的ys这款主题，该有的信息都能展示出来，界面如下： 启用插件Oh My Zsh 默认自带了一些默认主题，存放在~/.oh-my-zsh/plugins目录中。我们可以查看这些插件 1plugins=(git) 如需启用更多插件，可加入需启用插件的名称。如下 1plugins=(git wd web-search history history-substring-search) 更新设置自动更新oh-my-zsh 默认情况下，当oh-my-zsh有更新时，都会给你提示。如果希望让oh-my-zsh自动更新，在~/.zshrc 中添加下面这句 1DISABLE_UPDATE_PROMPT=true 要手动更新，可以执行 1$ upgrade_oh_my_zsh 卸载直接在终端中，运行uninstall_oh_my_zsh既可以卸载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo在遇到“{{”符号时出现解析报错]]></title>
      <url>%2F2016%2F11%2F24%2Fhexo%20%E5%9C%A8%E9%81%87%E5%88%B0%20%E2%80%9C%7B%7B%E2%80%9D%20%E7%AC%A6%E5%8F%B7%E6%97%B6%E5%87%BA%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99%2F</url>
      <content type="text"><![CDATA[刚刚生成了一篇文章， hexo g 时会报错， 错误信息大致如下： 123FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 128, Column 48]unexpected token: . 估计是文章的原因，试了一下，把文章移除后一切又正常了，但是就是不知道文章中哪里出错了。 网上搜了好久，发现了这篇文章：hexo 在遇到 “}}” 符号时出现解析报错。 查找资料发现有人遇到和我类似的问题，但报的是 `unexpected token: }}的错误。搜索一下我那篇文章，果然有好几处带有 }} 符号。尝试着把几处符号删除，果然正常了。看来问题真的出在 }}上面。 直接说解决方案吧，参考别人的解决方法是在 }}中间加一个空格，但因为我的是有部分教程含义的文章，所以并不想这样误导人。于是去 github 上找解决方案。 github 上给出的方法是在需要显示 }}符号的地方加上 ` 标签，标记这部分不需要解析。例如文章中可能会出现 `` 的片段，写成 `{{ something }} 就可以了。 虽然有点麻烦，但也算临时解决了这个问题，这是个已知 bug ，希望后续的版本能修复吧，毕竟使用太多 hexo 专属的标签对博客以后的迁移、改版什么的来说还是很麻烦的。 但是`` 标签在代码块中会显示出来，前一篇文章的代码块中的}}符号我就用空格隔开了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《AngularJS实战》学习笔记]]></title>
      <url>%2F2016%2F11%2F24%2F%E3%80%8AAngularJS%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[快速上手Angular核心特征–MVCMVC:model,view,controller Model：数据模型层 view：视图层、负责展示 Controller：业务逻辑与控制逻辑 MVC是一种架构模式，是三种设计模式的合体，故没有把它当做一种设计模式。 GoF (Gang of Four，四人组， 《Design Patterns: Elements of Reusable Object-Oriented Software》/《设计模式》一书的作者：Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)并没有把MVC提及为一种设计模式，而是把它当做“一组用于构建用户界面的类集合”。在他们看来，它其实是其它三个经典的设计模式的演变：观察者模式(Observer)(Pub/Sub), 策略模式(Strategy)和组合模式(Composite)。根据MVC在框架中的实现不同可能还会用到工厂模式(Factory)和装饰器(Decorator)模式。我在另一本免费的书“JavaScript Design Patterns For Beginners”中讲述了这些模式，如果你有兴趣可以阅读更多信息。 正如我们所讨论的，models表示应用的数据，而views处理屏幕上展现给用户的内容。为此，MVC在核心通讯上基于推送/订阅模型(惊讶的是 在很多关于MVC的文章中并没有提及到)。当一个model变化时它对应用其它模块发出更新通知(“publishes”)，订阅者 (subscriber)——通常是一个Controller，然后更新对应的view。观察者——这种自然的观察关系促进了多个view关联到同一个 model。 对于感兴趣的开发人员想更多的了解解耦性的MVC(根据不同的实现)，这种模式的目标之一就是在一个主题和它的观察者之间建立一对多的关系。当这个 主题改变的时候，它的观察者也会得到更新。Views和controllers的关系稍微有点不同。Controllers帮助views对不同用户的输 入做不同的响应，是一个非常好的策略模式列子。 Angular核心2–模块化html代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html ng-app="HellloAngular"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="helloAngular"&gt; &lt;!--控制器--&gt; &lt;p&gt;&#123; &#123; greeting.text&#125; &#125;,Angular&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;script src="HelloAngular_MVC.js"&gt;&lt;/script&gt;&lt;/html&gt; JS代码： 123456789var myModule = angular.module("HellloAngular", []); //创建模块myModule.controller("helloAngular", ['$scope', //创建控制器，并注入$scope function HelloAngular($scope) &#123; $scope.greeting = &#123; text: 'Hello' &#125;; &#125;]); 只有把模块创建出来以后，才能调用模块下面的方法。 1&lt;html ng-app="moduleName"&gt; Angular核心特征3–指令系统指令系统可以自定义标签： 123456789var myMoudle=angular.module("MyMoudle",[]);myMoudle.directive("hello",function () &#123; return &#123; restrict: 'E', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', //模板，替换了&lt;hello&gt; replace: true &#125;&#125;); 123456789101112&lt;!DOCTYPE html&gt;&lt;html ng-app="MyMoudle"&gt; &lt;!--ng-app相当于java中的main方法，表示从ng-app开始下面所有内容归angularjs管理--&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hello&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;script src="Hello.js"&gt;&lt;/script&gt;&lt;/html&gt; Angular核心特征4–双向数据绑定 数据更新View自动更新，view更新数据也跟着更新。 只用一个html文件实现输入的文字立刻出现在下方。（第一次看到时第一反应是，这货是黑科技~） 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;input ng-model="greeting.text"/&gt; &lt;!--生成数据模型--&gt; &lt;p&gt;&#123; &#123; greeting.text&#125; &#125;,AngularJS&lt;/p&gt; &lt;!--双括号在Angular中表示取值--&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;/html&gt; 开发、调试、测试工具 代码编辑工具：sublime、webstorm 断点调试工具：chrome插件batarang 版本管理工具：git、git小乌龟 代码合并和混淆工具：grunt 依赖管理工具：bower 单元测试工具：karma、jasmine 集成测试工具：protractor（专为AngularJS定制的测试工具） app放源代码 test下面分集成测试e2e和单元测试unit两个目录 基本概念和用法MVC MVC只是手段，终极目标是模块化和复用 AngularJS中Controller的实现方式 不要试图去复用Controller，一个控制器一般只负责一小块视图 不要在Controller中操作DOM，这不是控制器的职责 不要在Controller里面做数据格式化，ng有很好用的表单控件 不要在Controller里面做数据过滤操作，ng有$filter服务 一般来说，Controller是不会互相调用的，控制器之间的交互会通过事件进行 利用Directive实现View的复用。 AngularJS的MVC是借助于$scope实现的: $scope是一个POJO（Plain Old JavaScript Object） $scope提供了一些工具方法$watch()/$apply() $scope是表达式的执行环境（或者叫作用域） $scope是一个树形结构，与DOM标签平行 子$scope对象会继承父$scope上的属性和方法 每一个angular应用只有一个根$scope对象（一般位于ng-app上） $scope可以传播事件，类似DOM事件，可以向上也可以向下 $scope不仅是MVC的基础，也是后面实现双向数据绑定的基础 可以用angular.element($0).scope()进行调试 路由、模块、依赖注入 使用ngRoute进行视图之间的路由： 1234567891011121314151617 //创建模块，并指定模块依赖var bookStoresApp = angular.module('bookStoreApp',[ 'ngRoute','ngAnimate','bookStoreCtrls','bookStoreFilters', 'bookStoreServices','bookStoreDirectives']);bookStoreApp.config(function($routePrivider)&#123; //根据url后缀的不同，加载不同的模板，并且用不同的控制器控制 $routePrivider.when('/hello',&#123; templateUrl: 'tpls/hello.html', controller: 'HelloCtrl' &#125;).when('/list',&#123; templateUrl: 'tpls/booklist.html', controller: 'BookListCtrl' &#125;).otherwise(&#123; redirectTo: '/hello' &#125;)&#125;); ng官方推荐的模块切分方式： 任何一个ng应用都是由控制器、指令、服务、路由、过滤器、等有限的模块类型构成 控制器、指令、服务、过滤器分别放在一个模块里面（可借助与Grunt合并） 用一个总的app模块作为入口点，它依赖其他所有模块 双向数据绑定举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="UserInfoModule"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="Form.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt;双向数据绑定&lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;form class="form-horizontal" role="form" ng-controller="UserInfoCtrl"&gt; &lt;!--controller--&gt; &lt;div class="form-group"&gt; &lt;label class="col-md-2 control-label"&gt; 邮箱： &lt;/label&gt; &lt;div class="col-md-10"&gt; &lt;input ng-model="userInfo.email" placeholder="推荐使用126邮箱" type="email" class="form-control"&gt;&lt;!--调用userInfo中的email值--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-md-2 control-label"&gt; 密码： &lt;/label&gt; &lt;div class="col-md-10"&gt; &lt;input ng-model="userInfo.password" type="password" class="form-control" placeholder="只能是数字、字母及下划线"&gt; &lt;!--调用userInfo中的password值--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-offset-2 col-md-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" ng-model="userInfo.autoLogin"&gt;自动登录 &lt;!--调用userInfo中的checkbox值--&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-offset-2 col-md-10"&gt; &lt;button class="btn btn-default" ng-click="getFormData()"&gt;获取form表单的值&lt;/button&gt; &lt;button class="btn btn-default" ng-click="setFormData()"&gt;设置form表单的值&lt;/button&gt; &lt;button class="btn btn-default" ng-click="restFormData()"&gt;重置form表单的值&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930var userInfoModule = angular.module('UserInfoModule', []);userInfoModule.controller('UserInfoCtrl', ['$scope', function ($scope) &#123; //初始化userInfo数据 $scope.userInfo = &#123; email: '111@126.com', password: '112231', autoLogin: true &#125;; //获取表单中的数据 $scope.getFormData = function () &#123; console.log($scope.userInfo); &#125;; //设置表单中的数据 $scope.setFormData = function () &#123; $scope.userInfo = &#123; email: 'dddd@126.com', password: '11111', autoLogin: false &#125; &#125;; //重置表单数据 $scope.restFormData = function () &#123; $scope.userInfo = &#123; email: '111@126.com', password: '112231', autoLogin: true &#125;; &#125;&#125;]); ng-class可以做一些样式控制，比如 &lt;div ng-class=&#39;{error:isError,warning:isWaring}&#39;&gt;{ { messageText} }&lt;/div&gt; ng-show=&#39;menuState.show&#39;可以通过$scope.menuState={show:false};控制显示或者隐藏，show的值为false时隐藏，true时显示。通过ng-hide=&quot;&quot;也可以达到同样的效果。 路由可以用UI-Router来代替Angular自带的router功能。 前端路由的基本原理： 哈希# 点击后不会跳转，相当于设置了锚点，只在页内跳转 HTML5中新的historyAPI 通过js代码修改浏览器地址栏中的地址，会在浏览器中留下历史记录，但是页面不会跳转 路由的核心是给应用定义“状态” 使用路由机制会影响到应用的整体编码方式（需要预先定义好状态） 考虑兼容性问题和“优雅降级” 指令123456789101112&lt;!DOCTYPE html&gt;&lt;html ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hello&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script src="../Demo4-TwowayDataBinding/angular.min.js"&gt;&lt;/script&gt;&lt;script src="Hello.js"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myMoudle=angular.module("MyMoudle",[]);myMoudle.directive("hello",function () &#123; return &#123; restrict: 'E', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', //模板，替换了&lt;hello&gt; replace: true &#125;&#125;); restrict表示匹配模式，共有AEMC四个选项: A表示属性,&lt;div hello&gt;，是默认的匹配模式 E表示元素,&lt;hello&gt;， M表示注释,&lt;!-- directive:hello --&gt; &lt;div&gt;&lt;/div&gt;，(注意注释中的空格) C表示CSS的样式类,&lt;div class=&#39;hello&#39;&gt; A和E两种匹配模式比较常用，当需要创建带有自己的模板的指令时，使用元素名称的方式创建指令；当需要为已有的HTML标签增加功能时，使用属性的方式创建指令。 template表示模板，这里可以用templateURL来实现（需要导入templateUrl.js），即templateUrl: &#39;hello.html&#39;把已有的模板写在单独的html文件中。templateCache可以让模板不仅在一个地方使用，还可以在其他地方使用，Angular会把模板缓存起来，以便后续使用。 12345678910111213var myModule=angular.module('MyModule',[]);//run方法表示注射器加载完所有的模块时，此方法执行一次myModule.run(function($templateCache)&#123; $templateCache.put("hello.html","&lt;div&gt;Hello everyone&lt;/div&gt;")&#125;);myModule.directive("hello",function($templateCache)&#123; return&#123; restrict: 'AECM', template: $templateCache.get("hello.html"), replace:true &#125;&#125;) replace表示标签里面嵌套的内容被模板全部替换 transclude表示保留标签里面的内容: 12345678var myModule=angular.module('MyModule',[]);myModule.directive("hello",function()&#123; return&#123; restrict: "AE", transclude: true, template: "&lt;div&gt;Hello everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;" &#125;&#125;) ng-transclude表示原来标签里面嵌套的内容放在此处。 指令执行的机制 compile函数用来对模板自身进行转换，而link函数负责在模型和视图之间进行动态关联； 作用域在链接阶段才会被绑定到编译之后的link函数上； compile函数仅仅在编译阶段运行一次，而对于指令的每一个实例，link函数都会执行一次； compile函数可以返回prelink和postlink函数，而link函数只会返回postlink函数； 如果需要修改DOM结构，应该在postlink中来做这件事情，而如果在prelink中做这件事情会导致错误； 大多数时候我们只要编写link函数即可 指令和控制器之间的交互1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="Myctrl"&gt; &lt;loader&gt;滑动加载&lt;/loader&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="Directive.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819var myModule=angular.module("MyModule",[]);myModule.controller("MyCtrl",["$scope",function ($scope) &#123; $scope.loadData=function () &#123; console.log("加载数据中"); &#125;&#125;]);myModule.directive("loader",function () &#123; return&#123; restrict: "AE", link: function (scope,element,attrs) &#123; //用link来实现监听事件 element.bind("mouseenter",function () &#123; // scope.loadData(); //第一种写法 scope.$apply('loadData()'); //第二种写法 &#125;) &#125; &#125;&#125;); 若需要根据不同的控制器调用不同的方法，需要用到指令上定义的属性。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="Myctrl"&gt; &lt;loader howToLoad="loadData()"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller="Myctrl2"&gt; &lt;loader howToLoad="loadData2()"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="Directive.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819202122232425var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.loadData=function () &#123; console.log("加载数据中"); &#125;&#125;]);myModule.controller("Myctrl2",["$scope",function ($scope) &#123; $scope.loadData2=function () &#123; console.log("加载数据中。。。"); &#125;&#125;]);myModule.directive("loader",function () &#123; return&#123; restrict: "AE", link: function (scope,element,attrs) &#123; element.bind("mouseenter",function (event) &#123; //前面howtoload是按驼峰法则写的，但这边需要写成小写，这是一个坑，要注意。还有howtoload不要写成函数调用形式。 scope.$apply(attrs.howtoload); &#125;); &#125; &#125;&#125;); 上述代码实现了指令的复用，指令load通过howtoload属性实现了与控制器的交互，通过不同的控制器控制不同的属性，实现load输出的不同，可以简单的理解为标签load通过自身的howtoload属性，调用不同的控制器，实现不同的输出。 指令之间的交互123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="superman.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman strength&gt;动感超人-力量&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman speed strength&gt;动感超人2-力量+敏捷&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman light speed strength&gt;动感超人3-力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var myMoudle = angular.module("MyMoudle", []);myMoudle.directive("superman", function () &#123; return &#123; scope: &#123;&#125;, //创建独立的作用域 restrict: "AE", controller: function ($scope) &#123; /*指令内部的controller，用来暴露一组public的方法给外面调用*/ $scope.abilities = []; this.addStrength = function () &#123; $scope.abilities.push("strength"); &#125;; this.addSpeed = function () &#123; $scope.abilities.push("speed"); &#125;; this.addLight = function () &#123; $scope.abilities.push("light"); &#125;; &#125;, //link是用来处理指令内部的事物（绑定事件等），controller是暴露方法给外面调用 link: function (scope, element, attrs) &#123; element.addClass('btn btn-primary'); element.bind("mouseenter", function () &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myMoudle.directive("strength", function () &#123; return &#123; //require表示指令依赖于Superman require: '^superman', //Angular处理的时候会把supermanCtrl注入link中，这样就可以调用superman的addStrength()函数 link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myMoudle.directive("speed", function () &#123; return &#123; require: '^superman', link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myMoudle.directive("light", function () &#123; return &#123; require: '^superman', link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); 指令之间的交互方式是通过指令内部controller暴露出来的方法，来给外部调用。 若没有独立scope，scope之间会相互影响。 scope的绑定策略： @:把当前属性作为字符串传递。你还可以绑定来自外层scope的值，在属性值中插入{ { } }即可 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; &lt;drink flavor="&#123; &#123; ctrlFlavor&#125; &#125;"&gt;&lt;/drink&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scopeAT.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.ctrlFlavor="bb";&#125;]);myModule.directive("drink",function () &#123; return&#123; restrict: 'AE', template: '&lt;div&gt;&#123; &#123; flavor&#125; &#125;&lt;/div&gt;', scope: &#123; //作用等价于下面的link,获取控制器中的flavor flavor: '@' &#125;/*, link: function (scope,element,attrs) &#123; scope.flavor=attrs.flavor; &#125;*/ &#125;&#125;); =：与父scope中的属性进行双向绑定 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; Ctrl: &lt;br&gt; &lt;input type="text" ng-model="ctrlFlavor"&gt; &lt;br&gt; Directive: &lt;br&gt; &lt;drink flavor="ctrlFlavor"&gt;&lt;/drink&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scope-equal.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.ctrlFlavor="bb";&#125;]);myModule.directive("drink",function () &#123; return&#123; restrict: 'AE', template: '&lt;input type="text" ng-model="flavor"/&gt;', //控制器和指令中的内容同步 scope: &#123; flavor: '=' &#125; &#125;&#125;); ​ &amp;：传递一个来自父scope的函数，稍后调用 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scope-and.js"&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112131415var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.sayHello=function (name) &#123; alert("Hello"+name); &#125;&#125;]);myModule.directive("greeting",function () &#123; return&#123; restrict: 'AE', template: '&lt;input type="text" ng-model="userName"/&gt;&lt;br&gt;'+'&lt;button class="btn btn-default" ng-click="greet(&#123;name:userName&#125;)"&gt;Greeting&lt;/button&gt;&lt;br&gt;',//这边的name绑定到上面的userName scope: &#123; greet: '&amp;' &#125; &#125;&#125;); AngularJS内置的指令 form指令 html原生form表单是不能嵌套的，而Angular封装之后的form可以嵌套； Angular为form扩展了自动校验、防止重复提交等功能； Angular对input元素的type进行了扩展，一共提供了以下10种类型：text、number、url、email、radio、checkbox、hidden、button、submit、reset； Angular为表单内置了4种CSS样式：ng-valid、ng-invalid、ng-pristine、ng-dirty； 内置校验器：require、minlength、maxlength。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="form.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name="myForm" ng-submit="save()" ng-controller="TestFormModule"&gt; &lt;input type="text" name="userName" ng-model="user.userName" required/&gt; &lt;!--required表示自动校验--&gt; &lt;input type="password" name="password" ng-model="user.password" required/&gt; &lt;input type="submit" ng-disabled="myForm.$invalid"/&gt; &lt;!--绑定到$invalid的属性上--&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910var appModule=angular.module('MyMoudle',[]);appModule.controller('TestFormModule',function ($scope) &#123; $scope.user=&#123; userName: 'aaaaa', password: '' &#125; ; $scope.save=function () &#123; alert("保存数据"); &#125;&#125;); expander指令 expander指令是自定义指令 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="expander.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="SomeController"&gt; &lt;expander class="expander" expander-title="title"&gt; &#123; &#123; text&#125; &#125; &lt;/expander&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425var appModule = angular.module('MyMoudle', []);appModule.directive('expander', function () &#123; return &#123; restrict: 'AE', replace: true, transclude: true, scope: &#123; title: '=expanderTitle' &#125;, template: '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123; &#123; title&#125; &#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', /*ng-show决定了是否显示*/ link: function (scope, element, attrs) &#123; scope.showMe = false; scope.toggle = function () &#123; scope.showMe = !scope.showMe; &#125; &#125; &#125;&#125;);appModule.controller('SomeController', function ($scope) &#123; $scope.title = '点击展开'; $scope.text = '这里是内部内容';&#125;); according指令 封装一个比较复杂的according指令 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="according.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller="SomeController"&gt;&lt;div&gt; &lt;according&gt; &lt;expander class="expander" expander-title="expander.title" ng-repeat="expander in expanders"&gt; &#123; &#123; expander.text&#125; &#125; &lt;/expander&gt; &lt;/according&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var appModule = angular.module('MyMoudle', []);appModule.directive('according',function () &#123; return&#123; restrict: 'AE', replace: true, transclude: true, template: '&lt;div ng-transclude&gt;&lt;/div&gt;', controller: function () &#123; var expanders=[]; this.gotOpened=function (selectedExpander) &#123; angular.forEach(expanders,function (expander) &#123; if (selectedExpander != expander)&#123; expander.showMe=false; &#125; &#125;) &#125;; this.addExpander=function (expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);appModule.directive('expander', function () &#123; return &#123; restrict: 'AE', replace: true, transclude: true, require: '^?according', scope: &#123; title: '=expanderTitle' &#125;, template: '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123; &#123; title&#125; &#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', /*ng-show决定了是否显示*/ link: function (scope, element, attrs,accordingController) &#123; scope.showMe = false; accordingController.addExpander(scope); scope.toggle = function () &#123; scope.showMe = !scope.showMe; accordingController.gotOpened(scope); &#125; &#125; &#125;&#125;);appModule.controller('SomeController', function ($scope) &#123; $scope.expanders=[&#123; title: 'Click me to expander', text: 'Hi' &#125;,&#123; title: 'Click this', text: 'Yes' &#125;,&#123; title: 'Test', text: 'test' &#125;];&#125;); angular-ui提供了现成的指令库，可直接使用。 以miniui为例子 Service与Provider使用$HTTP服务类似Ajax 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="http.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="LoadDataCtrl"&gt; &lt;ul&gt; &lt;li ng-repeat="user in users"&gt; &#123; &#123; user.name&#125; &#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314var myModule=angular.module('MyMoudle',[]);myModule.controller('LoadDataCtrl',['$scope','$http',function ($scope,$http) &#123; $http(&#123; method: 'GET', url: 'data.json' &#125;).success(function (data,status,header,config) &#123; console.log("success"); console.log(data); $scope.users=data; &#125;).error(function (data,status,header,config) &#123; console.log("error"); &#125;)&#125;]); Service的特性 Service都是单例的 Service由$injector负责实例化,不需要new Service在整个应用的生命周期中存在，可以用来共享数据 在需要使用的地方利用依赖注入机制注入Service 自定义的Service需要写在内置的Service后面 内置Service的命名以$符号开头，自定义的Service应该避免 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="MyService1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="LoadDataCtrl"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type="text" ng-model="username" placeholder="请输入用户名"/&gt; &lt;pre ng-show="username"&gt;&#123; &#123; users&#125; &#125;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132var myModule=angular.module('MyMoudle',[]);myModule.factory('userListService',['$http',function ($http) &#123; var doRequest=function (username,path) &#123; return $http(&#123; method: 'GET', url: 'users.jon' &#125;); &#125; return &#123; userList: function (username) &#123; return doRequest(username,'userList'); &#125; &#125;;&#125;]);//自定义的服务放在最后myModule.controller('serviceController',['$scope','$timeout','userListService',function ($scope,$timeout,userListService) &#123; var timeout; //防止频繁向后台请求，导致页面抖动，350ms不按键就传输数据 $scope.$watch('username',function (newUserName) &#123; if (newUserName)&#123; if(timeout)&#123; $timeout.cancel(timeout); &#125; timeout=$timeout(function () &#123; userListService.userList(newUserName).success(function (data,status) &#123; $scope.users=data; &#125;); &#125;,300); &#125; &#125;);&#125;]); Service、Provide、Factory本质都是Provider Provider模式是“策略模式”+“抽象工厂模式”的混合体 使用$filter服务 $filter是用来进行数据格式化的专用服务 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="filter.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--利用内置的filter把毫秒转化成日期--&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date &#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date:"MM/dd/yyyy@h:mma"&#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date:"yyyy-MM-dd hh:mm:ss"&#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 1var myModule=angular.module('MyMoudle',[]); AngularJS内置了9个filter：currency（用来格式化货币），date（用来格式化日期），json，limitTo，lowercase，number，oderBy（排序），uppercase filter可以嵌套使用（用管道符号|分隔） filter是可以传递参数的 用户可以定义自己的filter 其他常用的Service内置的共有24个 $compile：编译服务 $filter：数据格式化工具，内置8个 $interval $timeout $locale：用来做国际化 $location：监控浏览器地址栏中的变化 $log：提供日志 $parse $http：封装了Ajax]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小记]]></title>
      <url>%2F2016%2F11%2F14%2F%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[工作终于有了着落，也算半只脚跨入了心仪已久的行业。 因为行业跨度太大，一路走来承受了很多压力，也很庆幸自己真的走过来了。 这几个月经常为了一个问题弄到凌晨三四点，每天一成不变的白米饭加老干妈。自己也迷茫过、质疑过、崩溃过，但是既然自己选择了这条路，那就要走到底。 感谢女朋友的陪伴，在我迷茫、崩溃的时候依然愿意在我身边。 感谢汪汪和田野的帮助，给了我那么一大箱的书，耐心解答我的问题，把我这个门外汉一步步领进门。 很庆幸，在年轻的时候能尝试去做自己想做的事情，尽管前路漫漫，充满更多的未知。 希望多年后，自己依然对技术保持一颗火热的心，依然充满激情。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于有自己的域名啦]]></title>
      <url>%2F2016%2F11%2F12%2F%E7%BB%88%E4%BA%8E%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E5%95%A6%2F</url>
      <content type="text"><![CDATA[双十一大家都在买买买的时候，有一个小码农也不甘寂寞，默默地在Namecheap上买了一个域名，完成了双十一的剁手之旅。 剁手之旅参照了新版Namecheap注册域名详细教程，还是比较简单的。不过我的域名解析用的是DNSPOD，没有用Namecheap的域名解析，这样国内的用coding访问，国外用github访问，可以加快网站访问速度。 Github的设置比较简单，在/hexo/source中添加一个CNAME文件，注意不需要后缀名，里面内容就写tc9011.com，不要写www。然后去github page上绑定一下域名，DNS解析的话我是这样设置的： 下面说一下新版的coding绑定域名的问题，我发现这是一个大坑啊~~ 我直接访问tc9011.github.io地址会跳转到tc9011.com,我直接访问tc9011.coding.me发现不会跳转到tc9011.com这个域名，原因我搜了一下，答案如下： github只能绑定一个域名，所以访问tengj.github.io时，github的服务器知道要往tengj.top跳转。coding可以绑定多个域名，当绑定多个域名时，访问tengj.coding.me,coding的服务器不知道要往哪里跳转，所以干脆就不跳转了。但是当绑定一个时，为什么不跳转，可能是coding觉得麻烦，就不跳转了。这些都是coding定的，我们没办法改变。 你先想一个问题：那么多人都要在github上搞博客，还要自定义域名。github哪来这么多ip给你们用？所以办法就是仅仅提供一个ip，这样必然导致这个服务器上发着所有人的博客文件，那么如何区分特定的域名应该展示谁的博客呢？答案就是在仓库里面新建一个CNAME文件，里面写上你博客想用的域名，github的服务器会根据当前http请求的Host头部（即域名），查找对应的包含相同的CNAME内容的目录，从而显示其中的页面。这就是为什么要在仓库里面创建一个CNAME原因。 不过，事情还没完，一个ip的问题是世界各地不同地点的访问速度不同，有些地方可能很慢，所以需要一组ip来分担一下。最早github好像只有2个ip，后来ip变多了。再后来，github支持域名解析的时候，通过alias来。比如在域名商那边设置成www.tengj.com ---&gt; tengj.github.io，由于github无法控制你如何配置域名和ip的关系，但他可以控制tengj.github.io的最终ip解析，所以github推荐大家使用alias解析，可以为博主提供就近ip访问。这就是你在域名商那边配置CNAME或者alias的原理。这里的CNAME跟上面提到的CNAME作用不同，不是一个概念，不要混淆。 还有就是coding.me的现在是指向国外的，不像以前是指向国内的，我也是醉了~ 要把博客同步到coding，首先要在coding里面新建一个与你Global Key（也就是个性后缀）一样的项目，然后修改博客根目录下面的_config.yml文件中的deploy如下（注意缩进）： 和github一样配置ssh，过程就不详细说了，比较简单。比较重要的是，在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 12cd source/touch Staticfile #名字必须是Staticfile 接下来在coding pages服务中绑定域名，注意分支一定要写master。 最后去DNSPOD上设置一下域名解析： 然后检测一下域名解析是否正确，国内解析到coding，国外解析到github，后面国外的解析很多是解析到美国 Fastly公司CDN网络节点，这个就是github的解析，所以国内的解析估计就是coding了，虽然也是指向国外，ORZ。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[近期对HEXO博客的一些优化]]></title>
      <url>%2F2016%2F11%2F08%2F%E8%BF%91%E6%9C%9F%E5%AF%B9HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前几天参加了一场面试，面试时展示我的博客时，发生了一个比较尴尬的事情：博客打开页面空白，此时我内心是崩溃的，明明昨天晚上还好好的。。。 回来后我就开始着手对我的博客进行bug调试和优化。 CSS JS 404导致博客页面空白首先解决这个问题，，在上网简单搜索了一下，导致这个结果的原因应该是： GitHub Pages 过滤掉了 source/vendors 目录的访问，所以next主题下的source下的vendors目录不能够被访问到，所以就出现了本地hexo s能够正常访问，但是deploy到github就是一片空白，按f12，可以看到大量来自source/vendors的css和js提示404 参考回答 解决方案正如github里面说说的： 找到解决方案了。。 @BBBOND @monsterLin @SpadeRoy 根据作者的提示 @iissnan ，首先修改source/vendors为source/lib，然后修改_config.yml， 将 _internal: vendors修改为_internal:lib 然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。 然而我觉得这个太麻烦了，毕竟要改很多东西，既然新版本已经修复这个问题了，那我就重新安装吧。安装前先把文件先备份了一下，然后就按照Next官网的说明，使用git来clone最新版本（之前我是下载安装）。 在终端窗口下，用cd定位到Hexo站点目录，然后clone，具体代码如下： $ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next cd后面的“your-hexo-site”改成你自己的hexo路径。 安装完了把主题目录下的_config.yml文件替换成更新前的文件，其中的_internal: vendors修改为_internal:lib （大概在347行的地方），然后这个bug就可以解决了。 使用google字体影响网页加载效率对网页加载进行分析后，发现有三个东西影响网页加载效率： 首先是Swiftype 搜索，这个是因为墙的原因，但是我又不想替换成localsearch，所以这个问题就先略过； 第二个是不蒜子统计，本来想替换成腾讯分析，但是貌似需要先给博客买个域名，然后腾讯分析才能识别，不然光是tc9011.github.io是识别不到的，这个涉及到购买域名，域名解析等问题，所以我暂时忍一下（其实是没钱了T^T）； 最后一个就是google字体，其实国内可以通过360cdn来访问。具体方法如下： 找到\themes\next\layout_partials\head\external-fonts.swig文件，把里面的fonts.googleapis.com 改成fonts.useso.com 实践证明，改过后速度更慢了，于是我又改回了fonts.googleapis.com，ORZ 添加留言本页面之前添加了多说评论，无意中看到别人家的博客中有留言本功能，于是我也想整一个。其实方法也是蛮简单的。 1、添加留言本page先cd到博客根目录，然后运行： hexo new page guestbook 2、在留言本页面中添加多说代码进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件添加以下代码： &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 然后登陆自己多说站点，进入设置-&gt;自定义CSS，添加 123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置头像长宽*/ border-radius: 27px; /*设置头像圆角效果*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置头像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隐藏多说版权*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 3、菜单中设置留言本找到NexT主题设置的_config.yml文件里面的menu项 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 在menu_icons下为留言本设定图标： 1234567891011menu_icons: enable: true#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat search: search guestbook: book 我用的是 book 这个图标，如果想要设定为其他图标，请访问：Font Awesome Icons，找到喜欢的图标，记录下图标后的关键字再填写到 menu_icons 下。 4、添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言 SEO优化1、添加robots.txt可以参考我的robots.txt，代码如下 1234567891011121314# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://tc9011.github.io/sitemap.xmlSitemap: https://tc9011.github.io/baidusitemap.xml 把robots.txt放在你的hexo站点的source文件下即可。 2、添加sitemap网站地图之前学了SEO，尝试也给自己网站做一下SEO，具体方法如下： 安装hexo的sitemap网站地图生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码 123# hexo sitemap网站地图sitemap:path: sitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。​ 3、给非友情链接的出站链接添加“nofollow”标签以hexo的NexT主题为例，需要修改两处 找到footer.swig,路径在your-hexo-site\themes\next\layout\_partials，将下面代码 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 改成 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io" rel="external nofollow"&gt;Hexo&lt;/a&gt;') &#125;&#125; 将下面代码 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 改成 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout\_macro，将下面代码 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" rel="external nofollow"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank"&gt; 改成 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank" rel="external nofollow"&gt; 这是根据动动手指，不限于NexT主题的Hexo优化（SEO篇来进行优化的，优化过程中发现，还是需要有自己的域名，不然百度抓不到你的数据，哎~等工作了一定要买一个域名（奋斗脸）。 多说评论不稳定，加载速度慢优化加载多说的时候，因为对方服务器的原因，很不稳定，经常刷不出多说评论，所以决定优化一下，多说评论不稳定，加载速度慢优化方法，主要参考这篇文章进行了优化，具体方法： 在七牛镜像储存中，镜像源地址填写http://static.duoshuo.com，然后保存。 加速成功后，可以通过七牛提供的空间访问域名访问到多说镜像网站，例如我的默认域名是http://og9ocpmwk.bkt.clouddn.com/，直接可以链接到多说的镜像网站。 下载多说核心脚本embed.js，需要更改一处地方代码， 1function n(e)&#123;j.theme=e,"none"!=e&amp;&amp;o.injectStylesheet(j.STATIC_URL+"/styles/embed"+(e?"."+e+".css?"+R[e]:"."+short_name)+".css")&#125; 上面代码应该是调用多说样式embed.xxx.css，我们需要修改成我们七牛镜像的多说样式，只需把j.STATIC_URL更改成七牛空间访问域名，例如我修改成&quot;http://og9ocpmwk.bkt.clouddn.com&quot;。更改后另存为dsembed.js（重命名主要防止与七牛镜像中的embed.js冲突）。最后上传到七牛空间里。现在你可以通过地址/dsembed.js访问经过七牛CDN加速后的多说核心脚本。 把多说默认引入static.duoshuo.com域名下的embed.js更改成七牛空间更改后的dsembed.js即可。 这里以多说通用代码为例， 12345678910111213141516&lt;!-- 多说评论框 start --&gt; &lt;div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type="text/javascript"&gt;var duoshuoQuery = &#123;short_name:"araolin"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; embed.js引入的代码是 1ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; 这里需要更改成 1ds.src = '这里是你的七牛空间embed.js的地址'; 以我的为例，我更改成了 1ds.src = 'http://og9ocpmwk.bkt.clouddn.com/dsembed.js'; 如果你是hexo Next主题的话，需要更改的文件是duoshuo.swig，具体路径在your-hexo-site\themes\next\layout\_scripts\comments目录里。​ 最后值的注意的是，因为我的网站是https://tc9011.github.io，上面的链接若写成http的话，也会加载不了多说评论。所以下面是针对https的一些修改： 首先给七牛账户充值11块钱，不然这个功能木有办法用~ 进入存储资源列表，然后点击下图所示的https域名，七牛会自动生成一个域名； 在内容管理里面选择刚刚生成的域名作为默认外链域名，记得保存。 把内容管理里面的文件先全部删掉，把上面dsembed.js文件重命名一下，主要防止没有覆盖旧文件，比如我命名为dembed.js，再把文件中添加http://og9ocpmwk.bkt.clouddn.com的地方都改成新的外链地址，比如我的https://ogddl0byd.qnssl.com，然后保存，上传七牛。 把duoshuo.swig中的src替换成新的域名。 1ds.src = 'https://ogddl0byd.qnssl.com/dembed.js'; ​ 最后其实博客还有优化空间，比如有几个js加载速度简直是慢的令人发指，尝试了压缩代码，还是不行，感觉还是要把他们托管到其他地方，这个以后慢慢优化，可能以后买个域名，把博客同时托管到coding和github，国内访问coding，国外访问github，具体怎么操作，请听下回分解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEO与Yahoo军规]]></title>
      <url>%2F2016%2F11%2F01%2FSEO%E4%B8%8EYahoo%E5%86%9B%E8%A7%84%2F</url>
      <content type="text"><![CDATA[《SEO在网页制作中的应用》与《Yahoo军规》课程总结 SEO与搜索引擎首先SEO是什么： SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化（比如网站结构调整、网站内容建设、网站代码优化等）以及站外优化（比如网站站外推广、网站品牌建设等），使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。 根据课程内容我自己画了上面这张图，这里以百度搜索引擎为例子说明一下，百度搜索引擎数据库通过百度蜘蛛爬取互联网上数据，这些数据是搜索引擎数据库中没有的，且有用的数据，理想状态下，用户输入关键字搜索，百度通过搜素引擎数据库中与关键字最匹配的结果返回给用户。 百度蜘蛛怎么才能更好的爬取数据呢，这就要通过网站的SEO，让网站用百度蜘蛛听得懂的语言和它交流，让它能更了解你的网站。SEO分为白帽SEO和黑帽SEO。黑帽SEO通过伪装让搜索引擎以为网站和某个关键字有联系，但实际上并没有；白帽SEO则通过上图列出的方法，让网站用百度蜘蛛听得懂的语言更好的去与搜索引擎交流。 网站结构与代码优化 结构布局优化：用扁平化结构 网站结构层次越少越容易被蜘蛛获取，中小型网站，目录层次结构超过3层，蜘蛛就不愿意往下爬。 控制首页链接数量 首页链接数量不能太少也不能太多，中小型企业首页链接在100个以内，例如：页面导航、底部导航、锚文字链接等。 扁平化目录层次 网站的设计不要用纵线性的结构。 导航SEO优化 尽量用文字，如果是图片，alt和title必须要有，面包屑导航（一般页面左上角的XX&gt;&gt;XX&gt;&gt;XX就是，便于了解当前位置和返回）。 页码 页码尽量用 首页 1 2 3 下一页 或者 首页 1 2 3 4 下拉菜单 这样方便蜘蛛抓取内容。 页面布局 左边正文，右边放热门文章和相关文章。 网速 控制页面不要超过100k，不然加载太慢。 网页代码 &lt;title&gt;标题 &lt;meta keywords&gt;关键词 &lt;meta description&gt;网页描述 HTML标签语义化 &lt;a&gt;要有title，对于指向其他网站的链接要写rel=&quot;nofollow&quot; &lt;h1&gt;用于正文标题，副级标题用&lt;h2&gt; &lt;table&gt;标签要写&lt;caption&gt;表格标题&lt;/caption&gt; &lt;img&gt;标签应使用alt说明 &lt;strong&gt;的权重&gt;&lt;em&gt;的权重，如果只为加粗斜体效果建议用&lt;b&gt;和&lt;i&gt;标签 重要内容HTML代码放在最前面 重要内容不要用JS输出 尽少使用iframe框架 谨慎使用display:none，不想显示的内容可以用z-index或者显示在浏览器显示范围之外。蜘蛛会过滤掉display:none中的内容 Yahoo军规 尽量减少HTTP的请求数 可以将图片合并、JavaScript代码合并、css样式合并 使用CDN（内容分发网络） CDN:内容分发网络。意思是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 用简单的话说就是，在离你最近的地方，放置一台性能好链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 添加Expire/Cache-Control头 expire头的内容是一个时间值，值就是资源在本地的过期时间、存在本地。在本地缓存阶段，找到一个对应的资源值，当前时间还没超过资源的过期时间，就直接使用这一个资源，不会发送http请求。 Cache-Control是http协议中常用的头部之一，顾名思义，他是负责控制页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，也有更多的处理方式 启用Gzip压缩 将HTML、JavaScript、CSS、PHP等文件进行Gzip压缩，可以显著减小文件的体积。 将CSS放在页面最上方 避免页面出现空白或者闪烁，提高浏览器的渲染性能。 将Script放在页面最下面 先将内容呈现出来，不会让用户等太久。 避免在CSS中使用Expressions 在CSS中用了JavaScript的计算式，在页面显示和缩放、页面滚动、移动鼠标时CSS Expressions都会重新计算一次，严重影响性能。 把JS和CSS都放到外部文件中 JS和CSS单独提取出来，提高了JS和CSS的复用性，减少页面体积，提高了JS和CSS的可维护性；JS和CSS内置可以减少页面请求，提高页面渲染，若JS和CSS很少、只应用于一个页面或者不经常被访问到时可以这样使用。两者各有优势，灵活取用。 减少DNS查询 当缓存时间长时，减少DNS的重复查找，节省时间；当缓存时间短时，及时的检测网站服务器的变化，保证准确性。 压缩JavaScript和CSS 可以去除不必要的空白符、格式符、注释符，简写方法名、参数名压缩JS脚本。 避免重定向 重定向：用户的原始请求被重新转向到了其他请求 重定向状态码：301 Moved Permanently，表示用户请求的页面被移动到了另一个位置，客户端收到这个后会重新发起一次请求，是永久重定向；302 Found，表示用户请求的页面被找到了，但不在原始位置，服务器会返回一个地址，客户端会重新发起一次请求，是临时重定向。 用301重定向可以使搜索引擎识别，更新新的地址；用302总是会先找到旧地址再跳到新地址。 移除重复的脚本 配置实体标签（ETag） ETag属于HTTP协议，是使用特殊的字符串来标识某个请求资源版本，如果客户端缓存中的版本和服务器中的版本一致，服务器就不需要再传递。 使用AJAX缓存 post请求每次都执行，不被缓存；get请求时同一地址不重复执行，可以被缓存。 看完这两课觉得以前自己码的东西还有很多要修改的，前端之路，任重而道远。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Github和Hexo的个人博客搭建]]></title>
      <url>%2F2016%2F10%2F31%2F%E5%9F%BA%E4%BA%8EGithub%E5%92%8CHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[花了两天终于把基于Github和Hexo的个人博客搭建好了，期间踩了不少坑，在此作为第一篇正式博文记录一下。 Hexo这里还是要说一下Hexo，它是一款基于Node.js的静态博客框架，可以换不同主题，自定义各种样式，个人觉得还是蛮不错的（因为你只用过这一个，呵呵）。 Hexo特性： Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 支持GitHub Flavored Markdown和所有Octopress的插件。 Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。 Hexo官网 ，官网也是基于Github构件的网站。 配置环境及安装Git的安装就跳过了，比较简单。下面说一下Node.js安装。 可以去node.js Git和Node.js安装完了就可以用npm安装Hexo，在mac的终端内输入下面的命令： 1$ npm install -g hexo-cli 然后Hexo就安装完成啦。安装好后，需要对Hexo初始化，在终端中挨个执行下面的命令，其中用指定的文件夹路径代替，一定要cd，不要问我为什么，都是血的教训： 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 至此，所有的安装工作都完成，撒花~ 完成后，目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 建站及部署安装完成后就可以通过下面的命令生成静态页面 hexo g 然后启用本地服务 hexo s 进入浏览器输入http://localhost:4000 就可以看到网站的效果，当然刚开始是默认样式。 下面我们就把网站部署到Github（此处我当你已经弄好github的ssh了） 登陆Github后创建一个名字为your_name.github.io（your_name替换成你的用户名）的仓库； 然后打开hexo下面的_config.yml，翻到最后面， 将下面的信息补充完整（your_name都换成你自己的用户名），注意Hexo 5.0以后type应该写成git而不是github，这又是一处血的教训（姚明脸）。 123type: git repository: https://github.com/your_name/your_name.github.io branch: master 然后分别执行以下命令部署本地博客到github 12hexo ghexo d 然后在浏览器里面输入your_name.github.io就可以访问你自己的博客啦！ NexT主题安装Hexo有好多主题，经过筛选，我选择了NexT，点击链接可以去官网看看，安装教程写的蛮详细的，我就不多说了。这里说一下一些要注意的地方吧，毕竟我踩的坑还是蛮多的，呵呵。 swiftype按照教程生成key后，那个框是不能下拉的，但是你的key却在你看不见的最底下，用command+A，然后command+C复制出来就行，key就是那一串大写字母，不要单引号，swiftype_key:后面记得加空格。 用LeanCloud来统计文章阅读次数，我是参考了这篇文章——&gt;&gt;最简便的方法搭建Hexo+Github博客,基于Next主题，记的在修改主题配置文件_config.yml时候，一定要把下面enable设置为true。 1234leancloud_visitors: enable: true app_id: ytnok33cvEchgidigtb0WumC-gzGzoHsz #&lt;AppID&gt; app_key: SrcG8cy1VhONurWBoEBGGHML #&lt;AppKEY&gt; 设置网站图标Favicon，用比特虫把图制作好后，上传到云存储空间（我用的是七牛），获取图片的网址，然后打开主题配置文件_config.yml，找到favicon字段，将图片网址粘贴在后面，即可。 其他东西跟着教程做起来都还好。]]></content>
    </entry>

    
  
  
</search>
