<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Sass入门]]></title>
      <url>%2F2017%2F04%2F08%2FSass%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[本文是Sass中文网、慕课网Sass入门篇 和 Sass进阶篇、阮一峰SASS用法指南的学习笔记。 Sass简介什么是SassSass 官网上是这样描述 Sass 的： Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。 Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。 Sass和SCSS的区别Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点： 文件扩展名不同，Sass 是以.sass后缀为扩展名，而 SCSS 是以.scss后缀为扩展名 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号{}和分号;，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。 例如： Sass： 123456$font-stack: Helvetica, sans-serif //定义变量$primary-color: #333 //定义变量body font: 100% $font-stack color: $primary-color SCSS: 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; Sass/SCSS和纯CSS写法的区别Sass 和 CSS 写法的确存在一定的差异，由于 Sass 是基于 Ruby 写出来，所以其延续了 Ruby 的书写规范。在书写 Sass 时不带有大括号和分号，其主要是依靠严格的缩进方式来控制的。 SCSS 和 CSS 写法无差别，这也是 Sass 后来越来越受大众喜欢原因之一。简单点说，把你现有的.css文件直接修改成.scss即可使用。 Sass安装sass基于Ruby语言开发而成，因此安装sass前需要安装Ruby。 mac下自带Ruby无需在安装Ruby。 window下先从官网下载Ruby并安装。安装过程中请注意勾选Add Ruby executables to your PATH添加到系统环境变量。 安装完成后需测试安装有没有成功,运行以下命令，下图表示已经安装成功： 然后安装Sass和Compass，安装需要通过gem源，国内可以更换成淘宝源，更换过程参考Sass官网，要安装最新版本的Sass和Compass，需要输入下面的命令： 12sudo gem install sasssudo gem install compass 安装成功后运行下面命令来确认应用已经正确地安装到了电脑中： 123456789sass -vSass 3.4.23 (Selective Steve)compass -vCompass 1.0.3 (Polaris)Copyright (c) 2008-2017 Chris EppsteinReleased under the MIT License.Compass is charityware.Please make a tax deductable donation for a worthy cause: http://umdf.org/compass 如下sass常用更新、查看版本、sass命令帮助等命令： 1234567891011//更新sassgem update sass//查看sass版本sass -v//查看sass帮助sass -h//删除sassgem uninstall sass Sass编译Sass 的编译有多种方法： 命令编译 GUI工具编译 自动化编译 命令编译单文件编译12345//单文件转换命令sass input.scss output.css//单文件监听命令sass --watch input.scss:output.css 多文件编译12//如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：sass --watch app/sass:public/stylesheets 命令编译配置选项123456789101112//编译格式,--style表示解析后的css是什么排版格式; sass内置有四种编译格式:nested,expanded,compact,compressedsass --watch input.scss:output.css --style compact//编译添加调试map,--sourcemap表示开启sourcemap调试。开启sourcemap调试后，会生成一个后缀名为.css.map文件。sass --watch input.scss:output.css --sourcemap//选择编译格式并添加调试mapsass --watch input.scss:output.css --style expanded --sourcemap//开启debug信息sass --watch input.scss:output.css --debug-info 四种编译排版格式nested(嵌套)编译排版格式1234567891011121314151617181920//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style nested/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125; .box-title &#123; height: 30px; line-height: 30px; &#125; expanded(展开)编译排版格式12345678910111213141516171819202122//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style expanded/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact(紧凑)编译排版格式12345678910111213141516//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style compact/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125;.box-title &#123; height: 30px; line-height: 30px; &#125; compressed(压缩)编译排版格式123456789101112131415//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style compressed/*编译过后样式*/.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125; GUI工具编译对于 GUI 界面编译工具，目前较为流行的主要有： Koala Compass.app Scout CodeKit Prepros 这里推荐koala&amp;codekit,其中koala是免费编译器，简单操作如下图: 自动化编译通过Grunt和Gulp来配置Sass编译，具体请看[Sass]自动化编译，这里我只写一下在webstorm下的自动化编译。 在webstorm的设置中搜索File Watcher，然后在mac中webstorm自动会添加ruby中的scss文件，其他配置默认，然后点击ok就可以。 项目所在的路径中请不要出现中文，不然sass在编译是会出现编码错误。并且在Sass的编译的过程中，是不是支持GBK编码的。所以在创建 Sass 文件时，就需要将文件编码设置为utf-8。 Sass调试CSS调试首先，先讲一下css的调试，在chrome中打开开发者工具，在sources中右击选择add folder to workspace，选择所要调试的项目文件夹，浏览器弹出提示框，选择允许，这时候就可以看到浏览器sources中有项目的文件夹： 这时候需要把localhost中的项目文件夹和导入的文件夹关联起来： 这时候会弹出一个选择框，选择chrome自动匹配到的文件： 这时候就匹配上了，chrome还会提示你其他文件匹配，选择enable就行： 这时候在导入的项目文件夹中修改css样式，浏览器会立刻生效，按command+s或者ctrl+s后，webstorm中源代码也会修改： Sass调试和css调试一样，直接修改Sass或者SCSS文件，保存后webstorm和浏览器同步更新。 Sass的基本特性使用变量sass使用$符号来标识变量，Sass 的变量包括三个部分： 声明变量的符号“$” 变量名称 赋予变量的值 1$highlight-color: #F90; 任何可以用作css属性值的赋值都 可以用作sass的变量值，甚至是以空格分割的多个属性值或以逗号分割的多个属性值: 12$basic-border: 1px solid black;$plain-font: "Myriad Pro"、Myriad、"Helvetica Neue"、Helvetica、"Liberation Sans"、Arial和sans-serif; sans-serif; 当变量定义在css规则块内，那么该变量只能在此规则块内使用，将局部变量转换为全局变量可以添加 !global 声明： 12345678910111213141516171819202122232425$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125;#main &#123; width: 5em; &#125;#sidebar &#123; width: 5em; &#125; 如果值后面加上!default则表示默认值: 1$btn-primary-border : darken($btn-primary-bg, 5%) !default; sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可： 12345678910$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125;//编译后body&#123; line-height:2;&#125; 凡是css属性的标准值可存在的地方，变量就可以使用。 在声明变量时，变量值也可以引用其他变量。 12345678910$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected &#123; border: $highlight-border;&#125;//编译后.selected &#123; border: 1px solid #F90;&#125; sass的变量名可以与css中的属性名和选择器名称相同，包括中划线和下划线，并且这两种用法相互兼容： 123456789$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 嵌套Sass 的嵌套分为三种： 选择器嵌套 属性嵌套 伪类嵌套 选择器嵌套Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如： 12345678910111213141516#main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125;//编译后#main p &#123; color: #00ff00; width: 97%; &#125; #main p .redbox &#123; background-color: #ff0000; color: #000000; &#125; 属性嵌套有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如： 12345678910111213.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125;//编译后.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 命名空间也可以包含自己的属性值，例如： 123456789101112.funky &#123; font: 20px/24px &#123; family: fantasy; weight: bold; &#125;&#125;//编译后.funky &#123; font: 20px/24px; font-family: fantasy; font-weight: bold; &#125; 伪类嵌套其实伪类嵌套和属性嵌套非常类似，只不过他需要借助&amp;符号一起配合使用。例如： 12345678910111213141516171819.clearfix&#123;&amp;:before,&amp;:after &#123; content:""; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125;//编译后.clearfix:before, .clearfix:after &#123; content: ""; display: table; &#125;.clearfix:after &#123; clear: both; overflow: hidden; &#125; 父级选择器&amp;&amp; 代表嵌套规则外层的父选择器，编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递： 123456789101112131415#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125;//编译后#main &#123; color: black; &#125; #main a &#123; font-weight: bold; &#125; #main a:hover &#123; color: red; &#125; &amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如: 12345678910#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125;//编译后#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 当父选择器含有不合适的后缀时，Sass 将会报错。 避免选择器嵌套：- 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。- 选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。 混合指令混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。 定义混合指令混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义： 12345678@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125; 可以在定义混合指令时带有参数，如： 1234@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 混合也需要包含选择器和属性，甚至可以用 &amp; 引用父选择器： 1234567891011@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125; 当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如： 12345678@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125; 引用混合样式使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）： 1234567891011121314151617181920212223@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125;//编译后.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器: 123456789101112@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links;//编译后a &#123; color: blue; background-color: red; &#125; 混合样式中也可以包含其他混合样式，比如: 123456@mixin compound &#123; @include highlighted-background; @include header-text;&#125;@mixin highlighted-background &#123; background-color: #fc0; &#125;@mixin header-text &#123; font-size: 20px; &#125; 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。 参数参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号： 1234567891011121314@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 1in); &#125;//编译后p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值： 1234567891011121314151617181920@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125;//编译后p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 混合指令也可以使用关键词参数，关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用，上面的例子也可以写成： 123456789101112131415161718192021@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border($color: blue); &#125;h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125;//编译后p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 ‘shadow’ 会被用到。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理： 1234567891011121314@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125;//编译后.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; &#125; 参数变量也可以用在引用混合指令的时候 (@include)，将一串值列表中的值逐条作为参数引用： 123456789101112131415@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff;.primary &#123; @include colors($values...);&#125;//编译后.primary &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff; &#125; 扩展/继承在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示： 1234567891011121314151617181920212223242526272829303132.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125;//编译后//编译出来的 CSS 会将选择器合并在一起，形成组合选择器.btn, .btn-primary, .btn-second &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px; &#125;.btn-primary &#123; background-color: #f36; color: #fff; &#125;.btn-second &#123; background-color: orange; color: #fff; &#125; Class 选择器并不是唯一可以被继承的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=&quot;http://&quot;] 等，例如： 12345678910.hoverlink &#123; @extend a:hover;&#125;a:hover &#123; text-decoration: underline;&#125;//编译后a:hover, .hoverlink &#123; text-decoration: underline; &#125; 所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover的样式，例如： 1234567891011.hoverlink &#123; @extend a:hover;&#125;.comment a.user:hover &#123; font-weight: bold;&#125;//编译后//.comment a.user:hover的样式也继承给了.hoverlink.comment a.user:hover, .comment .user.hoverlink &#123; font-weight: bold; &#125; 同一个选择器可以继承给多个选择器，它所包含的属性将继承给所有被继承的选择器，且后定义的样式享有优先权。多重继承可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。 当一个选择器继承给第二个后，可以继续将第二个选择器继承给第三个，第三个选择器既包含第二个选择器的样式，又包含第一个选择器样式。 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素。 当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器，第一列出现在第二列之前，或者第二列出现在第一列之前： 123456789101112#admin .tabbar a &#123; font-weight: bold;&#125;#demo .overview .fakelink &#123; @extend a;&#125;//编译后#admin .tabbar a,#admin .tabbar #demo .overview .fakelink, //第一列在第二列之前#demo .overview #admin .tabbar .fakelink &#123; //第二列在第一列之前 font-weight: bold; &#125; 如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出： 123456789101112#admin .tabbar a &#123; font-weight: bold;&#125;#admin .overview .fakelink &#123; @extend a;&#125;//编译后#admin .tabbar a, //相同部分#admin .tabbar .overview .fakelink, #admin .overview .tabbar .fakelink &#123; font-weight: bold; &#125; 在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器（@media中的继承，只能在其内部使用）。 占位符与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过@extend指令调用，当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中： 123456789101112131415%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5;&#125;//编译后.btn &#123; margin-top: 5px; &#125; 通过 @extend 调用的占位符，编译出来的代码会将相同的代码合并在一起。 何时使用混合指令、继承、占位符混合指令用混合指令编译出来的 CSS 不会自动合并相同的样式代码，如果在样式文件中调用同一个混合指令，会产生多个对应的样式代码，造成代码的冗余。 混合指令可以用来传参数，如果你的代码块中涉及到变量，建议使用混合指令来创建相同的代码块。 继承通过继承编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，相对于混合指令来说要干净的多。但是他不能传变量参数。 如果你的代码块不需要传任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。 占位符占位符和继承编译出来的CSS代码基本相同。占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。 插值通过 #{} 插值语句可以在选择器或属性名中使用变量： 123456789$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125;//编译后p.foo &#123; border-color: blue; &#125; #{} 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。 123456789p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;//编译后p &#123; font: 12px/30px; &#125; 使用插值语句可以构建一个选择器： 12345678910111213141516@mixin generate-sizes($class, $small, $medium, $big) &#123; .#&#123;$class&#125;-small &#123; font-size: $small; &#125; .#&#123;$class&#125;-medium &#123; font-size: $medium; &#125; .#&#123;$class&#125;-big &#123; font-size: $big; &#125;&#125;@include generate-sizes("header-text", 12px, 20px, 40px);//编译后.header-text-small &#123; font-size: 12px; &#125;.header-text-medium &#123; font-size: 20px; &#125;.header-text-big &#123; font-size: 40px; &#125; 但是不能在mixin中作为参数调用： 123456789@mixin updated-status &#123; margin-top: 20px; background: #F00;&#125;$flag: "status";.navigation &#123; @include updated-#&#123;$flag&#125;;&#125;//以上代码会报错 可以在@extend中使用插值。例如： 1234567891011121314151617181920%updated-status &#123; margin-top: 20px; background: #F00;&#125;.selected-status &#123; font-weight: bold;&#125;$flag: "status";.navigation &#123; @extend %updated-#&#123;$flag&#125;; @extend .selected-#&#123;$flag&#125;;&#125;//编译后.navigation &#123; margin-top: 20px; background: #F00; &#125;.selected-status, .navigation &#123; font-weight: bold; &#125; 注释Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如： 123456789101112131415161718192021/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;// These comments are only one line long each.// They won't appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green; &#125;//编译后/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;a &#123; color: green; &#125; 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。 插值语句也可写进多行注释中输出变量值： 12345$version: "1.2.3";/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. *///编译后/* This CSS is generated by My Snazzy Framework version 1.2.3. */ 数据类型SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 范围，或 !important 声明。然而，Sass 不会特殊对待这些属性值，一律视为无引号字符串 。 字符串SassScript 支持 CSS 的两种字符串类型： 有引号字符串 (quoted strings)，如 “Lucida Grande” 、’http://sass-lang.com&#39;； 无引号字符串 (unquoted strings)，如 sans-serifbold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名： 1234567891011@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: "Hi"; &#125;&#125;@include firefox-message(".header");//编译后body.firefox .header:before &#123; content: "Hi"; &#125; 数组数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组。 Sass数组函数（Sass list functions）赋予了数组更多功能： nth函数可以直接访问数组中的某一项； join函数可以将多个数组连结在一起； append函数可以在数组中添加值； @each指令能够遍历数组中的每一项。 数组中可以包含子数组，可以用两种方式书写 使用逗号分割子数组，比如1px 2px, 5px 6px 使用空格分割子数组，比如(1px 2px) (5px 6px) 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。 MapsMap表示key和value之间的关联，其中key用于查找value。Map可以轻松地将value收集到命名组中，并动态访问这些组。语法类似于媒体查询表达式：$ map：（key1：value1，key2：value2，key3：value3）; 与数组不同，Map必须始终用括号括起来，并且必须始终以逗号分隔。 Map中的key和value都可以是任何SassScript对象。Map可能只有一个与给定key相关联的value（尽管该值可能是一个数组）。但是，给定的值可能与许多键相关联。 像数组一样，Map大都使用SassScript函数进行操作。map-get函数在地图中查找值，map-merge函数将值添加到地图。@each指令可用于为Map中的每个键/值对添加样式。 （key1：value1，key2：value2）将被视为嵌套key1 value1，key2 value2的数组。除了空数组之外，数组不能被视为Map。 请注意，Map的key可以是任何Sass数据类型（甚至另一个Map），声明Map的语法同时也允许任意正确的SassScript表达式作为key。 Map无法转换为纯CSS。使用一个作为CSS函数的变量或参数的值将导致错误。 使用inspect（$ value）函数来生成一个对调试Map有用的输出字符串。 颜色任何CSS颜色表达式返回SassScript颜色值，SassScript颜色值包括大量命名的颜色，与无引号的字符串不可区分。 在压缩输出模式下，Sass将输出颜色的颜色的16进制形式。 例如，＃FF0000将以压缩模式输出为红色，但blanchedalmond将输出为#FFEBCD。 用户常遇到的命名颜色问题是，当压缩时插入到选择器中的颜色将变为无效语法。 为了避免这种情况，如果它们是用于构建选择器的话，总是引用命名的颜色。 Sass运算所有数据类型均支持相等运算 == 或 !=。 关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算。 SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在相同类型的不同单位间转换值。 运算时碰到不同类型的单位时，编译也会报错，如：em和px。 运算符两边有空格。 加法1234567.box &#123; width: 20px + 8in;&#125;//编译后.box &#123; width: 788px; &#125; 减法12345678910$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125;//编译后.content &#123; width: 760px; &#125; 乘法乘法中一个单位同时只能声明一个值。 1234567.box &#123; width: 10px * 2; //等于10px * 2px&#125;//编译后.box &#123; width: 20px; &#125; 除法/ 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。 以下三种情况 / 将被视为除法运算符号： 如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 12345678910111213141516p &#123; font: 10px/8px; // “/”起分隔作用 $width: 1000px; width: $width/2; // “/”起除法运算 width: round(1.5)/2; // “/”起除法运算 height: (500px/2); // “/”起除法运算 margin-left: 5px + 8px/2px; // “/”起除法运算&#125;//编译后p &#123; font: 10px/8px; width: 500px; width: 1; height: 250px; margin-left: 9px; &#125; 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。 123456789p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;//编译后p &#123; font: 12px/30px; &#125; 在除法运算时，如果两个值带有相同的单位值时，除法运算之后会得到一个不带单位的数值： 1234567.box &#123; width: (1000px / 100px);&#125;//编译后.box &#123; width: 10; &#125; 颜色运算颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值： 1234567p &#123; color: #010203 + #040506;&#125;//编译后p &#123; color: #050709; &#125;//计算过程：01 + 04 = 05 02 + 05 = 07 03 + 06 = 09 数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如： 1234567p &#123; color: #010203 * 2;&#125;//编译后p &#123; color: #020406; &#125;//计算过程： 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 1234567p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125;//编译后p &#123; color: rgba(255, 255, 0, 0.75); &#125; 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。 12345678910$translucent-red: rgba(255, 0, 0, 0.5);p &#123; color: opacify($translucent-red, 0.3); //透明度相加 background-color: transparentize($translucent-red, 0.25);//透明度替换&#125;//编译后p &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); &#125; IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。 12345678910$translucent-red: rgba(255, 0, 0, 0.5);$green: #00ff00;div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#&#123;ie-hex-str($green)&#125;', endColorstr='#&#123;ie-hex-str($translucent-red)&#125;');&#125;//编译后div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);&#125; 字符串运算+ 可用于连接字符串: 1234567p &#123; cursor: e + -resize;&#125;//编译后p &#123; cursor: e-resize; &#125; 如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 +左侧）连接有引号字符串，运算结果则没有引号。 运算表达式与其他值连用时，用空格做连接符： 1234567p &#123; margin: 3px + 4px auto;&#125;//编译后p &#123; margin: 7px auto; &#125; 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值： 1234567p:before &#123; content: "I ate #&#123;5 + 10&#125; pies!";&#125;//编译后p:before &#123; content: "I ate 15 pies!"; &#125; 空的值被视作插入了空字符串： 12345678$value: null;p:before &#123; content: "I ate #&#123;$value&#125; pies!";&#125;//编译后p:before &#123; content: "I ate pies!"; &#125; 布尔运算SassScript 支持布尔型的 and or 以及 not 运算。 数组运算数组不支持任何运算方式，只能使用 list functions 控制。 Sass控制指令@if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码： 123456789p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125;//编译后p &#123; border: 1px solid; &#125; @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如： 123456789101112$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; @for@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。 这个指令包含两种格式：@for $var from &lt;start&gt; through &lt;end&gt;，或者 @for $var from &lt;start&gt; to &lt;end&gt;，区别在于 through 与 to 的含义：当使用through时，条件范围包含&lt;start&gt;与 &lt;end&gt;的值，而使用to时条件范围只包含&lt;start&gt;的值不包含&lt;end&gt;的值。另外，$var 可以是任何变量，比如 $i；&lt;start&gt; 和 &lt;end&gt; 必须是整数值。 1234567891011@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;//编译后.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; @each@each 指令的格式是 $var in &lt;list&gt;，$var 可以是任何变量名，比如 $length 或者 $name，而 &lt;list&gt; 是一连串的值，也就是值列表。 @each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如： 12345678910111213141516171819202122232425$list: adam john wynn mason kuroir;//$list 就是一个列表@mixin author-images &#123; @each $author in $list &#123; .photo-#&#123;$author&#125; &#123; background: url("/images/avatars/#&#123;$author&#125;.png") no-repeat; &#125; &#125;&#125;.author-bio &#123; @include author-images;&#125;//编译后.author-bio .photo-adam &#123; background: url("/images/avatars/adam.png") no-repeat; &#125;.author-bio .photo-john &#123; background: url("/images/avatars/john.png") no-repeat; &#125;.author-bio .photo-wynn &#123; background: url("/images/avatars/wynn.png") no-repeat; &#125;.author-bio .photo-mason &#123; background: url("/images/avatars/mason.png") no-repeat; &#125;.author-bio .photo-kuroir &#123; background: url("/images/avatars/kuroir.png") no-repeat; &#125; @each指令中也可以使用多个变量： 12345678910111213141516171819202122232425@each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); border: 2px solid $color; cursor: $cursor; &#125;&#125;//编译后.puma-icon &#123; background-image: url("/images/puma.png"); border: 2px solid black; cursor: default; &#125;.sea-slug-icon &#123; background-image: url("/images/sea-slug.png"); border: 2px solid blue; cursor: pointer; &#125;.egret-icon &#123; background-image: url("/images/egret.png"); border: 2px solid white; cursor: move; &#125; 因为maps可以看做是有键值对的数组，所以用@each遍历多个变量也能用： 12345678910111213@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//编译后h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; @while@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如： 12345678910111213$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125;//编译后.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; Sass的函数字符串函数unquote(\$string)和quote(\$string) unquote(\$string)：删除字符串中的引号 quote(\$string)：给字符串添加引号，如果字符串自身带有引号会统一换成双引号 123456789101112131415161718192021222324.test1 &#123; content: unquote('Hello Sass!') ;&#125;.test2 &#123; content: unquote("'Hello Sass!");&#125;.test3 &#123; content: quote('Hello Sass!');&#125;.test4 &#123; content: quote(ImWebDesigner);&#125;//编译后.test1 &#123; content: Hello Sass!; &#125;.test2 &#123; content: 'Hello Sass!; &#125;.test3 &#123; content: "Hello Sass!"; &#125;.test4 &#123; content: "ImWebDesigner"; &#125; To-upper-case()和To-lower-case() To-upper-case()：将字符串转换成大写字母 To-lower-case()：将字符串转换成小写字母 123456789.test &#123; text: to-upper-case(aaaaa); text: to-lower-case(AA);&#125;//编译后.test &#123; text: AAAAA; text: aa; &#125; 数字函数percentage()percentage()函数主要是将一个不带单位的数字转换成百分比形式： 1234567.footer&#123; width : percentage(.2)&#125;//编译后.footer &#123; width: 20%; &#125; round()round() 函数可以将一个数四舍五入为一个最接近的整数: 1234567.footer &#123; width:round(12.3px)&#125;//编译后.footer &#123; width: 12px; &#125; ceil()和floor() ceil() 函数将一个数转换成最接近于自己的整数，会将一个大于自身的任何小数转换成大于本身 1 的整数。也就是只做入，不做舍的计算 floor() 函数刚好与 ceil() 函数功能相反，其主要将一个数去除其小数部分，并且不做任何的进位。也就是只做舍，不做入的计算 12345678910111213.footer &#123; width:ceil(12.3px);&#125;.footer1 &#123; width:floor(12.3px);&#125;//编译后.footer &#123; width: 13px; &#125;.footer1 &#123; width: 12px; &#125; abs()abs( ) 函数会返回一个数的绝对值 1234567.footer &#123; width:abs(-12.3px);&#125;//编译后.footer &#123; width: 12.3px; &#125; min()和max() min() 函数功能主要是在多个数之中找到最小的一个，这个函数可以设置任意多个参数，不过参数类型不同会报错 max() 函数和 min() 函数一样，不同的是，max() 函数用来获取一系列数中的最大那个值 12345678910111213.footer &#123; width: max(13px,5px); &#125;.footer1 &#123; width: min(13px,5px); &#125;//编译后.footer &#123; width: 13px; &#125;.footer1 &#123; width: 5px; &#125; random()random() 函数是用来获取一个随机数： 1234567.footer &#123;3 width: random(); &#125;//编译后.footer &#123; width: 0.18589; &#125; 数组函数length()length() 函数主要用来返回一个数组中有几个值： 1234567.footer &#123; width: length(10px 20px (border 1px solid) 2em);&#125;//编译后.footer &#123; width: 4; &#125; length() 函数中的列表参数之间使用空格隔开，不能使用逗号，否则函数将会出错。 nth()nth() 函数用来指定列表中某个位置的值，语法为nth($list,$n)，$n 必须是大于 0 的整数： 1234567.footer &#123; width: nth(10px 20px 30px,1);&#125;//编译后.footer &#123; width: 10px; &#125; join()join() 函数是将两个列表（只能是两个列表）连接合并成一个列表，碰到两个以上列表合并时，需要用多个join() 函数合并： 1234567.footer &#123; color: join((blue red), join((#abc #def),(#dee #eff)));&#125;//编译后.footer &#123; color: blue red #abc #def #dee #eff; 在join()函数中还有一个很特别的参数$separator，这个参数主要是用来给数组函数连接数组值，默认值为auto。 join()函数中$separator除了默认值auto之外，还有comma和space两个值，其中 comma值指定数组中的数组值之间使用逗号分隔，space值指定列表中的数组项值之间使用空格分隔。 在join()函数中除非明确指定了$separator值，否则将会有多种情形发生，建议大家使用join()函数合并列表项的时候就明确指定$separator参数： 1234567891011.footer &#123; color: join(blue,red,comma) (#0000ff, #ff0000);&#125;.footer1 &#123; color: join(blue,red,space) (#0000ff #ff0000);&#125;//编译后.footer &#123; color: blue, red #0000ff, #ff0000; &#125;.footer1 &#123; color: blue red #0000ff #ff0000; &#125; append()append()函数是用来将某个值插入到数组中，并且处于最末位。 append()函数中也有\$separator参数。 123456789101112.footer &#123; color: append((blue green),red,comma) (#0000ff, #008000, #ff0000);&#125;.footer1 &#123; color: append((blue green),red,space) (#0000ff #008000 #ff0000);&#125;//编译后.footer &#123; color: blue, green, red #0000ff, #008000, #ff0000; &#125;.footer1 &#123; color: blue green red #0000ff #008000 #ff0000; &#125; zip()zip()函数将多个数组值转成一个多维的数组，在使用zip()函数时，每个单一的数组个数值必须是相同的。 1234567.footer &#123; border: zip(1px 2px 3px,solid dashed dotted,green blue red);&#125;//编译后.footer &#123; border: 1px solid green, 2px dashed blue, 3px dotted red &#125; index()index() 函数类似于索引一样，主要让你找到某个值在列表中所处的位置。在 Sass 中，第一个值就是1，第二个值就是 2，依此类推，如果指定的值不在列表中（没有找到相应的值），那么返回的值将是 false。 Introspection函数Introspection 函数包括了几个判断型函数： type-of(\$value)：返回一个值的类型，number 为数值型、string 为字符串型、bool 为布尔型、color 为颜色型。 unit(\$number)：返回一个值的单位 unitless(\$number)：判断一个值是否带有单位，不带单位返回的值为 true，带单位返回的值为 false comparable(\$number-1, \$number-2)：判断两个值是否可以做加、减和合并，如果可以返回的值为 true，如果不可以返回的值是 false Miscellaneous函数Miscellaneous函数和 JavaScript 中的三元判断非常的相似：if($condition,$if-true,$if-false)。他有两个值，当条件成立返回一种值，当条件不成立时返回另一种值： 12345678910@mixin containue($bool)&#123; p&#123; width:if($bool,8em,20em); &#125;&#125;@include containue(false);//编译后p &#123; width: 20em; &#125; Map Sass 的 map 长得与 JSON 极其相似： 12345$map: ( $key1: value1, $key2: value2, $key3: value3) 首先有一个类似于 Sass 的变量一样，用个 $ 加上命名空间来声明 map。后面紧接是一个小括号 ()，将数据以 key:value 的形式赋予，其中 key 和 value 是成对出现，并且每对之间使用逗号分隔，其中最后一组后面没有逗号。 对于 Sass 的 map，还可以让 map 嵌套 map。其实就是 map 的某一个 key 当成 map，里面可以继续放一对或者多对 key:value： 12345678$map: ( key1: value1, key2: ( key-1: value-1, key-2: value-2, ), key3: value3); map 的嵌套实用性也非常的强，大家可能有碰到过换皮肤的项目，可能每一套皮肤对应的颜色蛮多的，那么使用此功能来管理颜色的变量就非常的有条理性，便于维护与管理。你可以这样使用： 1234567891011121314151617$theme-color: ( default: ( bgcolor: #fff, text-color: #444, link-color: #39f ), primary:( bgcolor: #000, text-color:#fff, link-color: #93f ), negative: ( bgcolor: #f36, text-color: #fefefe, link-color: #d4e )); map-get(\$map,\$key)map-get(\$map,\$key) 函数的作用是根据 \$key 参数，返回 \$key 在 \$map 中对应的 value 值。如果 \$key 不存在 $map中，将返回 null 值。此函数包括两个参数： $map：定义好的 map。 $key：需要遍历的 key。 1234567891011121314$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);.btn-dribble&#123; color: map-get($social-colors,facebook);&#125;//编译后.btn-dribble &#123; color: #3b5998; &#125; 如果 $key 不在 $map 中，不会编译出 CSS，其实在 Sass 中，map-get($social- colors,weibo) 返回了一个 null 值。但在编译出来的 CSS 中，你只知道他没有编译出样式，而且在命令终端编译时，也没有任何错误或者警告信息。说实话，你并不知道他为什么编译不出来样式，或者说他已返回了值为 null。 map-has-key(\$map,\$key)map-has-key(\$map,\$key) 函数将返回一个布尔值。当 \$map 中有这个 \$key，则函数返回 true，否则返回 false。 123456789101112131415161718$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);@if map-has-key($social-colors,facebook)&#123; .btn-facebook &#123; color: map-get($social-colors,facebook); &#125;&#125; @else &#123; @warn "No color found for faceboo in $social-colors map. Property ommitted."&#125;//编译后.btn-facebook &#123; color: #3b5998; &#125; 这样可以解决map-get(\$social- colors,weibo) 返回了一个 null 值后没有提示的状态。其实可以自定义一个函数来实现： 1234567891011121314151617181920212223242526272829303132333435363738394041@function colors($color)&#123; @if not map-has-key($social-colors,$color)&#123; @warn "No color found for `#&#123;$color&#125;` in $social-colors map. Property omitted."; &#125; @return map-get($social-colors,$color);&#125;.btn-dribble &#123; color: colors(dribble);&#125;.btn-facebook &#123; color: colors(facebook);&#125;.btn-github &#123; color: colors(github);&#125;.btn-google &#123; color: colors(google);&#125;.btn-twitter &#123; color: colors(twitter);&#125;.btn-weibo &#123; color: colors(weibo);&#125;//编译后.btn-dribble &#123; color: #ea4c89; &#125;.btn-facebook &#123; color: #3b5998; &#125;.btn-github &#123; color: #171515; &#125;.btn-google &#123; color: #db4437; &#125;.btn-twitter &#123; color: #55acee; &#125; map-keys(\$map)map-keys(\$map) 函数将会返回 \$map 中的所有 key。这些值赋予给一个变量，那他就是一个列表。如： 12345678$list: map-keys($social-colors);.test&#123; content:$list&#125;//编译后.test &#123; content: dribble, facebook, github, google, twitter; &#125; 上面的`@function colors函数可以做通过 map-keys(\$map) 来做一个修改： 1234567891011121314151617181920212223242526272829@function colors($color)&#123; $names: map-keys($social-colors); @if not index($names,$color)&#123; @warn "Waring: `#&#123;$color&#125; is not a valid color name.`"; &#125; @return map-get($social-colors,$color);&#125;@each $name in map-keys($social-colors)&#123; .btn-#&#123;$name&#125;&#123; color: colors($name); &#125;&#125;//编译后.btn-dribble &#123; color: #ea4c89; &#125;.btn-facebook &#123; color: #3b5998; &#125;.btn-github &#123; color: #171515; &#125;.btn-google &#123; color: #db4437; &#125;.btn-twitter &#123; color: #55acee; &#125; map-values(\$map)和map-merge(\$map1,\$map2)map-values(\$map) 函数类似于 map-keys(\$map) 功能，不同的是 map-values(\$map )获取的是 \$map 的所有 value 值，可以说也将是一个数组。而且，map-values(\$map) 中如果有相同的 value 也将会全部获取出来。 12345678$list: map-values($social-colors);.test&#123; content:$list&#125;//编译后.test &#123; content: #ea4c89, #3b5998, #171515, #db4437, #55acee; &#125; map-merge(\$map1,\$map2) 函数是将 \$map1 和 \$map2 合并，然后得到一个新的 \$map。如果你要快速将新的值插入到 \$map 中的话，这种方法是最佳方法。 123456789101112131415161718192021$color: ( text: #f36, link: #f63, border: #ddd, backround: #fff);$typo:( font-size: 12px, line-height: 1.6);$newmap: map-merge($color,$typo);//得到新的map$newmap:( text: #f36, link: #f63, font-size: 12px, line-height: 1.6, border: #ccc, background: #000); map-remove(\$map,\$key)和keywords(\$args)map-remove(\$map,\$key) 函数是用来删除当前 \$map 中的某一个 \$key，从而得到一个新的 map。其返回的值还是一个 map。他并不能直接从一个 map 中删除另一个 map，仅能通过删除 map 中的某个 key 得到新 map。如： 12345678910111213141516$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);$map:map-remove($social-colors,dribble);//返回新的map$map:( facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee); keywords(\$args) 函数可以说是一个动态创建 map 的函数。可以通过混合宏或函数的参数变创建 map。参数也是成对出现，其中 \$args 变成 key(会自动去掉\$符号)，而 \$args 对应的值就是value。 1234567891011121314@mixin map($args...)&#123; @debug keywords($args);&#125;@include map( $dribble: #ea4c89, $facebook: #3b5998, $github: #171515, $google: #db4437, $twitter: #55acee);//在命令终端可以看到一个输入的 @debug 信息DEBUG: (dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee) 颜色函数RGB()颜色函数在 Sass 中为 RGB 颜色提供六种函数： rgb(\$red,\$green,\$blue)：根据红、绿、蓝三个值创建一个颜色； rgba(\$red,\$green,\$blue,\$alpha)：根据红、绿、蓝和透明度值创建一个颜色； red(\$color)：从一个颜色中获取其中红色值； green(\$color)：从一个颜色中获取其中绿色值； blue(\$color)：从一个颜色中获取其中蓝色值； mix(\$color-1,\$color-2,[\$weight])：把两种颜色混合在一起。 12345678910111213$ sass -i //相当于开启 Sass 的函数计算&gt;&gt; rgb(200,40,88) //根据r:200,g:40,b:88计算出一个十六进制颜色值#c82858&gt;&gt; rgba(#c82858,.65) //根据#c82858的65%透明度计算出一个rgba颜色值rgba(200, 40, 88, 0.65)&gt;&gt; red(#c82858) //从#c82858颜色值中得到红色值 200200&gt;&gt; green(#c82858) //从#c82858颜色值中得到绿色值 4040&gt;&gt; blue(#c82858) //从#c82858颜色值中得到蓝色值 8888&gt;&gt; mix(#c82858,rgba(200,40,80,.65),.3) //把#c82858和rgba(200,40,88,.65) 两颜色按比例混合得到一个新颜色rgba(200, 40, 80, 0.65105) RGBA()颜色函数rgba() 函数主要用来将一个颜色根据透明度转换成 rgba 颜色。 其语法有两种格式： 12rgba($red,$green,$blue,$alpha) //将一个rgba颜色转译出来，和未转译的值一样rgba($color,$alpha) //将一个Hex颜色转换成rgba颜色 其中 rgba(\$color,\$alpha) 函数作用更大，主要运用在这样的情形之中：假设在实际中知道的颜色值是#f36或者red，但在使用中，需要给他们配上一个透明度，这时可以用上rgba(\$color,\$alpha) 函数： 1234567891011121314$color: #f36;$bgColor: orange;$borderColor:green;.rgba &#123; color: rgba(#f36,.5); background: rgba(orange,.5); border-color: rgba(green,.5);&#125;//编译后.rgba &#123; color: rgba(255, 51, 102, 0.5); background: rgba(255, 165, 0, 0.5); border-color: rgba(0, 128, 0, 0.5); &#125; Mix()函数Mix 函数是将两种颜色根据一定的比例混合在一起，生成另一种颜色。其使用语法如下： 1mix($color-1,$color-2,$weight); $color-1和$color-2指的是你需要合并的颜色，颜色可以是任何表达式，也可以是颜色变量。 $weight为合并的比例（选择权重），默认值为 50%，其取值范围是 0~1 之间。它是每个 RGB 的百分比来衡量，当然透明度也会有一定的权重。默认的比例是 50%，这意味着两个颜色各占一半，如果指定的比例是 25%，这意味着第一个颜色所占比例为 25%，第二个颜色所占比例为75%。 123456789101112131415161718$color1: #a63;$color2: #fff;$bgColor1: #f36;$bgColor2: #e36;$borderColor1:#c36;$borderColor2:#b36;.mix &#123; background: mix($bgColor1,$bgColor2,.75); color: mix($color1,$color2,.25); border-color: mix($borderColor1,$bgColor2,.05);&#125;//编译后.mix &#123; background: #ee3366; color: #fffffe; border-color: #ee3366; &#125; HSL函数在 Sass 中提供了一系列有关于 HSL 的颜色函数： hsl(\$hue,\$saturation,\$lightness)：通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色 hsla(\$hue,\$saturation,\$lightness,\$alpha)：通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色 hue(\$color)：从一个颜色中获取色相（hue）值 saturation(\$color)：从一个颜色中获取饱和度（saturation）值 lightness(\$color)：从一个颜色中获取亮度（lightness）值 adjust-hue(\$color,\$degrees)：通过改变一个颜色的色相值，创建一个新的颜色 lighten(\$color,\$amount)：通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色 darken(\$color,\$amount)：通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色 saturate(\$color,\$amount)：通过改变颜色的饱和度值，让颜色更饱和，从而创建一个新的颜色 desaturate(\$color,\$amount)：通过改变颜色的饱和度值，让颜色更少的饱和，从而创建出一个新的颜色 grayscale(\$color)：将一个颜色变成灰色，相当于desaturate(\$color,100%) complement(\$color)：返回一个补充色，相当于adjust-hue(\$color,180deg) invert(\$color)：返回一个反相色，红、绿、蓝色值倒过来，而透明度不变 lighten()lighten() 和 darken() 两个函数都是围绕颜色的亮度值做调整的，其中 lighten() 函数会让颜色变得更亮，与之相反的 darken() 函数会让颜色变得更暗。这个亮度值可以是0~1之间，不过常用的一般都在3%~20%之间。 1234567891011121314$baseColor: #ad141e;.lighten &#123; background: lighten($baseColor,10%);&#125;.darken&#123; background: darken($baseColor,10%);&#125;//编译后.lighten &#123; background: #db1926; &#125;.darken &#123; background: #7f0f16; &#125; saturate()saturate()、desaturate()这两个函数是通过改变颜色的饱和度来得到一个新的颜色，他们和前面介绍的修改亮度得到新颜色的方法非常相似。 1234567891011121314$baseColor: #ad141e;.saturate &#123; background: saturate($baseColor,30%); //在原色饱和度基础上增加饱和度&#125;.desaturate &#123; background: desaturate($baseColor,30%);//在原色饱和度基础上减少饱和度&#125;//编译后.saturate &#123; background: #c1000d; &#125;.desaturate &#123; background: #903137; &#125; adjust-hue()函数这个是通过调整颜色的色相换算一个新颜色。他需要一个颜色和色相度数值。通常这个度数值是在-360deg至360deg之间，当然了可以是百分数： 1234567891011121314$baseColor: #ad141e;.adjust-hue-deg &#123; background: adjust-hue($baseColor,30deg);&#125;.adjust-hue-per &#123; background: adjust-hue($baseColor,30%);&#125;//编译后.adjust-hue-deg &#123; background: #ad5714; &#125;.adjust-hue-per &#123; background: #ad5714; &#125; grayscale()函数这个函数会颜色的饱和度值直接调至0%，所以此函数与desaturate($color,100%)所起的功能是一样的。一般这个函数能将彩色颜色转换成不同程度的灰色。例如： 1234567891011121314$baseColor: #ad141e;.grayscale &#123; background: grayscale($baseColor);&#125;.desaturate &#123; background: desaturate($baseColor,100%);&#125;//编译后.grayscale &#123; background: #616161; &#125;.desaturate &#123; background: #616161; &#125; Opacity函数alpha()、opacity()函数alphpa() 和 opacity() 函数很简单，与前面介绍的 red(),green() 等函数很类似。这个函数的主要功能是用来获取一个颜色的透明度值。如果颜色没有特别指定透明度，那么这两个函数得到的值都会是 1。 opacify()、fade-in()函数这两个函数是用来对已有颜色的透明度做一个加法运算，会让颜色更加不透明。其接受两个参数，第一个参数是原始颜色，第二个参数是你需要增加的透明度值，其取值范围主要是在 0~1 之间。当透明度值增加到大于 1 时，会以 1 计算，表示颜色不具有任何透明度。 transparentize()、 fade-out()函数transparentize() 和 fade-out() 函数所起作用刚好与 opacify() 和 fade-in() 函数相反，让颜色更加的透明。这两个函数会让透明值做减法运算，当计算出来的结果小于 0 时会以 0 计算，表示全透明。 Sass的@规则@importSass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。 Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。 文件拓展名是 .css； 文件名以 http:// 开头； 文件名是 url()； @import 包含 media queries。 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。 Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件： 1@import "rounded-corners", "text-shadow"; 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式： 12$family: unquote("Droid+Sans");@import url("http://fonts.googleapis.com/css?family=\#&#123;$family&#125;"); 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。 假设 example.scss 文件包含以下样式： 123.example &#123; color: red;&#125; 然后导入到 #main 样式内 123#main &#123; @import "example";&#125; 将会被编译为 123#main .example &#123; color: red;&#125; @mediaSass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。 12345678910111213.sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; &#125;&#125;//编译后.sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and 123456789101112@media screen &#123; .sidebar &#123; @media (orientation: landscape) &#123; width: 500px; &#125; &#125;&#125;//编译后@media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值： 1234567891011121314$media: screen;$feature: -webkit-min-device-pixel-ratio;$value: 1.5;@media #&#123;$media&#125; and ($feature: $value) &#123; .sidebar &#123; width: 500px; &#125;&#125;//编译后@media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; .sidebar &#123; width: 500px; &#125; &#125; @at-root@at-root 从字面上解释就是跳出根元素。当你选择器嵌套多层之后，想让某个选择器跳出，此时就可以使用 @at-root。来看一个简单的示例： 12345678910111213141516171819202122232425.a &#123; color: red; .b &#123; color: orange; .c &#123; color: yellow; @at-root .d &#123; color: green; &#125; &#125; &#125; &#125;//编译后.a &#123; color: red; &#125;.a .b &#123; color: orange; &#125;.a .b .c &#123; color: yellow; &#125;.d &#123; color: green; &#125; @debug@debug 在 Sass 中是用来调试的，当你的在 Sass 的源码中使用了 @debug 指令之后，Sass 代码在编译出错时，在命令终端会输出你设置的提示 Bug: 1234@debug 10em + 12em;//输出Line 1 DEBUG: 22em @warn@warn 和 @debug 功能类似，用来帮助我们更好的调试 Sass。如： 1234567891011121314151617181920@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @warn "Assuming #&#123;$x&#125; to be in pixels"; $x: 1px * $x; &#125; @if unitless($y) &#123; @warn "Assuming #&#123;$y&#125; to be in pixels"; $y: 1px * $y; &#125; position: relative; left: $x; top: $y;&#125;.button&#123; @include adjust-location(20px,30)&#125;//编译后.button &#123; position: relative; left: 20px; top: 30px; &#125; @error@error 和 @warn、@debug 功能是如出一辙。 1234567891011121314151617@mixin error($x)&#123; @if $x &lt; 10 &#123; width: $x * 10px; &#125; @else if $x == 10 &#123; width: $x; &#125; @else &#123; @error "你需要将#&#123;$x&#125;值设置在10以内的数"; &#125;&#125;.test &#123; @include error(15);&#125;//编译后你需要将15值设置在10以内的数 on line 7 at column 5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《CSS揭秘》学习笔记]]></title>
      <url>%2F2017%2F04%2F01%2F%E3%80%8ACSS%E6%8F%AD%E7%A7%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[这本书给我打开了css新的大门，看之前最好对css基础比较熟练，然后对css3的新特性有一定的了解。书中大部份代码都在github上，大部分手敲，有问题可以提交pr 关于本书$$()函数可以更容易地获取和遍历所有匹配特定CSS选择符的DOM元素： 12345function $$(selector,context)&#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 应该把标准语法排在最后，这样可以通过层叠机制来确保标准语法能够最终生效。 可以使用modernizr来针对支持或者不支持某些特性的浏览器分别编写样式。 自定义特性检测函数： 123456789function testProperty(property)&#123; var root = document.documentElement; if (property in root.style)&#123; root.classList.add(property.toLowerCase()); return true; &#125; root.classList.add('no-' + property.toLowerCase()); return false;&#125; 自定义检测某个具体值是否支持的函数： 12345678910function testValue(id,value,property)()&#123; var dummy = document.createElement("p"); dummy.style[property] = value; if (dummy.style[property])&#123; root.classList.add(id); return true; &#125; root.classList.add('no-' + id); return false;&#125; 引言Web标准：是敌还是友冰与火之歌：浏览器前缀常见浏览器前缀：Firefox的-moz-、IE的-ms-、Opera的-o-、Safari和Chrome的-webkit-。 自动添加浏览器前缀的工具： css3,please，允许把无前缀的css代码粘贴进去，它们会自动帮你把必要的前缀都加好。 css3generator，可视化的css3代码生成器（我补充的）。 autoprefixer，它是在本地完成编译的，类似于预处理器。 prefixfree，会在浏览器中进行特性检测，来决定哪些前缀是需要的，几乎不需要更新。 CSS编码技巧尽量减少代码重复字号和行高之间有关系，如果都写成绝对值，改变字号的时候好需要计算行高。当某些值相互依赖时，应该把他们的相互关系用代码表达出来。 12345678font-size: 20px;line-height: 30px;--------升级-----------font-size: 20px;line-height: 1.5;--------升级-----------font-size: 125%;/*假设父级字号是16px*/line-height: 1.5; 把下面一些长度单位单位改成em，这样这些效果就可以根据字号进行缩放，em可能会导致复杂的运算，因为它只能跟父级元素建立联系，这种情况下可以使用rem，rem是指相对于根元素的字体大小的单位，简单的说它就是一个相对单位。 把半透明的黑色或者白色叠加在主色调上，即可产生主色调的亮色和暗色变体，只要覆盖background-color属性，就可以得到不同颜色版本的按钮。 123456789101112131415161718192021222324252627282930313233343536padding: 6px 16px;border: 1px solid #446d88;background: #58a line-gradient(#77a0bb,#58a);border-radius: 4px;box-shadow: 0 1px 5px gray;color: white;text-shadow: 0 -1px 1px #335166;font-size: 20px;line-height: 30px;--------升级-----------padding: .3em .8em;border: 1px solid #446d88;background: #58a line-gradient(#77a0bb,#58a);border-radius: .2em;box-shadow: 0 .05em .25em gray;color: white;text-shadow: 0 -.05em .05em #335166;font-size: 125%;line-height: 1.5;--------升级-----------padding: .3em .8em;border: 1px solid rgba(0,0,0,.1);background: #58a line-gradient(hsla(0,0%,100%,.2),transparent);border-radius: .2em;box-shadow: 0 .05em .25em rgba(0,0,0,.5);color: white;text-shadow: 0 -.05em .05em rgba(0,0,0,.5);font-size: 125%;line-height: 1.5;button.cancel&#123; background-color: #c00;&#125;button.ok&#123; background-color: #6b0;&#125; currentColorcurrentColor是CSS有史以来的第一个变量。假设让所有水平分割线自动与文本颜色保持一致： 1234hr&#123; height: .5em; background: currentColor;&#125; 继承inherit总是绑定到父元素的计算值。 1input,button&#123;font: inherit;&#125; 相信你的眼睛，而不是数字有时候精准的尺度看起来并不精准，这种视觉上的错觉在任何形式的视觉设计中都普遍存在，我们的设计要顺应这种偏差。 关于响应式网页设计每个媒体查询都会增加成本。 不妨在媒体查询中使用em单位，这能让文本缩放在必要时触发布局的变化。 使用百分比长度来取代固定长度。如果实在做不到这点，也应该尝试使用与视口相关的单位（vm、vh、vmin和vmax），它们的值解析为视口的宽度或者高度的百分比。 当需要在较大分辨率下得到固定宽度时，使用max-width而不是width，因为它可以适应较小分辨率，而无需使用媒体查询。 不要忘记为替换元素（比如img、object、video、iframe等）设置一个max-width，值为100% 假如背景图片需要完整的铺满一个容器，不管容器的尺寸如何变化，background-size: cover这个属性都可做到。但是带宽并不是无限的，因此在移动设备中通过css把大图缩小显示往往是不明智的。 当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局（即flexbox）或者display: inline-block加上常规的文本折行行为，都可以实现这一点。 在使用多列文本时，指定column-width（列宽）而不是指定column-count（列数），这样它就可以在较小的屏幕上自动显示为单列布局。 实现弹性可伸缩的布局，并在媒体查询的各个断点区间内指定相应的尺寸。 合理使用简写12background: rebeccapurole;background-color: rebeccapurole; 上面两行代码并不等价，前者是简写，它可以确保你得到rebeccapurole纯色背景；使用后者有可能背景颜色会受到background-image影响，从而背景最终显示为其他的图案。 我应该使用预处理器吗123ul&#123; --accent-color: purple;&#125;ol&#123; --accent-color: rebeccapurole;&#125;li&#123; background: var(--accent-color);&#125; 这段原生css代码使用变量玩法，在有序列表中，li的背景颜色是rebeccapurole；在无序列表中，li的背景颜色是purple。 背景与边框半透明边框 RGBA(R,G,B,A)，R：红色值，正整数 | 百分数；G：绿色值，正整数 | 百分数；B：蓝色值，正整数 | 百分数；A：Alpha透明度，取值0~1之间。此色彩模式与RGB相同，只是在RGB模式上新增了Alpha透明度。IE6.0-8.0不支持使用 rgba 模式实现透明度，可使用 IE 滤镜处理。 HSLA(H,S,L,A)，H：Hue(色调)，0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色，取值为：0 - 360；S：Saturation(饱和度)，取值为：0.0% - 100.0%；L：Lightness(亮度)，取值为：0.0% - 100.0%；A：Alpha透明度，取值0~1之间。 默认情况下，背景会延伸到边框所在的区域下层。 在背景与边框第三版中可以通过background-clip属性来调整上面的默认行为带来的不便。 123border: 10px solid hsla(0,0%,100%,0.5);background: white;background-clip: padding-box; background-clip属性初始值是border-box，意味着背景会被元素的border box（边框的外沿边框）剪裁掉。padding-box意味着浏览器会用内边距的外沿来把背景剪裁掉。 多重边框box-shadow方案box-shadow第四个参数（称作扩张半径）通过指定正值或者负值，可以让投影面积加大或者减小。 一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的投影其实像一道实线边框： 12background: yellowgreen;box-shadow: 0 0 0 10px #655, 用box-shadow的好处在于，它支持逗号分隔语法，可以用来创建任意数量的投影： 123box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6); 唯一需要注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，假设为10px，如果外圈再加一道5px的外框，需要指定的扩张半径为：15px（10px+5px）。 需要注意的是： 投影不会影响布局，而且不会受到box-size属性的影响。不过可以通过内边距或者外边距来额外模拟出边框所需要占据的空间。 投影的边框出现在元素的外圈，不会影响鼠标事件。 outline方案如果只需要两层边框，可以先设置一层常规边框，再设置一层outline属性来产生外层的边框。这种方法有点在于边框样式比较灵活，可以模拟虚线边框的效果，还可以通过outline-offset属性来控制它跟元素边缘之间的间距，这个属性可以接受负值。但是这个方案中outline产生的边框不会贴合圆角边框。 12345678910111213141516171819202122232425262728293031323334353637#div1&#123; display: inline-block; color: white; text-align: center; width: 100px; height: 60px; margin: 25px 25px; background: yellowgreen; border: 10px solid #655; outline: 5px dashed deeppink;&#125;#div2&#123; display: inline-block; color: white; text-align: center; width: 100px; height: 60px; margin: 25px 25px; background: black; border: 10px solid black; outline: 1px dashed white; outline-offset: -5px;&#125;#div3&#123; display: inline-block; color: white; text-align: center; width: 100px; height: 60px; margin: 25px 25px; background: yellowgreen; border: 10px solid #655; border-radius: 15px; outline: 5px solid deeppink;&#125; 灵活的背景定位background-position的扩展语法方案在CSS背景与边框（第三版）中，background-position属性允许指定背景图片距离任意角的偏移量，只要在偏移量前面指定关键字。 123background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat #58a;background-position: right 20px bottom 10px; 对不支持background-position扩展语法的浏览器中，回退方案是把bottom right写到background简写属性中： 123background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;background-position: right 20px bottom 10px; background-origin方案当偏移量与容器内边距一致的时候，可以用background-origin，让偏移量自动跟着内边距走。 默认情况下，background-position的偏移量是以padding box为准，这样边框才不会遮住背景图片。在背景与边框（第三版）中的background-origin属性可以改变这种行为，其默认值是padding box，改成content-box后background-position的偏移量以content-box为准。 calc()方案请不要忘记在calc()函数内部的-和+运算符的两侧各加一个空白符，否则会产生解析错误。 123background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;background-position: calc(100% - 20px) calc(100% - 10px); 边框内圆角12345outline: .6em solid #655;box-shadow: 0 0 0 .4em #655; /* todo calculate max of this */border-radius: .8em;padding: 1em;background: tan; 描边并不会跟着元素的圆角走，但是box-shadow会，两者叠加到一起，box-shadow刚好填补描边和容器圆角之间的空隙，达到下图的效果。扩张值等于描边宽度可能会浏览器渲染异常，所以扩张半径取圆角半径的一半，并且描边的宽度要比圆角半径的一半要小。 条纹背景如果多个色标具有相同的位置，它们会产生一个无限小的过度区域，过度的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程：background: linear-gradient(#fb3 50%, #58a 50%);。 关于linear-gradient()，MDN是这样说明的（颜色参数后面的长度参数是渐变的起始位置或者终止位置）： 如果第二个色标的位置值设为0，那它的位置就总会被浏览器调整为前一个色标的位置值。background: linear-gradient(#fb3 50%, #58a 0); 垂直条纹1234background: linear-gradient(to right, #fb3 50%, #58a 0);/*或者这样写*//*background: linear-gradient(90deg, #fb3 50%, #58a 0);*/background-size: 30px 100%; 斜向条纹单个贴片中包含四条条纹，才有可能无缝拼接成斜向条纹。 条纹宽度要和垂直条纹宽度一样时，条纹宽度需要通过勾股定理计算。 12background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0); background-size: 42px 42px; 更好的斜向条纹可以通过linear-gradient()（radial-gradient()）的循环加强版repeating-linear-gradient()（repeating-radial-gradient()）来实现斜向条纹，和前者相比，后者的色标是无限循环的。 使用repeating-radial-gradient()可以随意改变斜纹的角度，而且代码中的长度直接表示条纹自身宽度。 1background: repeating-linear-gradient(45deg, #fb3 0, #fb3 15px, #58a 0, #58a 30px); 灵活的同色系条纹如果条纹图案属于同色系，只是在明暗方面有着轻微的差别，可以这样写： 1234 background: #58a; background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1) 0, hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px);---------等同于---------background: repeating-linear-gradient(30deg, #79b 0, #79b 15px, #58a 0, #58a 30px); 这样写只需要修改一处就可以改变所有颜色，而且对不支持css渐变的浏览器来说起到了回退作用。 复杂的背景图案网格1234567 background: white; background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 0),linear-gradient(rgba(200,0,0,.5) 50%, transparent 0); background-size: 30px 30px;----------改进版，可方便的改变网格尺寸、线宽、颜色---------- background: #5588aa; background-image: linear-gradient( white 1px, transparent 0),linear-gradient(90deg,white 1px, transparent 0); background-size: 30px 30px; 波点12345background: #655; background-image: radial-gradient(tan 30%, transparent 0), radial-gradient(tan 30%, transparent 0); background-size: 30px 30px; background-position: 0 0,15px 15px; 为了达到波点的效果，第二层背景的偏移定位必须是贴片宽高的一半。为了方便维护，可以使用scss的mixin： 1234567@mixin polka($size,$dot,$base,$accent)&#123; background: $base; background-image: radial-gradient($accent $dot, transparent 0), radial-gradient($accent $dot, transparent 0); background-size: $size $size; background-position: 0 0,$size/2 $size/2;&#125; Bennett的图案库 伪随机背景12345678background: hsl(20,40%,90%);background-image: linear-gradient(90deg, #fb3 10px, transparent 0), linear-gradient(90deg, #ab4 20px, transparent 0), linear-gradient(90deg, #655 20px, transparent 0); background-size: 41px 100%,61px 100%,83px 100%; width: 300px; height: 100px; margin: 2em 2em; 贴片尺寸是background-size的最小公倍数，也就是每隔41px*61px*83px后贴片会重复，所以background-size尽量选择质数，使得最小公倍数尽可能大，减小重复。 连续的图像边框border-image工作原理是把图片分成9块，然后把他们应用到元素边框的边和角。 使用border-image生成边框，需要额外的html元素： 12345678910111213141516.div3&#123; background: url(http://csssecrets.io/images/stone-art.jpg); background-size: cover; /* Styling &amp; enable resize */ width: 21em; padding: 1em; overflow: hidden; resize: both; font: 100%/1.6 Baskerville, Palatino, serif; margin: 5em 5em;&#125;.div3 &gt; div&#123; background: white; padding: 1em;&#125; 1&lt;div class="div3"&gt;&lt;div&gt;i am a man&lt;/div&gt;&lt;/div&gt; 还可以在背景图片之上，再叠加一层纯白实色背景，这两层背景分别设置不同的background-clip值，并且background-origin设置为border-box，这样使得背景图片在border-box范围内平铺： 1234567 padding: 1em;border: 1em solid transparent; background: linear-gradient(white , white), url(http://csssecrets.io/images/stone-art.jpg); background-size: cover; background-clip: padding-box,border-box; background-origin: border-box 这个技巧可以用来做蚂蚁行军框： 123456789101112131415161718@keyframes div5 &#123; to &#123;background-position: 100%&#125;&#125;.div5&#123; border: 1px solid transparent; background: linear-gradient(white , white) padding-box, repeating-linear-gradient(-45deg , black 0,black 25%, white 0,white 50%) 0 / .6em .6em; animation: div5 12s linear infinite; /* Styling &amp; enable resize */ width: 21em; padding: 1em; font: 100%/1.6 Baskerville, Palatino, serif; margin: 5em 5em;&#125; border-image配合渐变图案生成顶部边框被剪裁的效果： 123border-top : .2em solid transparent; border-image : 100% 0 0 linear-gradient(90deg, currentColor 4em, transparent 0); padding-top : 1em; 形状自适应椭圆给任何足够大的正方形元素设置一个足够大的border-radius就可以把它变成一个圆形。 当任意两个相邻圆角的半径之和超过border box的尺寸时，用户代理必须按比例减小各个边框半径所使用的值，直到它们不会相互重叠为止。 border-radius可以单独指定水平和垂直半径，只要用/分隔两个值即可。 border-radius不仅可以接受长度值，还可以接受百分比。 border-radius: 50%;可以实现自适应椭圆。 border-radius是简写，对应的展开式属性为：border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius。可以向border-radius一次性提供空格分隔的多个值。如果传了4个值，这4个值分别从左上角开始以顺时针顺序应用到元素的各个拐角；如果传了3个值，意味着第四个值与第二个值相同；如果传了2个值，意味着第三个值与第一个相同。 可以为所有四角提供完全不同的水平半径和垂直半径：斜杠前指定1~4个值，斜杠后指定1~4个值：border-radius: 10px/5px 20px; 自适应的半椭圆：border-radius: 50%/100% 100% 0 0; 自适应四分之一椭圆：border-radius: 100% 0 0 0; 平行四边形嵌套元素方案用skew()变形属性对矩形进行斜向拉伸：transform: skewX(-45deg);。 直接用skew()拉伸内容也会拉伸，此时可以对内容再用一次反向skew()变形，缺点是需要额外的HTML元素包裹内容。 伪元素方案另一种方法是把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形，因为内容不包含在伪元素中，所以内容不会受到影响： 12345678910111213141516171819202122.button2 &#123; position: relative; color: white; font: bold 200%/1 sans-serif; padding: .5em 1em; border: 0;&#125;.button2::before &#123; content: ""; /*用伪元素生成一个矩形*/ /*偏移量设置为0，以便让伪元素在水平和垂直方向上都被拉伸至宿主元素的尺寸*/ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1;/*伪元素生成的方块位于内容之上，设置z-index后会推到宿主元素之后*/ background: #5588aa; transform: skew(45deg);&#125; 当想变形一个元素而不想变形它的内容时都可以用到上面的代码。 菱形图片基于变形的方案1234567891011121314.div1 &#123; width: 250px; height: 250px; transform: rotate(45deg); overflow: hidden; margin: 100px;&#125;.div1 img&#123; max-width: 100%; transform: rotate(-45deg) scale(1.42); z-index: -1; position: relative;&#125; 123&lt;div class="div1"&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" /&gt;&lt;/div&gt; max-width: 100%会被解析为容器的边长。要显示为菱形，图片的宽度要与容器的对角线相等。 通过scale()变形样式缩放图片时，是以它的中心点进行缩放的。通过width属性来放大图片时，只会以它的左上角为原点进行缩放。 裁切路径方案clip-path属性可以把元素剪裁成任何形状。polygon()是多边形函数，可以用一系列坐标点来指定任意的多边形，使用百分比时会解析为元素自身的尺寸。 1clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); 只要使用同一种形状函数并且点的数量相同，clip-path属性可以参与动画： 12345678.img2&#123; clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); transition: 1s clip-path;&#125;.img2:hover&#123; clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);&#125; 切角效果linear-gradient可以接受一个角度作为方向，色标的位置信息也可以是绝对的长度值。 12background: #5588aa;background: linear-gradient(45deg, white 15px,#5588aa 0); 四角切角效果需要把background-repeat关掉，防止四层渐变背景相互覆盖。 1234567background: #5588aa;background: linear-gradient(135deg, white 15px,#5588aa 0) top left, linear-gradient(-135deg, white 15px,#5588aa 0) top right, linear-gradient(-45deg, white 15px,#5588aa 0) bottom right, linear-gradient(45deg, white 15px,#5588aa 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 弧形切角123456background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, radial-gradient(circle at top right, transparent 15px, #58a 0) top right, radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 内联SVG与border-image方案SVG可以实现与尺寸完全无关的缩放，此处使用的切片尺寸是1，它所对应的是SVG文件的坐标系统，因此不需要单位。background-clip属性避免背景色蔓延到边框区域。 border-width支持动画效果。 1234567border: 21px solid transparent;border-image: 1 url('data:image/svg+xml,\ &lt;svg xmlns="http://www.w3.org/2000/svg" width="3" height="3" fill="%2358a"&gt;\ &lt;polygon points="0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2" /&gt;\ &lt;/svg&gt;'); background: #58a; background-clip: padding-box; 裁切路径方案clip-path属性中可以同时使用百分比数值和绝对长度。 12345background: #58a;clip-path: polygon(20px 0, calc(100% - 20px) 0, 100% 20px, 100% calc(100% - 20px), calc(100% - 20px) 100%, 20px 100%, 0 calc(100% - 20px), 0 20px); 这个方法不仅可以对任意类型的背景进行裁剪，甚至对替换元素（比如图片）进行裁剪，而且还支持动画效果。 由于它只能对元素做统一的裁剪，当内边距不够宽时，这个方案会裁剪掉文本。渐变方案允许文字溢出并超出切角区域，而border-image方案则会起到普通边框的作用，令文字折行。 梯形标签页对元素使用3d变形后，其内部的变形效应是不可逆的。 当没有设置transform-origin属性时，应用变形效果会让这个元素以它自身的中心线为轴进行空间上的旋转，因此元素投射到2D屏幕上的尺寸会发生变化。指定transform-origin: bottom;，当元素在3D空间中旋转时，可以把它的底边固定住。 12345678910111213141516171819.div1&#123; height: 50px; width: 100px; color: white; position: relative; line-height: 50px; margin: 5em 5em; text-align: center;&#125;.div1::before&#123; content: ""; position: absolute; top: 0;right: 0;left: 0;bottom: 0; z-index: -1; background: #5588aa; transform: perspective(.5em) rotateX(5deg) scaleY(1.3); transform-origin: bottom;&#125; 这个方法可以给梯形标签页添加背景、边框。圆角。投影等一系列样式，并且只需要把transform-origin改成bottom left或者buttom right就可以立刻得到左侧倾斜或者右侧倾斜的标签页。但是这个方法的斜边角度依赖于元素的宽度。 简单的饼图基于transform的解决方案用伪元素覆盖上去，通过旋转决定露出多大扇形区。 12345678910.pie::before &#123; content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; /*背景元素与宿主元素保持一致,比率超过50%时改成棕色*/ transform-origin: left; /*伪元素圆形的圆形旋转，还可以写成transform-origin: 0 50%*/ animation: spin 3s linear infinite, bg 6s step-end infinite;&#125; 一个负的延时值是合法的。与0s的延时类似，它意味着动画会立即开始播放，但会自动前进到延时值的绝对值处，就好像动画在过去已经播放了指定的时间一样。因此实际效果就是动画跳过指定时间而从中间开始播放了。 可以用负的动画延时来直接跳至动画中的任意时间点，并且定格在那里，以此来实现按照比率来显示饼图。这里的动画永远处于暂停状态，指定的持续时间并不会产生任何副作用。 SVG解决方案stroke-dasharray: 20 10;是为虚线描边而准备的，20是虚线线段长度，10是间隙长度。 SVG描边时总会把一半绘制在元素外部，另一半绘制在元素内部： 视觉效果单侧投影单侧投影投影box-shadow: 2px 3px 4px rgba(0,0,0,5);的绘制过程： 在该元素相同尺寸和位置绘制颜色为rgba(0,0,0,5)的矩形； 把它向右移2px，向下移3px； 使用高斯模糊算法进行4px的模糊处理，本质上表示在阴影边缘发生阴影色和纯透明色之间的颜色过度长度近似于模糊半径的两倍（在这里就是8px）； 模糊后的矩形与原始元素交集部分会被切除掉。 所以box-shadow中，没有任何投影绘制在元素的下层。 text-shadow中，文字下层的投影不会被剪裁。 使用4px的模糊半径意味着投影的尺寸会比元素本身的尺寸大8px；因此投影的最外圈会从元素的四面向外显露出来。 box-shadow还有第四个长度参数—扩张半径，这个参数会根据指定的值去扩大或者缩小投影尺寸。比如，一个-5px的扩张半径会把投影的宽度和高度各减少10px（每边5px）。 1box-shadow: 0 5px 4px -4px rgba(0,0,0,5); 邻边投影扩张半径设为模糊半径相反值的一半，并且偏移量的值需要大于或者等于模糊半径的一半，比如，把6px模糊半径的投影设置到右侧和底部： 1box-shadow: 3px 3px 6px -3px rgba(0,0,0,5); 双侧投影设置两块投影（运用两次单侧投影）以实现双侧投影的效果： 12box-shadow: 5px 0 5px -5px rgba(0,0,0,5), -5px 0 5px -5px rgba(0,0,0,5); 不规则投影使用filter滤镜属性，该属性只需要一些函数，就可以指定滤镜效果，比如blur()、grayscale()、drop-shadow()等。 1filter: blur() grayscale() drop-shadow(); drop-shadow()带有的参数和box-shadow属性一样，但是不包括扩张半径，不包括insert关键字，也不支持逗号分隔的多层投影语法： 1filter: drop-shadow(2px 2px 10px rgba(0,0,0,.5)); 任何非透明的部分都会被打上投影，如果文字被搭上投影，不能用text-shadow: none去除。 染色效果基于滤镜的方案sepia()滤镜会给图片增加一种降饱和度的橙黄色染色效果，几乎所有像素的色相值都会被收敛到35~40： 1filter: sepia(); saturate()滤镜可以给每个像素提升饱和度；hue-rotate()滤镜把每个像素的相色以指定的度数进行偏移。 1filter: sepia(1) saturate(4) hue-rotate(295deg); 基于混合模式的方案luminosity混合模式会保留上层元素的HSL亮度信息，并从下层吸取色相的饱和度信息。 background-blend-mode: luminosity;可以为每层背景单独指定混合模式，不用&lt;img&gt;元素，而是用&lt;div&gt;元素，把这个元素的第一层背景设置为要染色的图片，并把第二层颜色设置成想要的主色调； mix-blend-mode: luminosity;可以为整个元素设置混合模式，需要把图片包裹在一个容器中，并把容器的背景色设置成想要的主色调。 混合模式不可以加动画。把属性设置为luminosity混合模式，图片总会跟某些东西进行混合，如果要加上过度动画，可以通过修改背景颜色的方式实现，比如，可以把背景图片和一个透明背景混合，此时不会出现任何混合效果： 毛玻璃效果blur()会使整个元素都会模糊。所以不能对元素本身进行模糊处理，这样文字也会变模糊。 可以对一个伪元素进行处理，然后将其定位到元素下层，它的背景将会无缝匹配&lt;body&gt;的背景。 12345678910111213141516171819202122232425262728main &#123; position: relative; margin: 0 auto; padding: 1em; max-width: 23em; background: hsla(0,0%,100%,.25) border-box; overflow: hidden; border-radius: .3em; box-shadow: 0 0 0 1px hsla(0,0%,100%,.3) inset, 0 .5em 1em rgba(0, 0, 0, 0.6); text-shadow: 0 1px 1px hsla(0,0%,100%,.3);&#125;main::before &#123; content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: -30px; /*为了让边缘不出现逐渐消退的效果，需要让伪元素 相对其宿主元素的尺寸再向 外扩大 至少 20px （即它的模糊半径）。由于不同浏览器的模糊算法可能存在差异， 用一个更大的绝对值（比 如 -30px ）会更保险一些。*/ z-index: -1;/*把伪元素移动到宿主元素后面*/ -webkit-filter: blur(20px);/*设置伪元素模糊效果*/ filter: blur(20px);&#125;body, main::before &#123; /*第二张图是去掉body的效果*/ background: url("http://csssecrets.io/images/tiger.jpg") 0 / cover fixed; /*把伪元素和body背景设置为相同的图片，因为main元素有overflow: hidden;所以超出main元素大小的部分会被剪裁掉*/&#125; 折角效果45°折角的解决方案切角效果的矩形和渐变生成的小三角形重合。要注意，第二层渐变中的1.5em是沿着渐变轴测量的，第一层渐变中background-size中的2em长度是背景贴片的宽度和高度。为了两者尺寸一致，需要把原来切角渐变的角标位置2em除以√2变成1.5em。 1234background: #58a; /* Fallback */ background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg, transparent 1.5em, #58a 0); 其他角度的解决方案123456789101112131415161718192021222324252627282930.div5 &#123; position: relative; background: #5588aa; background: linear-gradient(-150deg,transparent 1.5em,#5588aa 0); border-radius: .5em; margin-top: 2em; width: 12em; font: 100%/1.6 Baskerville, Palatino, serif; padding: 2em; color: white;&#125;.div5::before&#123; content: ''; position: absolute; top: 0;right: 0; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; /*移动并旋转伪元素与切角对齐*/ transform: translateY(-1.3em) rotate(-30deg); /*让三角形的右下角成为旋转中心，方便计算便宜距离*/ transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; 字体排印连字符断行hyphens属性有三个值：none、manual、auto。manual为默认值，它允许任何时候手工插入软连字符（&amp;shy;），来实现断词折行的效果。hyphens属性会优先处理软连字符，再去计算其他可以断词的地方。 hyphens属性的auto值可以比较好的实现连字符断行，不过需要在在HTML标签的lang属性中指定合适的语言。 1hyphens: auto; 插入换行\A在Unicode中代表换行，可以用它来作为 ::after伪元素的内容，并将其添加到每个 &lt;dd&gt;元素的尾部。 设置white-space: pre; 保留源代码中 的空白符和换行。 如果你的结构代码在多个连续的 &lt;dd&gt;之间包含了（未加 注释的）空白符，那么逗号前面会有一个空格。可以利用负外边距修复这个问 题，但如果你的内容是以不一样的字体和尺寸来 显示的， 这个空隙的宽度就 不一定刚好 是 0.25em 。 1234567891011121314151617181920212223dt, dd &#123; display: inline; margin: 0;&#125;dd &#123; font-weight: 600;&#125;dd + dt::before &#123; content: "\A"; white-space: pre;&#125;dd + dd::before &#123; content: ', '; font-weight: normal; margin-left: -.25em;&#125;body &#123; font: 150%/1.6 Baskerville, Palatino, serif;&#125; 1234567891011&lt;dl&gt; &lt;dt&gt;Name:&lt;/dt&gt; &lt;dd&gt;Lea Verou&lt;/dd&gt; &lt;dt&gt;Email:&lt;/dt&gt; &lt;dd&gt;lea@verou.me&lt;/dd&gt; &lt;dd&gt;leaverou@mit.edu&lt;/dd&gt; &lt;dt&gt;Location:&lt;/dt&gt; &lt;dd&gt;Earth&lt;/dd&gt;&lt;/dl&gt; 文本行的斑马条纹可以在 CSS 中用渐变直接生成背景图像，用 em 单位来设定背景尺寸，这样背景就可以自动适应 font-size 的变化了。 12345678910111213141516pre &#123; padding: .5em; /*创建出水平条纹背景。它的background-size需要设置为line-height的两倍，因为每个背景贴片需要覆盖两行代码。*/ line-height: 1.5em; background: hsl(20, 50%, 95%); background-image: linear-gradient( rgba(120,0,0,.1) 50%, transparent 0); background-size: auto 3em; /*让背景自动跟着内边距的宽度走*/ background-origin: content-box; font-family: Consolas, Monaco, monospace;&#125; 调整tab的宽度tab-size属性接受一个数字（表示字符数）或者一个长度值（这个不那么实用）来调整tab缩进尺寸。 连字font-variant-ligatures专门用来控制连字效果的开启和关闭。如果要启用所有可能的连字，需要同时指定这三个标识符： 1font-variant-ligatures: common-ligatures discretionary-ligatures historical-ligatures; 可以显式地把两种连字关闭： 1font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures; 如果要把font- variant-ligatures属性复位为初始值，应该使用normal而不是none，none会把所有连字效果都关掉。 华丽的&amp;符号在 font-family 声明中同时指定多个字体（即字体队列 ）这样，即使我们指定的最优先字体不可用，浏览器还可以回退到其他符合整 体设计风格的字体。但是，很多开发者都忽略了一点：这个机制对单个字符 来说也是有效的。如果某款字体可用，但仅包括某几个字符，那它就只会用 来显示这几个字符；而在显示其他字符时，浏览器就会回退到其他字体。这 个规则对本地字体和通过 @font-face 规则引入的嵌入字体都是有效的。 @font-face 规则中的 src 描述符还可以接受 local() 函数，用于指定本地字体的名称。 1234567@font-face &#123; font-family: Ampersand; src: local ('Baskerville'), local ('Goudy Old Style'), local ('Garamond'), local ('Palatino'); &#125; unicode-range描述符只在@font-face规则内部生效（因此这里用了描述符这个术语；它并不是一个 CSS 属性），它可以把字体作用的字符范围限制在一个子集内。它对本地字体和远程字体都是有效的。 1unicode-range : U+26; 可以在控制台用下面语句查询字符的16进制Unicode码位： 1"&amp;".charCodeAt(0).toString(16); // 返回26 如果你想指定一个字符区间，还是要加上U+前缀， 比如U+400-4FF。 实际上对于这个区间来说， 你还可以使用通配符， 以这样的方式来写：U+4??。同时指定多个字符或多个区间也是允许的，把它们用逗号隔开即可， 比如U+26,U+4??, U+2665-2670 。 123456789@font-face &#123; font-family: Ampersand; src: local('Baskerville-Italic'), local('GoudyOldStyleT-Italic'), local('Garamond-Italic'), local('Palatino-Italic'); unicode-range: U+26;&#125;h1 &#123; font-family: Ampersand, Helvetica, sans-serif;&#125; 自定义下划线使用background-image及其相关属性生成下划线。可以设置两层与背景色相同的text-shadow来模拟下划线在遇到字母时会自动断开避让的效果： 123456a &#123; background: linear-gradient(gray, gray) no-repeat; background-size: 100% 1px; background-position: 0 1.02em; text-shadow: .05em 0 white, -.05em 0 white;&#125; 使用渐变来实现下划线的高明之处在于， 这些线条 极为灵活。比如生成虚线下划线： 12background: linear-gradient(90deg, gray 66%, transparent 0) repeat-x; background-size: .2em 2px;background-position: 0 1em; 现实中的文字效果凸版印刷效果出现在底部的浅色投影（或者出现在顶部的暗色投影）会让人 产生物体是凹进平面内的错觉。同理，出现在底部的暗色投影（或者出现在 顶部的浅色投影）会让人产生物体从平面上凸起的错觉。 空心字效果 使用多个 text-shadow ，分别为这些投影加上不同方向的少量偏移： 1234background: deeppink;color: white;text-shadow: 1px 1px black, -1px -1px black, 1px -1px black,-1px 1px black; 重叠多层轻微模糊的投影来模拟描边。这种方法不需要设置偏移量，但是性能较差，因为使用了模糊算法： 12345background: deeppink;color: white;text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black; SVG方案： 12345678910111213141516171819h1&#123; font: 500%/1 Rockwell, serif; background: deeppink; color: white;&#125;h1 text&#123; fill: currentcolor;&#125;h1 svg&#123; overflow: visible;&#125;h1 use&#123; stroke: black; stroke-width: 6; stroke-linejoin: round;&#125; 123456&lt;h1&gt; &lt;svg width="2em" height="1.2em"&gt; &lt;use xlink:href="#css"/&gt; &lt;text id="css" y="1em"&gt;css&lt;/text&gt; &lt;/svg&gt;&lt;/h1&gt; 文字外发光效果 通过几层重叠的 text-shadow，但是依赖 text-shadow 来实现文字显示的做法无法实 现平稳退化： 12345678910.p1 &#123; font: 250%/1.6 Baskerville, Palatino, serif; background: #203; color: white; transition: 1s;&#125;.p1:hover&#123; text-shadow: 0 0 .1em, 0 0 .3em;&#125; 使用 CSS 滤镜来实现文字的模糊效果： 12345678910.span3 &#123; font: 250%/1.6 Baskerville, Palatino, serif; background: #203; color: white; transition: 1s;&#125;.span3:hover&#123; filter: blur(.1em);&#125; 文字凸起效果使用一长串累加的投影， 不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强 烈模糊的暗投影，从而模拟完整的立体效果。 1234567891011.p1 &#123; font: 250%/1.6 Baskerville, Palatino, serif; background: #58a; color: white; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px black;&#125; 环形文字12345678910&lt;div class="circular"&gt; &lt;svg viewBox="0 0 100 100"&gt; &lt;path d="M 0,50 a 50,50 0 1,1 0,1 z" id="circle"/&gt; &lt;text&gt; &lt;textPath xlink:href="#circle"&gt; circular reasoning works because &lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/div&gt; M 0,50 ：移动到点 (0,50) 。 a 50,50 0 1,1 0,1 ：以当前所在的这个点为起点，以当前点右侧 0单位、下方 1 单位的那个点为终点， 画一段圆弧。这段圆弧的水平 半径和垂直半径都必须是 50。如果存在两种可能的圆弧度数，选择 度数较大的那一种；同时，如果存在两种可能的圆弧方向， 选择画 在这两个点右侧的那一种，而不是左侧的。 z ：用一条直线线段闭合这条路径。 通过 &lt;text&gt; 和 &lt;textPath&gt;元素来添加文本，并通过xlink:href属性来把它链接到这个圆上： 123456789101112131415161718.circular path &#123; fill: none;&#125;.circular &#123; width: 30em; height: 30em; /*把 SVG 元素自身往下推*/ margin: 3em auto 0;&#125;.circular svg &#123; display: block; /*取消把溢出内容裁切效果*/ overflow: visible;&#125; 用脚本遍历所有设置了 circular 类的元素，将其文本内容删除并保存在变量中，然后为其填入必要的 SVG 元素： 123&lt;div class="circular" &gt; circular reasoning works because &lt;/div&gt; 12345678910111213141516171819202122$$('.circular').forEach(function (el) &#123; var NS = "http://www.w3.org/2000/svg"; var xlinkNS = "http://www.w3.org/1999/xlink"; var svg = document.createElementNS(NS, "svg"); var circle = document.createElementNS(NS, "path"); var text = document.createElementNS(NS, "text"); var textPath = document.createElementNS(NS, "textPath"); svg.setAttribute("viewBox", "0 0 100 100"); circle.setAttribute("d", "M0,50 a50,50 0 1,1 0,1z"); circle.setAttribute("id", "circle"); textPath.textContent = el.textContent; textPath.setAttributeNS(xlinkNS, "xlink:href", "#circle"); text.appendChild(textPath); svg.appendChild(circle); svg.appendChild(text); el.textContent = ''; el.appendChild(svg);&#125;); 用户体验选择合适的鼠标光标提示禁用状态123:disabled , [ disabled ], [ aria - disabled ="true"] &#123; cursor : not-allowed; &#125; 隐藏鼠标光标在css2.1中需要用到一张 1×1 的透明 GIF 图片，然后cursor:url(&#39;transparent.gif&#39;); 在css3中只要：cursor: none;。 扩大可点击区域 Fitts 法则认为，人类移动到某个 目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。 为按钮设置一圈透明边框： 123456789 border: 10px solid transparent; /*把背景限制在原本的区域内*/ background: #58a; background-clip: padding-box;/*用box-shadow模拟边框*/ box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset; 通过伪元素代表其宿主元素来响应鼠标交互： 1234567891011121314151617181920.button1 &#123; position: relative; padding: .3em .5em; background: #58a; border-radius: 50%; border: 1px solid rgba(0,0,0,.3); box-shadow: 0 .1em .2em -.05em rgba(0,0,0,.5); color: white; font: bold 150%/1 sans-serif; cursor: pointer;&#125;.button1:before &#123; content: ''; position: absolute; /*伪元素在四个方向上都比宿主元素大出10px*/ top: -10px; right: -10px; bottom: -10px; left: -10px;&#125; 自定义复选框伪类选择符:checked和属性选择符[checked]的区别是：后者不会根据用户的交互行为进行更新，因为用户的交互不会影响到HTML标签上的属性。 可以基于复选框的勾选状态借助组合选择符来给其他元素设置样式。 123456789101112131415161718192021222324252627282930313233343536input[type="checkbox"] &#123; /*隐藏原始的复选框，不能使用display: none，这样会把它从tab键切换焦点的队列完全删除*/ position: absolute; clip: rect(0,0,0,0);&#125;/*设置紧邻input的label伪元素样式*/input[type="checkbox"] + label::before &#123; content: '\a0'; display: inline-block; vertical-align: .2em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background: silver; text-indent: .15em; line-height: .65;&#125;/*设置紧邻已经勾选的input的label伪元素的样式*/input[type="checkbox"]:checked + label::before &#123; content: '\2713'; background: yellowgreen;&#125;input[type="checkbox"]:focus + label::before &#123; box-shadow: 0 0 .1em .1em #58a;&#125;input[type="checkbox"]:disabled + label::before &#123; background: gray; box-shadow: none; color: #555; cursor: not-allowed;&#125; 12&lt;input type="checkbox" id="awesome" autofocus /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; 把&lt;label&gt;元素与复选框关联，让它起到触发开关的作用，为它添加生成性内 容（伪元素），并基于复选框的状态来为其设置样式。把真正 的复选框隐藏起来，再 把生成性内容美化一番，用来顶替原来的复选框。 开关式按钮用同样的思路可以实现开关式按钮： 123456789101112131415161718192021222324input[type="checkbox"] &#123; position: absolute; clip: rect(0,0,0,0);&#125;input[type="checkbox"] + label &#123; display: inline-block; padding: .35em .5em .2em; background: #ccc; background-image: linear-gradient(#ddd, #bbb); border: 1px solid rgba(0,0,0,.2); border-radius: .3em; box-shadow: 0 1px white inset; text-align: center; text-shadow: 0 1px 1px white; cursor: pointer;&#125;input[type="checkbox"]:checked + label,input[type="checkbox"]:active + label &#123; box-shadow: .04em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb;&#125; 12&lt;input type="checkbox" id="awesome" autofocus /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; 在绝大多数场景下，开关式按钮 对可用性有负面作用，因为它们很容易与普通按钮混淆，让人误以为按下它 会触发某个动作。 通过阴影来弱化背景配合HTML实现1234567891011121314151617/*用于遮挡背景*/.overlay&#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0,0,0,.8);&#125;/*需要吸引用户注意的元素*/.lightbox &#123; position: absolute; z-index: 1; top: 50%; left: 50%; margin: -200px;&#125; 这个方案需要增加额外的HTML，.overlay负责把这个关键元素背后的所有东西调暗。 伪元素方案123456789101112131415.lightbox::before &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: rgba(0, 0, 0, .8);&#125;.lightbox &#123; position: absolute; z-index: 1; top: 50%; left: 50%; margin: -200px;&#125; 这个方案没有成功~~~ box-shadow方案box-shadow的扩张参数可以把元素的投影向各个方 向延伸放大。具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而 拙劣地模拟出遮罩层的效果： 1234567.lightbox &#123; position: fixed; top: 50%; left: 50%; margin: -200px; box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .8);&#125; vmax是视口单位，1vmax相当于1vw和1vh两者中的较大值。100vw等于整 个视口的宽度，100vh就是视口的高度。因此，满足我们需求的最小值就是50vmax。 由于投影是同时向四个方向扩展的， 这个遮罩层的最终尺寸将是100vmax加上元素本身的尺寸。 这个方案的缺点是： 由于遮罩层的尺寸是与视口相关，而不是与页面相关的，当我们 滚动页面时，遮罩层的边缘就露出来了，除非给它加上position: fixed; 当使用一个独立的元素（或伪元素）来实现遮罩层时，这个遮罩 层不仅可以从视觉上把用户的注意力引导到关键元素上，还可以防止用户的 鼠标与页面的其他部分发生交互， 因为遮罩层会捕获所有指针事件。box- shadow并没有这种能力， 因此它只能在视觉上起到引导注意力的作用， 却 无法阻止鼠标交互。 backdrop方案&lt;dialog&gt;元素可以由它的showModal()方法显示出来。根据浏览器 的默认样式，它会自带一个遮罩层。借助::backdrop伪元素，这个原生的 遮罩层也是可以设置样式的，比如可以把它变得更暗一些： 123dialog::backdrop &#123; background: rgba(0,0,0,.8)&#125; 12345&lt;button onclick="document.querySelector('#modal').showModal()"&gt;Click me&lt;/button&gt;&lt;dialog id="modal"&gt; O HAI! &lt;button onclick="this.parentNode.close()"&gt;Close&lt;/button&gt;&lt;/dialog&gt; 浏览器对它的支持还极为有限。 通过模糊来弱化背景&lt;main&gt;元素它可以把页面中的主要内容标记出来（对话框通常都不是主要内 容），同时还给了我们添加样式的钩子。 12&lt;main&gt;.....&lt;/main&gt;&lt;dialog&gt;o hai&lt;/dialog&gt; 12345678main.de-emphasized &#123; -webkit-filter: blur(3px); filter: blur(3px);&#125;main &#123; transition: .6s; background: white;&#125; 可以通过contrast()和brightness()滤镜同时实现模糊效果和阴影效果来弱化背景： 1filter: blur(3px) contrast(.8) brightness(.8); 但是这个方法没有任何回退方案。 滚动提示background-attachment属性有三个值：scroll、fixed、local。scroll是默认值，背景图像会随着页面其余部分的滚动而移动。fixed表示页面的其余部分滚动背景图像不会移动。local表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。 达到上面动图的效果，需要用两层背景，一层用来生成那条阴影，另一层基本 上就是一个用来遮挡阴影的白色矩形，其作用类似于遮罩层。生成阴影的那 层背景将具有默认的 background-attachment值（scroll），因为我们希望 它总是保持在原位。 我们把遮罩背景的background-attachment属性设置 为local，这样它就会在我们滚动到最顶部时盖住阴影，在向下滚动时跟着 滚动，从而露出阴影。 123456789101112ul &#123; /*基本样式，让ul的高度小于内容的高度*/ display: inline-block; overflow: auto; width: 7.2em; height: 7em; border: 1px solid silver; padding: .3em .5em; list-style: none; margin-top: 2em; font: 100 200%/1.6 'Frutiger LT Std', sans-serif;&#125; 1234567891011121314151617181920212223242526.ul1 &#123; /*通过径向渐变生成顶部的阴影，但是生成的阴影出现的时机和我们期望的相反*/ background: radial-gradient(at top,rgba(0,0,0,.2), transparent 70%) no-repeat; background-size: 100% 15px; background-attachment: local;&#125;----------进化----------.ul2 &#123; /*通过线性渐变生成白色矩形来遮挡阴影*/ background: linear-gradient(white,white), radial-gradient(at top,rgba(0,0,0,.2), transparent 70%); background-repeat: no-repeat; background-size: 100% 15px; background-attachment: local,scroll;&#125;----------进化----------.ul3 &#123; /*生成底部的阴影和遮挡矩形，并且把白色矩形的渐变颜色改成linear-gradient(white,hsla(0,0%,100%,0))，这样可以让阴影的显现变得平滑*/ background: linear-gradient(white 15px, hsla(0,0%,100%,0)) 0 0 / 100% 50px, radial-gradient(at top, rgba(0,0,0,.2), transparent 70%) 0 0 / 100% 15px, linear-gradient(to top, white 15px, hsla(0,0%,100%,0)) bottom / 100% 50px, radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom / 100% 15px; background-repeat: no-repeat; background-attachment: local, scroll, local, scroll;&#125; 交互式的图片对比控件CSS resize方案resize属性控制元素是否能被用户缩放，有none、both、horizontal、vertical、block、inline这几个属性。其中：none表示元素不能被用户缩放。both表示允许用户在水平和垂直方向上调整元素的大小。horizontal表示允许用户在水平方向上调整元素的大小。vertical表示允许用户在垂直方向上调整元素的大小。如果一个block元素的 overflow 属性被设置成了visible，那么resize属性对该元素无效。 12345&lt;body&gt;&lt;div class="image-slider"&gt; &lt;div&gt;&lt;img src="http://csssecrets.io/images/adamcatlace-before.jpg" alt="Before" /&gt;&lt;/div&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" /&gt;&lt;/div&gt; 12345678910111213141516.image-slider1 &#123; position:relative; display: inline-block;&#125;.image-slider1 &gt; div &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 50%;/*设置初识宽度*/ overflow: hidden;/*剪裁图片*/ resize: horizontal;/*动态改变宽度*/&#125;.image-slider1 img &#123; display: block;&#125; 可以看到已经可以随心所欲的改变图片的宽度了，但是调节手柄不容易辨认，而且&lt;div&gt;的宽度拉伸超过了图片宽度的（可以注意动图最后右下角调节手柄的位置）。 超出图片宽度只要这样设置max-width: 100%。 调节手柄可以通过伪元素覆盖在调节手柄之上： 123456789101112.image-slider2 &gt; div:before &#123; content: ''; position: absolute; right: 0; bottom: 0; width: 12px; height: 12px; padding: 5px; background: linear-gradient(-45deg, white 50%, transparent 0); background-clip: content-box; cursor: ew-resize; -webkit-filter: drop-shadow(0 0 2px black); filter: drop-shadow(0 0 2px black);&#125; cursor: ew-resize;表示鼠标变成 这个方案对键盘来说是不可访问的。 范围输入控件方案将原生的滑块控件覆盖在图片上，通过js脚本将滑块移动和&lt;div&gt;的宽度联系起来，实现用控件控制的效果。 1234&lt;div class="image-slider3"&gt; &lt;img src="http://csssecrets.io/images/adamcatlace-before.jpg" alt="Before" /&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" alt="After" /&gt;&lt;/div&gt; 12345678910111213141516171819202122$$('.image-slider3').forEach(function (slider) &#123; //创建附加的div元素，并用它包裹住第一个图片元素 var div = document.createElement("div"); var img = slider.querySelector("img"); slider.insertBefore(div,img); div.appendChild(img); //创建滑块 var range = document.createElement("input"); range.type = 'range'; //滑块和div宽度绑定 range.oninput = function () &#123; div.style.width = this.value + "%"; &#125;; slider.appendChild(range);&#125;);function $$(selector, context) &#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 1234567891011121314151617181920212223.image-slider3 &#123; position:relative; display: inline-block;&#125;.image-slider3 &gt; div &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 50%;/*设置初识宽度*/ overflow: hidden;/*剪裁图片*/&#125;.image-slider3 img &#123; display: block; user-select: none;&#125;.image-slider3 input&#123; position: absolute; left: 0; bottom: 10px; width: 100%; margin: 0;&#125; 可以通过混合模式、滤镜和变形来优化控件： 12345678910111213.image-slider3 input&#123; position: absolute; left: 0; bottom: 10px; /*width: 100%;*/ margin: 0; width: 50%; filter: contrast(.5); mix-blend-mode: luminosity; transform: scale(2); transform-origin: left bottom;&#125; 结构与布局自适应内部元素width和height属性有一个新的关键字： min-content，这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或者具有固定宽度的盒元素）： 12345678&lt;p&gt;Let’s assume we have some text here. Bacon ipsum dolor sit amet turkey veniam shankle, culpa short ribs kevin t-bone occaecat.&lt;/p&gt;&lt;figure&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" /&gt; &lt;figcaption&gt; The great Sir Adam Catlace was named after Countess Ada Lovelace, the first programmer ever. &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;We also have some more text here. Et laborum venison nostrud, ut veniam sint kielbasa ullamco pancetta.&lt;/p&gt; 1234567891011121314figure &#123; max-width: 300px;/*为了向下兼容*/ max-width: min-content; margin: auto;&#125;figure &gt; img &#123; max-width: inherit &#125;/* Basic styling */figure &#123; padding: 10px; border: 1px solid silver;&#125; width和height属性其他的值还有max-content，它的行为类似于display: inline-block；fit-content的行为与浮动元素是相同的（和min-content效果通常一致，但也有例外） 精确控制表格列宽table-layout属性有auto和fixed两个值： auto的行为模式被称为自动表格布局算法，会根据内容自动调整表格宽度。 fixed表示表和列宽度由表和元素的宽度或第一行单元格的宽度来设置。后续行中的单元格不会影响列宽度。 table-layout: fixed这种固定表格布局算法不仅更容易预测、便于使用，同时也明显更快。 因为表格的内容并不会影响单元格的宽度，所以在页面的下载过程中，表格 不需要频繁重绘。 在使用时，我们只需要对 &lt;table&gt;元素或其他具有display: table样 式的元素应用这个属性即可。 请注意， 为了确保这个技巧奏效， 需要为这 些表格元素指定一个宽度（哪怕是 100% ）。 同样， 为了让text-overflow: ellipsis发挥作用， 我们还需要为那一列指定宽度。 1234table&#123; table-layout: fixed; width: 100%;&#125; 根据兄弟元素的数量来设置样式:only-child可以用来定义只有一个子元素时的样式。等效于:first-child:last-child。:last-child相当于:nth-last-child(1)。 li:first-child:nth-last-child(4)表示一个正好有四个列表项的列表中的第一个列表项。如下图所示： 通过:first-child:nth-last-child()找到特定数量列表中的第一项，然后可以使用兄弟选择器~来命中它之后的所有兄弟元素，这样就达到了选定特定数量列表项中每个元素的目的： 1li:first-child:nth-last-child ( 4 ), li:first-child:nth-last-child ( 4 ) ~ li &#123; /* 当列表正好包含四项时，命中所有列表项 */ &#125; 根据兄弟元素的数量范围来匹配元素:nth-child()中的参数不仅可以是数字还可以是an+b这样的表达式。如果参数是n+b这样的表达式，不论n取何值，这个表达式无法产生小于b的值，因此n+b这个表达式可以选择从第b个元素开始的所有子元素。 同样n+b这个表达式也可以用在:nth-last-child ()上，这样可以在列表总数是b或者更多时选中所有列表项： 1li:first-child:nth-last-child ( n + 4 ), li:first-child:nth-last-child ( n + 4 ) ~ li &#123; /* 当列表至少包含四项时，命中所有列表项 */ &#125; -n+b表达式可以选中开头的b个元素。这样可以在列表总数是b或者更少时选中所有列表项： 1li:first-child:nth-last-child ( -n + 4 ), li:first-child:nth-last-child ( -n + 4 ) ~ li &#123; /* 当列表最多包含四项时，命中所有列表项 */ &#125; 这两个技巧还可以组合起来使用，比如在列表包含2~4个列表项时命中所有的列表项： 1li:first-child:nth-last-child ( n + 2 ) :nth-last-child ( -n + 4 ), li:first-child:nth-last-child ( n + 2 ) :nth-last-child ( -n + 4 ) ~ li &#123; /* 当列表包含2～4项时，命中所有列表项 */ &#125; 满幅的背景，定宽的内容calc()函数允许在css中直接进行简单的算式来指定属性的值。 别忘了在calc()函数中用 空白符把-和+隔起来，否则会 产生解析错误！这个看似怪异的规则是为了向前兼容，因为在未来，calc()可能会允许使用标识符， 而这些标识符本身可能会包含连字符，容易与减号混淆。 如果内容居中，左右外边距实际上都等于视口宽度的一半减去内容宽度的一半，而且使用calc()函数计算出的值可以用在任何一个接受长度值的属性上，所以可以这样写： 12345678910111213141516171819202122232425262728293031323334&lt;footer&gt; &lt;div class="wrapper"&gt; &lt;!--内容--&gt; &lt;/div&gt;&lt;/footer&gt; footer &#123; background: #333;&#125;.wrapper &#123; max-width:900px; margin:1em auto;&#125;-------升级-------&lt;footer&gt; &lt;!--内容--&gt;&lt;/footer&gt;footer &#123; max-width: 900px;/*这一行声明注释掉没影响，因为当内边距是 50% - 450px 时，只可能给内容留出 900px （2× 450px ）的可用空 间。 只有把 width 显式地设置为 900px 之外（或大或小）的其他值， 我们 才有可能看出区别。由于我们想要得到的内容宽度本来就是 900px ，这一行 声明其实就是冗余的，我们可以把它去掉*/ padding: 1em calc(50% - 450px); background: #333;&#125;-------升级-------&lt;footer&gt; &lt;!--内容--&gt;&lt;/footer&gt;footer &#123; padding: 1em; /*向后兼容，避免浏览器不支持calc()函数*/ padding: 1em calc(50% - 450px); background: #333;&#125; 垂直居中基于绝对定位的解决方案先把这个元素的左上角放置在视 口（或最近的、具有定位属性的祖先元素）的正中心，然后再利用负外边距 把它向左、向上移动（移动距离相当于它自身宽高的一半），从而把元素的 正中心放置在视口的正中心。借助calc()函数可以简化代码： 1234567891011121314151617.main1 &#123; position: absolute; top: 50%; left: 50%; margin-top: -5em; /*6/2=3*/ margin-left: -9em; /*18/2=9*/ width: 18em; height: 10em;&#125;-------升级-------.main1 &#123; position: absolute; left: calc(50% - 9em); top: calc(50% - 5em); width: 18em; height: 10em;&#125; 当我们在 translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度 为基准进行换算和移动的，而这正是我们所需要的。接下来，只要换用基于 百分比的 CSS 变形来对元素进行偏移， 就不需要在偏移量中把元素的尺寸 写死了。 123456.main1 &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; translate()用来移动元素在平面上的位置。这种变换的特点是一个向量，其坐标定义多少，它在每个方向移动多少。 这个方案有以下缺点： 需要绝对定位，对整个布局的影响太过强烈 如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视 口裁切掉 在某些浏览器中，这个方法可能会导致元素的显示有一些模糊，因 为元素可能被放置在半个像素上。 这个问题可以用 transform- style: preserve-3d 来修复，不过很难保证它在未来不会出问题。 基于视口单位的解决方案原理和上面的方案一样，不过通过margin属性的百分比值来控制元素左上角位于容器的中心，然后再用translate()技巧来把元素以其自身高度宽高的一半为距离进行移动。 margin的百分比是以父元素的宽度作为解析基准的。 css3定义了一套与视口相关的长度单位： vw是与视口宽度相关的。1vw实际上表示视口宽度的1%，而不是100%。 1vh表示视口高度的1%。 当视口宽度小于高度时，1vmin等于1vw，否则等于1vh。 当视口宽度大于高度时，1vmax等于1vw，否则等于1vh。 123456.main2 &#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translate(-50%,-50%);&#125; 这个方案只适合在视口中居中的场景。 基于Flexbox的解决方案先给这个待居中元素的父元素设置display: flex（在这个例子中是&lt;body&gt;元素），再给这个元素自身设置margin: auto（在这个例子中是&lt;main&gt;元素）： 123456789body&#123; display: flex; min-height: 100vh; margin: 0;&#125;main &#123; margin: auto;&#125; 当我们使用 Flexbox 时，margin: auto不仅在水平方向上将元 素居中，垂直方向上也是如此。我们甚至不需要指定任何宽度（如果需要的话，也是可以指定的）：这个居中元素分配到的宽度等于max- content。 Flexbox 的另一个好处在于，它还可以将匿名容器（即没有被标签包裹 的文本节点）垂直居中。比如： 1&lt;main&gt;Center me,please!&lt;/main&gt; 1234567main &#123; display : flex; align-items : center; justify-content : center; width : 18em; height : 10em; &#125; justify-content用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。align-items属性属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。这意味着它像justify-content一样，但是在垂直方向。 align-self属性规定弹性盒子元素内被选中项目的对齐方式。直接用align-self: center就可以实现垂直居中。 紧贴底部的页脚固定高度的解决方案1234567891011&lt;header&gt; &lt;h1&gt;Site name&lt;/h1&gt;&lt;/header&gt;&lt;main&gt; &lt;input type="checkbox" id="contents" /&gt;&lt;label for="contents"&gt;Toggle contents&lt;/label&gt; &lt;p&gt;Bacon ipsum dolor ....&lt;/p&gt;&lt;/main&gt;&lt;footer&gt; &lt;p&gt;© 2015 No rights reserved.&lt;/p&gt; &lt;p&gt;Made with ♥ by an anonymous pastafarian.&lt;/p&gt;&lt;/footer&gt; 计算出页脚所占高度和大标题与最顶部的距离，然后让内容的最小高度为（视口高度-页脚所占高度-大标题与最顶部的距离）。 12345main &#123; min-height : calc(100vh - 2.5em - 7em); /* 避免内边距或边框搞乱高度的计算： */ box-sizing : border-box; &#125; 或者直接把&lt;header&gt;和&lt;main&gt;元素包在一个容器里面，这样只要计算页脚高度： 123#wrapper &#123; min-height: calc(100vh - 7em); &#125; 这套方案不仅要求我们确保页脚内的文本永远不会折行， 而且每当我们改变页脚的尺寸时，都需要跟着调整min-height值。 更灵活的解决方案对父元素设置display: ﬂex，当父元素获得这个属性之后，就可以对其 子元素触发“伸缩盒布局模型”。 我们还需要把ﬂex-ﬂow设置为column， 否则子元素会被水平排放在一行上。 要把父元素的min-height属性指 定为100vh，这样它就至少会占据整个视口的高度。不过此时各个子元素的高度仍然是以各自的内容为准的（按照 CSS 规 范的说法，它们的高度仍然由内部因素来决定）。只要给&lt;main&gt;这个容器的ﬂex属性指定一个大于 0 的值（比如 1 即可），内容区块的高度应该可以自动伸展并占满所有的可用空间。 12345678body &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;main &#123; flex: 1;&#125; flex属 性 实 际 上 是flex-grow、flex-shrink和flex-basis的 简 写 语 法。 任 何 元素只要设置了一个大于 0 的flex值， 就将获得可伸缩的特 性；flex的值负责控制多个可伸 缩元素之间的尺寸分配比例。 举例来说，在上面的这个例子中， 如 果&lt;main&gt;是flex: 2而 &lt;footer&gt;是flex: 1，那么内容 区块的高度将是页脚高度的两倍。如果把它们的值从 2 和 1 改为 4和 2 ， 结果也是一样的， 因为真 正起作用的是它们的数值比例。 过渡与动画缓动效果弹跳动画所有过渡和动画都是跟一条曲线（缓动曲线）有关的，这条曲线指定了动画过程在整段时间中是如何推进的。如果不指定调速函数， 它就会得到一个默认值。这个默认的缓动效果并不是我们想像中的匀速效果，而是如下图所示的效果： 不 论 是在animation / transition简 写 属 性 中，还 是在animation- timing-function / transition-timing-function展开式属性中，ease都是是 默认值缓动曲线如上图。除此以外，还有四种内置的缓动曲线，你可以用它们来改变动画的推进方式： ease-out是ease-in是反向版本。 这一对组合正好是实现回弹效果所需要的：每当小球的运动方向相反时，我们希望调速函数也是相反的。 因此，我们可以在animation属性中指定一个通用的调速函数， 然后在关键帧中按需覆盖它。我们希望下落方向上的调速函数是加速的（ease- out），而弹起方向上是减速的（ease-in）： 12345678910111213141516@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateY(400px); animation-timing-function: ease-out; &#125; 70% &#123; transform: translateY(300px); &#125; 90% &#123; transform: translateY(360px); &#125;&#125;.ball &#123; width: 0; height: 0; padding: 1.5em; border-radius: 50%; margin: auto; background: red radial-gradient(at 30% 30%, #fdd, red); animation: bounce 2s ease-in ;&#125; 所有这五种曲线都是通过（三次）贝塞尔曲线来指定的。这种曲线 由一定数量的路径片断所组成，各个片断的每一端都可以由一个手柄来控制曲率（这些手柄通常也被称作控制锚点）。一条复杂的曲线可能包含很多个 片断，这些片断的端点彼此相连构成了整条曲线。 作为对上述五种预定义曲线的补充，CSS 提供了cubic-bezier()函数，允许我们指定自定义的调速函数。它接受四个参数，分别代表两个控 制锚点的坐标值， 我们通过这两个控制锚点来指定想要的贝塞尔曲线。 语法形式是这样的：cubic-bezier(x1, y1, x2, y2)，其中( x 1 , y 1 )表示第一 个控制锚点的坐标， 而( x 2 , y 2 )是第二个。 曲线片断的两个端点分别固定在(0,0)和(1,1)，前者是整个过渡的起点（时间进度为零，动画进度为零）， 后者是终点（时间进度为 100%，动画进度为 100%）。两个控制锚点 的 x 值都被限制在 [0, 1] 区间内（即我们无法把手柄在水平方向上移出这个图形范围）。只要把控制锚点的水平坐标和垂直坐标互换， 就可以得到任何调速函数的反向版本。 下面的ease 等 同 于cubic-bezier(.25,.1,.25,1)，它的反向版本就是cubic- bezier(.1,.25,1,.25)： 12345678910111213141516@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateY(400px); animation-timing-function: ease; &#125; 70% &#123; transform: translateY(300px); &#125; 90% &#123; transform: translateY(360px); &#125;&#125;.ball &#123; width: 0; height: 0; padding: 1.5em; border-radius: 50%; margin: auto; background: red radial-gradient(at 30% 30%, #fdd, red); animation: bounce 2s cubic-bezier(.1,.25,1,.25) forwards;&#125; 借助一款cubic-bezier.com的图形化工具，可以反复调整贝塞尔曲线，从而优化动画效果。 弹性过渡1234567&lt;label&gt; Your username: &lt;input value="leaverou"&gt;&lt;/input&gt; &lt;span class="callout"&gt; Only letters, numbers, underscores (_) and hyphens (-) allowed! &lt;/span&gt;&lt;/label&gt; 123456789101112131415161718192021222324input:not(:focus) + .callout &#123; transform: scale(0);&#125;.callout &#123; transition: .5s transform; transform-origin: 1.4em -.4em;&#125;---------升级到弹性过渡---------@keyframes elastic-grow &#123; from &#123;transform: scale(0)&#125; 70% &#123; transform: scale(1.1); animation-timing-function: cubic-bezier(.1,.25,1,.25); &#125;&#125;input:not(:focus) + .callout:not(:hover) &#123; transform: scale(0);&#125;input:focus + .callout &#123; animation: elastic-grow .5s;&#125; 上面的弹性过渡特效使用了动画，但是有点大材小用，还可以只用cubic-bezier()函数来实现。 曲线的控制锚点可以在垂直方向上突破 0~1 区间，从而让过渡达到低于0或高于100%的程度。它表示如果我们要从 scale(0) 的变形程度过渡到 scale(1) ，就还将经历一个比最终值更大的状 态，比如 scale(1.1) （或者更甚，这取决于调速函数有多陡）。 从上图可以看出，现在这个过渡会在总时长 50% 的时间点达到100%的变形程度。 不过， 过渡过程并不会停在那里；它会在超越最终值之后继 续推进， 在 70% 的时间点达到 110% 的变形程度峰值， 然后在最后可用的 30% 时间里过渡回它的最终值。 可见， 整个过渡的推进过程非常接近前面 的动画方案，但它只需要一行代码就可以实现整个效果： 1234567input:not(:focus) + .callout &#123; transform: scale(0);&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5); transform-origin: 1.4em -.4em;&#125; 当我们把焦点从输入框中切出去的时候，所触发 的过渡会以scale(1)作为起始值， 并以scale(0)作为最终值。 由于此时 是相同的调速函数在起作用，这个过渡仍然会在 350ms 后到达110%的变形 程度。只不过在这里，110% 变形程度的解析结果并不是 scale(1.1)，而是scale(-0.1)，这样就会出现下面的效果： 修复这个问题不过是多加一行代码而已。假设我们 只想给提示框的关闭过程指定普通的 ease 调速函数，那么可以在定义关闭 状态的 CSS 规则中把当前的调速函数覆盖掉： 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition-timing-function: ease;&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5); transform-origin: 1.4em -.4em;&#125; 但是此时提示框的关闭动作明显要迟钝一 些。这是因为在提示框的展开过程中，当时间 进行到 50% 时（即 250ms 之后）， 它就已经达到 100% 的完整尺寸了。 但 在收缩的过程中，从 0 到 100% 的变化会花费我们为过渡所指定的所有时间 （500ms），因此感觉上会慢一半。要修复这个问题，只需同时覆盖过渡的持续时间即可，我们既可以单独 覆盖transition-duration这一个属性，也可以用transition这个简写属 性来覆盖所有的值。如果选择后者的话，就不需要显式指定 ease 了： 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition: .25s;&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5); transform-origin: 1.4em -.4em;&#125; 在对颜色属性的弹性过渡中，由于RGB三个通道的值是独立进行插值运算的， 因此这个过渡过程中可能会产生其他颜色，为避免不小心对颜色设置了弹性过渡， 可以尝试 把过渡的作用范围 限制在某几种特定的属性上。当我们在transition简写属性中不指定任何属性时，transition-property就会得 到它的初始值：all。这意味着只要是可以过渡的属性，都会参与过渡。因 此，如果我们以后在提示框打开状态的样式规则中增加一行 background声明，那么弹性过渡也会作用在这个属性上。 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition: .25s transform;&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5) transform; transform-origin: 1.4em -.4em;&#125; 可以通过transition-delay属 性把各个属性的过渡过程排成列队， 这个 属性的值实际上就是transition简写属性中的第二个时间值。 举例 来 说， 如 果width和height都需要过渡效果， 而且你希望高 度先变化然后宽度再变化， 就可以这样 写：transition: .5s height, .8s .5s width;（ 也 就 是 说， 让 width过渡的延时正好等于height过渡的持续时间）。 逐帧动画1&lt;div class="loader"&gt;Loading…&lt;/div&gt; 12345678910@keyframes loader &#123; to &#123; background-position: -800px 0; &#125;&#125;.loader &#123; width: 100px; height: 100px; animation: loader 1s infinite linear; text-indent: 999px; overflow: hidden; /* Hide text */ background: url(http://dabblet.com/img/loader.png) 0 0;&#125; 这种通过应用各种不同的background-position值的方法会显示帧与帧之间的动画： 这时候可以采用steps()调速函数，而不是基于贝塞尔曲线的调速函数。 所有基于贝塞尔曲线的调速函数都会在关键帧之间进行插值运算，从而产生平滑的过渡效果。在通常情况下，平滑的过渡是我们使用 CSS 过渡和动画的原因。 但在眼前的场景下， 这种平滑特性恰恰毁 掉了我们想实现的逐帧动画效果。 与贝塞尔曲线调速函数迥然不同的是，steps()会根据你指定的步进数量（在这个例子中就是动画的帧数），把整个动画切分为多帧，而且整个动画会在帧与帧之间硬切，不会做任何插值处理。 123456.loader &#123; width: 100px; height: 100px; text-indent: 999px; overflow: hidden; /* Hide text */ background: url(http://dabblet.com/img/loader.png) 0 0; animation: loader 1s infinite steps(8);&#125; steps()还接受可选的第二个参数， 其值可以是start或end（默认值）。这个参数用于指定动画在每个循环周期的什么位置发生帧的切换动作，但实际上这个参数用得并不 多。 如果我们只需要一个单步切换效果， 还可以使用step-start和step- end这样的简写属性，它们分别等同于steps(1, start)和steps(1, end)。 对steps(1, start)和steps(1, end)的理解可以参照闪烁效果中的例子 闪烁效果1234567891011@keyframes blink-1 &#123; to &#123; color: transparent &#125; &#125;.blink-smooth-1 &#123; animation: 1s blink-1 3;&#125;----------升级----------@keyframes blink-2 &#123; 50% &#123; color: transparent &#125; &#125;.blink-smooth-2 &#123; animation: 1s blink-1 3;&#125; 下图中，.blink-smooth-1对应第二个闪烁图，.blink-smooth-2对应第一个闪烁图。 通过修改关键帧，让状态切换发生在每个循环周期的中间。 animation-direction的唯一作用就是反转每一个循环周期（reverse），或第偶数个循环周期（alternate），或第奇数个循环周期（alternate-reverse）。它的伟大之处在于，它会同时反转调整函数 ，从而产生更加逼真的动画效果。 12345@keyframes blink-2 &#123; to &#123; color: transparent &#125; &#125;.blink-smooth-2 &#123; animation: .5s blink-1 6 alternate;&#125; 必须把动画循环的次数翻倍（而不是像前面的方法那样把循环周期的时间长度翻倍），因为现在一次淡入淡出的过程是由两个循环周 期组成的。基于同样的原因，我们也要把animation-duration减半。 如果用steps()函数来实现: 12345@keyframes blink &#123; to &#123; color: transparent &#125; .blink &#123; animation: 1s blink 3 steps(1);&#125; 此时文字不会闪烁，因为steps(1)本质上等同于steps(1, end)， 它表示当前颜色与transparent之间的过渡会在一次步进中完成，于是颜色值的切换只会发生在动画周期的末尾。因此，我们会看到起始值贯穿于整个动画周期，而终止值只在 动画结尾的无限短的时间点处出现。如果我们改用steps(1, start)，结果 就完全相反了：颜色值的切换会发生在动画周期最开始，于是我们始终只能 看到纯透明的文字，没有任何动画或闪烁效果。 我们接下来可以换用steps(2)来碰碰运气，两种步进方式（start或end）都可以试一下。现在我们终于可以看到闪烁效果了， 但这个闪烁效果要么是由半透明切到纯透明，要么是由半透明切到实色，原因同上。由于我们无法通过配置steps()来让这个切换动作发生在动画周期 的中间点（只能发生在起点或终点），唯一的解决方案是调整动画的关键帧， 让切换动作发生在 50% 处，就像我们在本节刚开始所做的那样： 1234567891011@keyframes blink-1 &#123; to &#123; color: transparent &#125; .blink1 &#123; animation: 1s blink-1 3 steps(2);&#125;----------升级----------@keyframes blink-2 &#123; 50% &#123; color: transparent &#125; .blink2 &#123; animation: 1s blink-2 3 steps(1);&#125; 上图第一个对应的是blink-1的效果，第二个对应的是blink-2的效果。 打字动画核心思路就是让容器的宽度成为动画的主体：把所有文本包裹在这个容 器中，然后让它的宽度从 0 开始以步进动画的方式、一个字一个字地扩张到 它应有的宽度。这个方法并不适用于多行文本。 动画的持续时间越长，动画效果越差：持续时间较短的动画会让界面显得更加精致。反之，动画的持续时间越长，越容易让用户感到厌烦。因此，即使这个 技巧可以用在大段文本身上，也不一定是个好主意。 需要用white-space: nowrap;来阻止文本折行，否则文本的行数会随着宽度的扩张不断变化。 用overﬂow: hidden;， 裁切超出宽度的文本。 用steps()来达到动画逐字呈现的效果，而不是平滑连贯的。 1&lt;h1&gt;CSS is awesome!&lt;/h1&gt; 1234567891011@keyframes typing &#123; from &#123; width: 0 &#125;&#125;h1 &#123; font: bold 200% Consolas, Monaco, monospace; width: 7.7em; white-space: nowrap; overﬂow: hidden; animation: typing 8s steps(15),&#125; 此时的效果如下： 用em指定宽度显然效果不好，可以用ch来解决这个问题。 ch表示“0” 字形的宽度，是CSS值与单位（第三版）规范引入的一个新单位。在绝大多数场景下， 我们并不关心0这个字符显示出来到底有多宽。但对等宽字体来说，这是个 例外。在等宽字体中，“0”字形的宽度和其他所有字形的宽度是一样的。因 此，如果我们用 ch 单位来表达这个标题的宽度，那取值实际上就是字符的数量。 1234567891011@keyframes typing &#123; from &#123; width: 0 &#125;&#125;h1 &#123; font: bold 200% Consolas, Monaco, monospace; width: 15ch; white-space: nowrap; overﬂow: hidden; animation: typing 8s steps(15),&#125; 在这个例子中，可以用一个伪元素来生成光标，并通过opacity属性来实现闪烁效果；我们也可以用右边框来模拟 光标效果，这样就可以把有限的伪元素资源节省下来留作他用。光标的闪烁动画是需要无限循环的（即使所有的文字都显示完整之后仍然如此）， 因此需要用到 inﬁnite 关键字。 1234567891011121314151617@keyframes typing &#123; from &#123; width: 0 &#125;&#125;@keyframes caret &#123; 50% &#123; border-right-color: transparent; &#125;&#125;h1 &#123; font: bold 200% Consolas, Monaco, monospace; width: 15ch; white-space: nowrap; overflow: hidden; border-right: .05em solid; animation: typing 8s steps(15), caret 1s steps(1) infinite;&#125; 由于需要根据每 个标题的字数来给它们分别指定不同的宽度样式， 而且还需要在每次改变标题内容时同步更新这些宽度样式，所有可以用一段JavaScript代码来实现： 123456789function $$(expr, con) &#123; return [].slice.call((con || document).querySelectorAll(expr));&#125;$$('h1').forEach(function (h1) &#123; var len = h1.textContent.length, s = h1.style; s.width = len + 'ch'; s.animationTimingFunction = "steps(" + len + "),steps(1)";&#125;); 状态平滑的动画让背景的background-position属性值从原本的0 0一直变化到100% 0时，我们就会看到这张图片从左侧一直滚动到右侧的完整过程。 12345678910@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url('http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg'); background-size: auto 100%; animation: panoramic 10s linear infinite alternate;&#125; 接下来实现当用户鼠标悬停时才开始播放的效果： 12345678910111213@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url('http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg'); background-size: auto 100%;&#125;.panoramic:hover, .panoramic:focus &#123; animation: panoramic 10s linear infinite alternate;&#125; 这时候当我们把鼠标移出图片时，它就会生硬地跳回最左侧。为了修复这个问题，我们需要换个角度来思考：我们在这里到底想要实 现什么样的结果。我们需要的并不是在:hover时应用一个动画，因为这意 味着动画被中断时的状态是无处保存的。我们需要的是当失去 :hover 状态 时暂停动画。有一个属性正好是为暂停动画的需求专门设计的：animation-play-state。 123456789101112131415@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url('http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg'); background-size: auto 100%; animation: panoramic 10s linear infinite alternate; animation-play-state: paused;&#125;.panoramic:hover, .panoramic:focus &#123; animation-play-state: running;&#125; 沿环形路径平移的动画123&lt;div class="path"&gt; &lt;img src="http://lea.verou.me/book/adamcatlace.jpg" /&gt;&lt;/div&gt; 1234567@keyframes spin &#123; to &#123; transform: rotate(1turn); &#125;&#125;.avatar &#123; animation: spin 3s infinite linear; transform-origin: 50% 150px; /*150px = 路径的半径*/&#125; 这段代码不仅让头像沿着环形路径转动，同时还会让头像自身旋转。如果有文字的话，那文字也会是颠倒的，这在可读性方面可是一个严重的问题。因此我们希望它只是沿着环形进行移动，同时保持自己本来的朝向。 需要两个元素的解决方案最主要的思路 与“平行四边形” 或者“菱形图片” 中提到的“嵌套的两层变形会相互抵 消”如出一辙：用内层的变形来抵消外层的变形效果。这时需要给图片套上额外的div： 12345&lt;div class="path"&gt; &lt;div class="avatar"&gt; &lt;img class="avatar" src="http://lea.verou.me/book/adamcatlace.jpg" /&gt; &lt;/div&gt;&lt;/div&gt; 然后只需把头像的动画设置为相反的角度范围（ 360-0deg ） 即可： 123456789101112131415@keyframes spin &#123; to &#123; transform : rotate(1turn); &#125; &#125; @keyframes spin-reverse &#123; from &#123; transform : rotate(1turn); &#125; &#125;.avatar &#123; animation : spin 3s infinite linear; transform-origin : 50% 150px; /* 150px = 路径的半径 */ &#125;.avatar &gt; img &#123; animation : spin-reverse 3s infinite linear;&#125; 上面代码中animation的参数重复了两次，可以让内层动画从父元素那里继承所有的动画属性，然后把动画名覆盖掉。 如果只是为了反转第一套动画，就又建了一套新动画， 有点浪费。可以用在“闪烁效果”中所提到的animation-direction属性的reverse值得到原始动画的反向版本。 12345678910111213@keyframes spin &#123; to &#123; transform : rotate(1turn); &#125; &#125;.avatar &#123; animation : spin 3s infinite linear; transform-origin : 50% 150px; /* 150px = 路径的半径 */ &#125;.avatar &gt; img &#123; animation : inherit; animation-direction: reverse;&#125; 单个元素的解决方案transform-origin只是一个语法糖而已。实际上你总是可以用translate()来代替它 每 个transform-origin都是可以被两个translate()模拟出来的。比如，下面两段代码实际上是等效的： 1234567transform : rotate(30deg); transform-origin : 200px 300px;transform : translate(200px, 300px) rotate(30deg) translate(-200px, -300px); transform-origin : 0 0; 这是因为，变形函数并不是彼此独立的。每个变形函数并不是只对这个元素进行变形， 而且会把整个元素的坐标系统进行变形， 从而影响所有后续的变形操作。这也说明了为什么变形函数的顺序是很重要的，变形属性中不同函数的顺序如果被打乱， 可能会产生完全不同的结果。 借助这个思路，基于同一个transform-origin来实现前面用到的两个旋转动画： 1234567891011121314151617181920212223242526272829303132333435@keyframes spin &#123; from &#123; transform : translate(50%, 150px) rotate(0turn) translate(-50%, -150px); &#125; to &#123; transform : translate(50%, 150px) rotate(1turn) translate(-50%, -150px); &#125;&#125;@keyframes spin-reverse &#123; from &#123; transform : translate(50%, 50%) rotate(1turn) translate(-50%, -50%); &#125; to &#123; transform : translate(50%, 50%) rotate(0turn) translate(-50%, -50%); &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125;.avatar &gt; img &#123; animation: inherit; animation-name: spin-reverse;&#125; 因为现在所有变形函数都是使用一个起点，可以把两套动画合成一套，这时候就不需要两层div来实现了： 12345678910111213141516171819202122@keyframes spin &#123; from &#123; transform : translate(50%, 150px) rotate(0turn) translate(-50%, -150px) translate(50%, 50%) rotate(1turn) translate(-50%, -50%); &#125; to &#123; transform : translate(50%, 150px) rotate(1turn) translate(-50%, -150px) translate(50%, 50%) rotate(0turn) translate(-50%, -50%);; &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125; 上面代码还可以把连续的translate()变形操作合并起来， translate(-50%, -150px)和 translate(50%, 50%)在水平方向上的位移可以抵消，相当于我们只在 Y 轴上做了两次位移操作translateY(-150px) translateY(50%)： 12345678910111213141516171819202122@keyframes spin &#123; from &#123; transform : translateY(150px) translateY(-50%) rotate(0turn) translateY(-150px) translateY(50%) rotate(1turn) &#125; to &#123; transform : translateY(150px) translateY(-50%);; rotate(1turn) translateY(-150px) translateY(50%) rotate(0turn) &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125; 如果把头像放在圆心并以此作为起点，就可以消除最开始的那两个位移操作了，而实际上这两个位移在本质上所做的就是把它放在圆心。 123456789101112131415161718@keyframes spin &#123; from &#123; transform : rotate(0turn) translateY(-150px) translateY(50%) rotate(1turn) &#125; to &#123; transform : rotate(1turn) translateY(-150px) translateY(50%) rotate(0turn) &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之动画]]></title>
      <url>%2F2017%2F03%2F30%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[Angular动画是基于标准的Web动画API(Web Animations API)构建的，它们在支持此API的浏览器中会用原生方式工作。 至于其它浏览器，就需要一个填充库(polyfill)了。你可以从这里获取web-animations.min.js，并把它加入你的页面中。 快速起步范例：在两个状态间转场引入与动画相关的函数： 1import &#123; Component,Input,trigger,state,style,transition,animate,group&#125; from '@angular/core'; 在Angular刚刚发布的4.0版本中，动画已经从@angular/core中拆分出来。 1234567891011121314animations: [ trigger('heroState', [ state('inactive', style(&#123; backgroundColor: '#eee', transform: 'scale(1)' &#125;)), state('active', style(&#123; backgroundColor: '#cfd8dc', transform: 'scale(1.1)' &#125;)), transition('inactive =&gt; active', animate('100ms ease-in')), transition('active =&gt; inactive', animate('100ms ease-out')) ])] 123456789template: ` &lt;ul&gt; &lt;li *ngFor="let hero of heroes" [@heroState]="hero.state" &lt;!--方括号内是trigger的名字，右边是state对应state的值。--&gt; (click)="hero.toggleState()"&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt;`, 定义的动画可以在模板中用[@triggerName]语法来把它附加到一个或多个元素上。然后把@triggerName属性(Attribute)的值设置成表达式hero.state。这个值应该或者是inactive或者是active。 状态与转场Angular动画=状态+状态之间的转场效果。 状态表现为上面代码中active和inactive这两种状态，它定义了每个状态的最终样式。一旦元素转场到那个状态，该样式就会被应用到此元素上，当它留在此状态时，这些样式也会一直保持着。 转场表现为上面代码中用transition()定义的转换时的动画，每个转场都会控制一条在一组样式和下一组样式之间切换的时间线。 如果多个转场都有同样的时间线配置，就可以把它们合并进同一个transition定义中： 12transition('inactive =&gt; active, active =&gt; inactive，focus =&gt; infocus', animate('100ms ease-out')) 如果要对同一个转场的两个方向都使用相同的时间线（就像前面的例子中那样），就可以使用&lt;=&gt;这种简写语法： 1transition('inactive &lt;=&gt; active', animate('100ms ease-out')) 有时希望一些样式只在动画期间生效，但在结束后并不保留它们。这时可以把这些样式内联在transition中进行定义。只有定义在state中的样式在转场结束后才能保留。 12345678910transition('inactive =&gt; active', [ style(&#123; //activey样式 backgroundColor: '#cfd8dc', transform: 'scale(1.3)' &#125;), animate('80ms ease-in', style(&#123; //inactive样式 backgroundColor: '#eee', transform: 'scale(1)' &#125;))]), *（通配符）状态*(通配符)状态匹配任何动画状态。当定义那些不需要管当前处于什么状态的样式及转场时，这很有用。比如： 当该元素的状态从active变成任何其它状态时，active =&gt; *转场都会生效。 当在任意两个状态之间切换时，* =&gt; *转场都会生效。 void状态void状态可以应用在任何动画中。它表示元素没有被附加到视图。这种情况可能是由于它尚未被添加进来或者已经被移除了。 void状态在定义“进场”和“离场”的动画时会非常有用。 比如当一个元素离开视图时，* =&gt; void转场就会生效，而不管它在离场以前是什么状态。 *通配符状态也能匹配void。 例子：进场与离场123456789101112animations: [ trigger('flyInOut', [ state('in', style(&#123;transform: 'translateX(0)'&#125;)), transition('void =&gt; *', [ style(&#123;transform: 'translateX(-100%)'&#125;),//void状态的style animate(100) ]), transition('* =&gt; void', [ animate(100, style(&#123;transform: 'translateX(100%)'&#125;))//void状态的style ]) ])] 没有一个单独的state(void)定义是因为希望在进场与离场时使用不一样的转换效果：元素从左侧进场，从右侧离开。 这两个动画有自己的名字：12transition(':enter', [ ... ]); // void =&gt; *transition(':leave', [ ... ]); // * =&gt; void 范例：从不同的状态下进场和离场 非激活英雄进场：void =&gt; inactive 激活英雄进场：void =&gt; active 非激活英雄离场：inactive =&gt; void 激活英雄离场：active =&gt; void 12345678910111213141516171819202122animations: [ trigger('heroState', [ state('inactive', style(&#123;transform: 'translateX(0) scale(1)'&#125;)), state('active', style(&#123;transform: 'translateX(0) scale(1.1)'&#125;)), transition('inactive =&gt; active', animate('100ms ease-in')), transition('active =&gt; inactive', animate('100ms ease-out')), transition('void =&gt; inactive', [ style(&#123;transform: 'translateX(-100%) scale(1)'&#125;), animate(100) ]), transition('inactive =&gt; void', [ animate(100, style(&#123;transform: 'translateX(100%) scale(1)'&#125;)) ]), transition('void =&gt; active', [ style(&#123;transform: 'translateX(0) scale(0)'&#125;), animate(200) ]), transition('active =&gt; void', [ animate(200, style(&#123;transform: 'translateX(0) scale(0)'&#125;)) ]) ])] 可动的属性与单位参见w3c的 “可动”属性列表。在style()中可以定义多个属性，实现同一时间段多个动画。 自动属性值计算*属性值会在运行期被计算出来，然后插入到这个动画中。适用于尺寸类样式在初始时未知的情况。 123456789animations: [ trigger('shrinkOut', [ state('in', style(&#123;height: '*'&#125;)),//取得该元素在离场前的高度 transition('* =&gt; void', [ //此处的*表示通配符状态 style(&#123;height: '*'&#125;), animate(250, style(&#123;height: 0&#125;)) //用动画转场到0高度 ]) ])] 动画时间线对每一个动画转场效果，有三种时间线属性可以调整：持续时间(duration)、延迟(delay)和缓动(easing)函数。它们被合并到了一个单独的转场时间线字符串。 持续时间持续时间控制动画从开始到结束要花多长时间。 单独一个数字，默认单位是ms。用字符串可以定义单位。 延迟延迟控制的是在动画已经触发但尚未真正开始转场之前要等待多久。它位于字符串中的持续时间后面。 缓动函数缓动函数用于控制动画在运行期间如何加速和减速（可以参考《css揭秘》第八章对缓动函数的讲解）。 例子123456789101112131415161718animations: [ trigger('flyInOut', [ state('in', style(&#123;opacity: 1, transform: 'translateX(0)'&#125;)), transition('void =&gt; *', [ style(&#123; opacity: 0, transform: 'translateX(-100%)' &#125;), animate('0.2s ease-in') ]), transition('* =&gt; void', [ animate('0.2s 10 ease-out', style(&#123; opacity: 0, transform: 'translateX(100%)' &#125;)) ]) ])] 基于关键帧的多阶段动画每个关键帧都可以被指定一个偏移量，用来定义该关键帧将被用在动画期间的哪个时间点。偏移量是一个介于0(表示动画起点)和1(表示动画终点)之间的相对值（百分比）。如果省略它们，偏移量会自动根据帧数平均分布出来。例如，三个未定义过偏移量的关键帧会分别获得偏移量：0、0.5和1。 12345678910111213141516171819animations: [ trigger('flyInOut', [ state('in', style(&#123;transform: 'translateX(0)'&#125;)), transition('void =&gt; *', [ animate(300, keyframes([ style(&#123;opacity: 0, transform: 'translateX(-100%)', offset: 0&#125;), style(&#123;opacity: 1, transform: 'translateX(15px)', offset: 0.3&#125;), style(&#123;opacity: 1, transform: 'translateX(0)', offset: 1.0&#125;) ])) ]), transition('* =&gt; void', [ animate(300, keyframes([ style(&#123;opacity: 1, transform: 'translateX(0)', offset: 0&#125;), style(&#123;opacity: 1, transform: 'translateX(-15px)', offset: 0.7&#125;), style(&#123;opacity: 0, transform: 'translateX(100%)', offset: 1.0&#125;) ])) ]) ])] 并行动画组group()可以为同时发生的几个动画配置不同的时间线。 下面代码中，同时在进场和离场时使用了group()，以便能让它们使用两种不同的时间线配置（一个动画组对元素的transform和width做动画，另一个组则对opacity做动画）。 它们被同时应用到同一个元素上，但又彼此独立运行： 12345678910111213141516171819202122232425262728animations: [ trigger('flyInOut', [ state('in', style(&#123;width: 120, transform: 'translateX(0)', opacity: 1&#125;)), transition('void =&gt; *', [ style(&#123;width: 10, transform: 'translateX(50px)', opacity: 0&#125;), group([ animate('0.3s 0.1s ease', style(&#123; transform: 'translateX(0)', width: 120 &#125;)), animate('0.3s ease', style(&#123; opacity: 1 &#125;)) ]) ]), transition('* =&gt; void', [ group([ animate('0.3s ease', style(&#123; transform: 'translateX(50px)', width: 10 &#125;)), animate('0.3s 0.2s ease', style(&#123; opacity: 0 &#125;)) ]) ]) ])] 动画回调当动画开始和结束时，会触发一个回调。 对于例子中的这个关键帧，有一个叫做@flyInOut的trigger。在那里我们可以挂钩到那些回调，比如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#123; Component, Input, trigger, state, style, animate, transition, keyframes, AnimationTransitionEvent&#125; from '@angular/core';import &#123; Heroes &#125; from './hero.service';@Component(&#123; moduleId: module.id, selector: 'hero-list-multistep', template: ` &lt;ul&gt; &lt;li *ngFor="let hero of heroes" (@flyInOut.start)="animationStarted($event)" (@flyInOut.done)="animationDone($event)" [@flyInOut]="'in'"&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; `, styleUrls: ['./hero-list.component.css'], animations: [ trigger('flyInOut', [ state('in', style(&#123;transform: 'translateX(0)'&#125;)), transition('void =&gt; *', [ animate(300, keyframes([ style(&#123;opacity: 0, transform: 'translateX(-100%)', offset: 0&#125;), style(&#123;opacity: 1, transform: 'translateX(15px)', offset: 0.3&#125;), style(&#123;opacity: 1, transform: 'translateX(0)', offset: 1.0&#125;) ])) ]), transition('* =&gt; void', [ animate(300, keyframes([ style(&#123;opacity: 1, transform: 'translateX(0)', offset: 0&#125;), style(&#123;opacity: 1, transform: 'translateX(-15px)', offset: 0.7&#125;), style(&#123;opacity: 0, transform: 'translateX(100%)', offset: 1.0&#125;) ])) ]) ]) ]&#125;)export class HeroListMultistepComponent &#123; @Input() heroes: Heroes; animationStarted(event: AnimationTransitionEvent) &#123; console.warn('Animation started: ', event); &#125; animationDone(event: AnimationTransitionEvent) &#123; console.warn('Animation done: ', event); &#125;&#125; 这些回调接收一个AnimationTransitionEvent参数，它包含一些有用的属性，例如fromState，toState和totalTime。 无论动画是否实际执行过，那些回调都会触发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端基础知识]]></title>
      <url>%2F2017%2F03%2F24%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[HTML初级 介绍一下你对浏览器内核的理解？ 简述一下你对HTML语义化的理解？ html5有哪些新特性、移除了那些元素？ 中级 页面导入样式时，使用link和@import有什么区别？ 为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？ 高级 如何实现浏览器内多个标签页之间的通信? 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ CSS初级 css的position属性有哪些取值，它们的行为是什么？ css哪些属性可以继承，哪些属性不可继承？ 清除浮动的几种方法？ css居中常用的方法（垂直、水平和同时水平垂直居中）。 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。 中级 px、em、rem的区别。 什么是CSS 预处理器 / 后处理器？ li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ ::after 和:after中双冒号和单冒号有什么区别，在css3中这两个属性有什么区别？ 什么叫优雅降级和渐进增强？ 响应式设计 (responsive design) 和自适应设计 (adaptive design)有什么 不同？ 解释下 CSS sprites，以及你要如何在页面或网站中使用它。 高级 用css实现多重边框，如下图所示： 用css实现自定义复选框，如下图所示: ​ JavaScript初级 DOM元素的property与attribute都可以翻译成属性，那两者有什么的区别？ 123456var a = false;var b = "";if (a == b)&#123; alert("a = b");&#125;输出结果是什么？为什么？ Javascript如何实现继承？ 谈谈This对象的理解。 什么是事件冒泡?事件冒泡有什么作用? 请解释事件委托（或者事件代理） 解释一下捕获型事件和冒泡型事件。 什么是闭包（closure），为什么要用它？ javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。 中级 Javascript作用链域? JavaScript原型，原型链 ? 有什么特点？ 123456789function add(a,b)&#123; alert(a+b); &#125;function sub(a,b) &#123; alert(a-b); &#125;add.call(sub,3,1);这个函数最后输出结果是什么？为什么？ 123456var v = "hello";(function()&#123; console.log(v); var v = "world";&#125;)();上面两段代码分别输出什么？为什么？ js延迟加载的方式有哪些？ 你知道有哪些性能优化的方法？ HTTP状态码有哪些，都是什么含义？ Ajax 是什么? 如何创建一个Ajax？ 使用 Ajax 都有哪些优劣？ AJAX注意点及适用和不适用场景 高级 关于Http 2.0 你知道多少？ 网站重构的理解？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 什么是指内存泄露，哪些操作会造成内存泄漏？ js如何操作获取和设置cookie 听说过PWA（Progressive Web App）吗？有哪些优点？ 答案HTML初级 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 1234567绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除;语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search;新的技术webworker, websocket, Geolocation; 移除的元素： 12纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes； 中级 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 浏览器从上到下依次解析html文档。将 css 文件放到头部， css 文件可以先加载。避免先加载 body 内容，导致页面一开始样式错乱，然后闪烁。将 javascript 文件放到底部是因为：若将 javascript 文件放到 head 里面，就意味着必须等到所有的 javascript 代码都被 下载、解析和执行完成 之后才开始呈现页面内容。这样就会造成呈现页面时出现明显的延迟，窗口一片空白。为避免这样的问题一般将全部 javascript 文件放到 body 元素中页面内容的后面。 一般希望DOM还没加载必须需要先加载的js会放置在&lt;head&gt;中,有些加了defer、async的&lt;script&gt;也会放在&lt;head&gt;中。 高级 WebSocket、SharedWorker；也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： 12cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： 123localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 CSS初级 (这个问题的答案很基础，但是这个问题可以问的很深入，可以筛选从初级到高级前端工程师，参考：https://github.com/wintercn/blog/issues/4) postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让top，right，bottom，left的值失效。 position：relative和absolute都可以用于定位，区别在于前者的div还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。定位原点relative是相对于它在正常流中的默认位置偏移，它原本占据的空间任然保留；absolute相对于第一个position属性值不为static的父类。所以设置了position：absolute，其父类的该属性值要注意，而且overflow：hidden也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。 fixed旧版本IE不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。常用于header，footer，或者一些固定的悬浮div，随滚动条滚动又稳定又流畅，比JS好多了。fixed可以有很多创造性的布局和作用，兼容性是问题。 可继承的样式：font-size font-family color, text-indent; 不可继承的样式：border padding margin width height ; 12345678910111，额外标签，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类#parent:after&#123; content:&quot;.&quot;; height:0; visibility:hidden; display:block; clear:both; &#125;3,浮动外部元素4,设置overflow为hidden或者auto 水平居中： 12内联元素水平居中：text-align: center;块级元素水平居中：margin: 0 auto;同时还要设置width 垂直居中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849内联元素:设置相等的上下padding，或者单行文本可以利用line-height和height相等来实现;块级元素： 1、若元素有固定高度 .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; /* 如果没有使用: border-box; 的盒子模型则需要设置这个 */ &#125; 2、如果不知道元素高度 .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; transform: translateY(-50%); &#125; 3、用flexbox &lt;main&gt; &lt;div&gt; I'm ok. &lt;/div&gt; &lt;/main&gt; body &#123; background: #f06d06; font-size: 80%; &#125; main &#123; background: white; height: 300px; width: 200px; padding: 20px; margin: 20px; display: flex; flex-direction: column; justify-content: center; resize: vertical; overflow: auto; &#125; main div &#123; background: black; color: white; padding: 20px; resize: vertical; overflow: auto; &#125; 同时水平和垂直居中： 1234567891011121314151617181920212223元素有固定高度和宽度：先绝对居中，然后上移和左移50%的宽度即可: .parent &#123; position: relative; &#125; .child &#123; width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; &#125;元素的高度和宽度未知或可变的：使用transofrm属性在两个方向都平移负50%: .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; ​ 盒模型包括margin、border、padding和content，W3C的标准是width和height就是content的宽和高，而IE默认盒模型的width和height是包含了border、padding和content的。 box-sizing：content-box（w3c标准盒模型），border-box（IE类盒模型）。 中级 Px是一个绝对字体大小，em则是基于基数（比如：1.5em）来计算出来的相对字体大小。这个基数是需要乘以当前对象从其父级遗传字体大小。rem是基于根节点（比如html）的字体大小进行计算的。 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 单冒号:用于伪类，双冒号::用于伪元素。 伪类是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息，伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息。 伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的，伪元素本质上是创建了一个有内容的虚拟容器。 可以同时使用多个伪类，但是一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 Responsive design (响应式设计)：建立一个网页，通过CSS Media Queries，Content－Based Breakpoint（基于内容的断点）等技术来改变网页的大小以适应不同分辨率的屏幕。 Adaptive design (自适应设计)：为不同类别的设备建立不同的网页，检测到设备分辨率大小后调用相应的网页。目前AWD网页主要针对这几种分辨率（320，480，760，960，1200，1600） CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的background-image，background- repeat，background-position的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 高级 123456789#div1 &#123; width: 100px; height: 60px; margin: 25px; background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6);&#125; 把&lt;label&gt;元素与复选框关联，让它起到触发开关的作用，为它添加生成性内 容（伪元素），并基于复选框的状态来为其设置样式。把真正 的复选框隐藏起来，再 把生成性内容美化一番，用来顶替原来的复选框。 123456789101112131415161718192021222324252627282930313233343536input[type="checkbox"] &#123; /*隐藏原始的复选框，不能使用display: none，这样会把它从tab键切换焦点的队列完全删除*/ position: absolute; clip: rect(0,0,0,0);&#125;/*设置紧邻input的label伪元素样式*/input[type="checkbox"] + label::before &#123; content: '\a0'; display: inline-block; vertical-align: .2em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background: silver; text-indent: .15em; line-height: .65;&#125;/*设置紧邻已经勾选的input的label伪元素的样式*/input[type="checkbox"]:checked + label::before &#123; content: '\2713'; background: yellowgreen;&#125;input[type="checkbox"]:focus + label::before &#123; box-shadow: 0 0 .1em .1em #58a;&#125;input[type="checkbox"]:disabled + label::before &#123; background: gray; box-shadow: none; color: #555; cursor: not-allowed;&#125; 12&lt;input type="checkbox" id="awesome" autofocus /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; JavaScript初级 property是DOM中的属性，是JavaScript里的对象；attribute是HTML标签上的特性，它的值只能够是字符串。attributes是属于property的一个子集，它保存了HTML标签上定义property。 输出true，JavaScript中，==并不表示严格相等，因为==认为空字符串与false的含义相同。要进行严格比较，就要使用另一种等号：===。这个全等操作符会执行严格的比较，不仅比较值，而且会比较变量的类型。 JavaScript无法实现接口继承，支持实现继承，而且继承主要是依靠原型链来实现的。主要继承方式有：原型式继承、寄生式继承、寄生组合式继承。 this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。 事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。 让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情，就像老板一下命令，各自员工做自己岗位上的工作去了。 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 12345678910111213141516171819202122232425闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。闭包的特性：1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125;&lt;/script&gt; use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。 单页应用是指在浏览器中运行的应用，它们在使用期间不会重新加载页面。像所有的应用一样，它旨在帮助用户完成任务，比如“编写文档”或者“管理Web服务器”。可以认为单页应用是一种从Web服务器加载的富客户端。 搜索引擎优化： 1234567891011121314151617181、注重TDK的写法既然页面单一，那么就更需要注重网站标题、关键词和描述的写法。标题上来说，要简单明确，包含主要关键词，一句话能概括全文;描述上来讲，一句话活一小段文字提炼出文章的精髓，内容比标题更加详细;关键词，用绝对的与内容相关的词语，多个关键词用逗号分开。2、外链锚文本的多样化在外链建设上，切忌内容单一，这样很容易造成网站的过度优化，而我们都知道，网站的过度优化对SEO而言是不利的。3、网站标签的运用合理的运用网站标签可以让搜索引擎更好的理解网站的层次内容，比如h标签，strong标签等等。4、符合国际标准这里所说的符合国际标准指的是告诉搜索引擎我的网站符合W3C标准，对任何浏览器都是兼容的。5、代码优化CSS和JS的优化，尽可能的使用外部导入，从而让网页代码更加简洁，能用CSS就尽量不用JS，毕竟JS对于搜索引擎而言并不友好。6、图片的优化这个属于老生常谈了，这里就不多说了。7、合理设置锚点有一些单页面为了展示很多产品特点，页面会拉的很长，不利于用户查看，用户体验并不好，如果在单页面网站上设置合理的锚点，用户只需要点击一下快速达到想要看到的内容区域。8、避免全是图片展示如果单页面网站为了提升视觉效果从而更多的使用图片，那么就会造成网站文字内容过少，不利于搜索引擎对网站的抓取和索引。9、内容为王之前我们就举过百度百科的例子，而作为单页面网站来讲，将用户所有的需求点尽可能完整的展现出来，从而解决用户的烦恼才是单页面网站立足的关键。 中级 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 这个程序中的add 来替换 sub，add.call(sub,3,1) == add(3,1)，所以运行结果为：alert(4); 输出undefined。 javascript的变量声明具有变量声明提升机制，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。并且function作用域里的变量v遮盖了上层作用域变量v。这段代码相当于下面这段： 123456var v = "hello";(function()&#123; var v; //declaration hoisting console.log(v); v = "world";&#125;)(); defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 当需要设置的样式很多时设置className而不是直接操作style。 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 12345678910111213141516100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ajax的全称：Asynchronous Javascript And XML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 创建一个Ajax： 创建XMLHttpRequest对象,也就是创建一个异步调用对象 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 使用JavaScript和DOM实现局部刷新 优点： 无刷新更新数据。 异步与服务器通信。 前端和后端负载平衡。 基于标准被广泛支持。 界面与应用分离。 缺点： AJAX干掉了Back和History功能，即对浏览器机制的破坏。 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎支持较弱。 破坏程序的异常处理机制。 违背URL和资源定位的初衷。 AJAX不能很好支持移动设备。 客户端过肥，太多客户端代码造成开发上的成本。 不容易调试。 注意点：Ajax开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。不给予用户明确的回应，没有恰当的预读数据，或者对XMLHttpRequest的不恰当处理，都会使用户感到延迟，这是用户不希望看到的，也是他们无法理解的。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。 Ajax适用场景： 表单驱动的交互 深层次的树的导航 快速的用户与用户间的交流响应 类似投票、yes/no等无关痛痒的场景 对数据进行过滤和操纵相关数据的场景 普通的文本输入提示和自动完成的场景 Ajax不适用场景： 部分简单的表单 搜索 基本的导航 替换大量的文本 对呈现的操纵 高级 HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面 减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存 12345678910111213141516171819202122232425Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 区别：1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： // CMD define(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) // AMD 默认推荐 define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... &#125;) 两等号判等，会在比较时进行类型转换；三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； Object.is在三等号判等的基础上特别处理了NaN、-0和+0 ，保证 -0和+0不再相同，但Object.is(NaN, NaN)会返回 true. Object.is应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） ​ 12345678910111213141516171819202122232425262728293031323334353637//创建cookie function setCookie(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (path) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (domain) &#123; cookieText += &apos;; domain=&apos; + domain; &#125; if (secure) &#123; cookieText += &apos;; secure&apos;; &#125; document.cookie = cookieText; &#125; //获取cookie function getCookie(name) &#123; var cookieName = encodeURIComponent(name) + &apos;=&apos;; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125; //删除cookie function unsetCookie(name) &#123; document.cookie = name + &quot;= ; expires=&quot; + new Date(0); &#125; Progressive Web App是一个利用现代浏览器的能力来达到类似APP的用户体验的技术，由Google开发，让浏览器打开的网址像APP一样运行在手机上。让Web App和Native App之间的差距更小。 优点： Installability （可安装性） App Shell：第一次渲染渲个壳、等异步数据来了再填充 Offline （离线能力） Re-engageable：推送通知的能力 缺点： 门槛不低（要求 HTTPS；Service Worker也需要学习）； 浏览器支持（主要是Safari不愿意支持，只是在5年计划里提了一下）； 用户习惯（让用户习惯于网页可以离线工作真不是短期可以达到的）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[chrome扩展程序推荐]]></title>
      <url>%2F2017%2F03%2F16%2Fchrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[Google Chrome，是一个由Google公司开发的一款设计简单、高效的网页浏览器。其最大的魅力就在于可以安装各种扩展插件，让Chrome浏览器自身的功能更加丰富。Chrome网上应用店，用户可以下载和安装应用程序、扩展程序以及主题背景。 作为用了7年的chrome的老用户，下面推荐一下我常用的chrome扩展程序。 因为某些原因，如果不能去chrome网上应用商店下载，可以去chrome插件和插件网下载，然后自行安装，安装教程参考:怎么在谷歌浏览器中安装.crx扩展名的离线Chrome插件？。 uBlock Origin一款去除页面广告的插件，之所以不推荐大名鼎鼎的Adblock Plus是因为uBlock Origin占用极低的内存和 CPU。而且uBlock Origin支持的Adblock Plus过滤语法拦截广告。 开启拦截前： 开启拦截后： 前端开发的时候记得把拦截取消。 国内下载地址：uBlock Origin 官方下载地址：uBlock Origin Tampermonkey俗称“油猴”，号称“Chrome第二应用商店”，是一款最为流行的用户脚本管理器。它可以加入更多的 Chrome 本身不支持的用户脚本功能。 安装完Tampermonkey，就可以去Greasy Fork安装各种脚本了，无数强大的脚本都可以通过这个扩展运行，代替应用商店里繁复的apps&amp;extensions，极大地减少了chrome应用、扩展造成的不必要的系统资源占用。不必担心这些脚本会导致浏览器卡顿，它们只在特定页面运行，资源占用极低。 下面是我安装的一些脚本： 国内下载地址：Tampermonkey 官方下载地址：Tampermonkey Speed dial 2Speed dial 2可以完美替代默认的新标签页。它可以记录书签、浏览历史，主题易于定制，对快速拨号页面进行分组，可以云同步所有配置（需要付费，不过很便宜）。 国内下载地址：Speed dial 2 官方下载地址：Speed dial 2 FireShotFireShot是网页截图插件，它可以对网页中整个屏幕或者是网页的部分视图进行截图操作，在截图之后用户还可以对当前截图的图片进行编辑，包括添加注释，批注，添加线条，上传，分享等操作。 国内下载地址：FireShot 官方下载地址：FireShot OneTabchrome浏览器每打开一个标签就相当于多独立运行了一个程序，所以每个网页标签都是占用内存的。标签页数量较多时消耗的内存相当可观。对内存不是那么大的人来说，用一段时间之后整个系统被拖得很慢着实非常痛苦。OneTab chrome扩展插件是为了解决 Chrome 浏览器内存占用过多的问题的，安装后，点击一下扩展图标，扩展的功能会将当前打开的标签关闭，显示在扩展页的标签列表中，相当于只打开一个标签，内存占用就一下子从几个 G 骤减为 100M 左右了；同时将标签页展示为一个竖排的列表样式，查看全部标签也更轻松了。你可以点击恢复某个标签页，也可以全部恢复打开。 国内下载地址：OneTab 官方下载地址：OneTab Scroll To TopScroll To Top可以在浏览页面时帮助你快速滚动到顶部或者底部。 国内下载地址：Scroll To Top 官方下载地址：Scroll To Top crxMouse Chrome GesturesCrxMouse是一款鼠标手势Chrome插件，使用它可以充分、方便、快捷地发挥鼠标在Chrome浏览器中的操作方式。其中包括鼠标手势，超级拖拽，滚动手势，摇杆手势，平滑滚动，标签页列表等功能，比如在Chrome浏览器中画上一个向左的转折线就可以快速地把当前的标签页关闭。 鼠标手势的设置： 鼠标手势效果演示： 超级拖拽的设置（可以方便的进行各种搜索）： 国内下载地址：crxMouse Chrome Gestures 官方下载地址：crxMouse Chrome Gestures 划词翻译一个简便但强大的翻译扩展。支持谷歌、百度、有道、必应四大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。 国内下载地址：划词翻译 官方下载地址：划词翻译 Fatkun图片批量下载Fatkun图片批量下载是一个简单好用的下载图片扩展，它可以找出当前页面的所有图片，并提供按分辨率、链接等筛选图片的功能。 国内下载地址：Fatkun图片批量下载 官方下载地址：Fatkun图片批量下载 OctotreeOctotree是一个用来显示 Github 项目的目录结构的插件， Github上的项目可以显示为类似 IDE 的代码目录树结构。缺点是需要初始化的时间，像nodejs这种稍微大一点的代码库要花大概1分钟多有去爬吧。 国内下载地址：Octotree 官方下载地址：Octotree Isometric Contributions这个插件可以把github上的contributions 显示为3d柱状图，并且给出一些更加详细的信息。 国内下载地址：Isometric Contributions 官方下载地址：Isometric Contributions WEB前端助手(FeHelper)功能包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色、Ajax接口调试。 国内下载地址：WEB前端助手(FeHelper) 官方下载地址：WEB前端助手(FeHelper) WhatFontWhatFont是一款可以帮助用户查看识别网页字体的浏览器插件。 国内下载地址：WhatFont 官方下载地址：WhatFont Page RulerPage Ruler是一款页面尺寸测量工具，非常适合前端工程师。PageRuler插件可以与当前网页的屏幕无缝地集成到一起，使用户非常精确地测量出当前页面某个元素或者是整个页面的大小尺寸。 国内下载地址：Page Ruler 官方下载地址：Page Ruler CSSViewerCSSViewer是一款快速查看css样式的插件，不需点开开发者工具，直接可以显示元素的css样式信息。 国内下载地址：CSSViewer 官方下载地址：CSSViewer Code ColaCode Cola是一个可视化编辑在线页面css样式的chrome插件。比chrome自带的开发者工具要方便一点。 国内下载地址：Code Cola 官方下载地址：Code Cola PerfectPixel by WellDoneCodePerfectPixel是一种叠加插件。它处理的是图层，这样你可以在同一页面多次叠加。 在PixelPerfect中简单地加载任意JPG或PNG格式的网站原型，然后在你的工作代码上手工定位，锁定它的位置，并将它的不透明度降低到大约20％。 当你开发HTML页面时，你可以不断地将HTML和CSS呈现的效果与原始设计稿比较。 国内下载地址：PerfectPixel by WellDoneCode 官方下载地址：PerfectPixel by WellDoneCode Web Developer Checklist这个插件可以分析任何网页是否违反最佳实践，对于Web开发谁想要确保他们遵循最佳实践，这个扩展可以让你很容易发现你的网站的问题领域。 国内下载地址：Web Developer Checklist 官方下载地址：Web Developer Checklist PageSpeed Insights (with PNaCl)这个插件是Google官方的PageSpeed Tools的chrome扩展版本，通过分析网页的内容来提供网站加载速度优化建议。 安装完后，进入开发者页面，此时顶部会多出一个PageSpeed按钮，点击Start Analyzing就可以开始分析。 国内下载地址：PageSpeed Insights (with PNaCl) 官方下载地址：PageSpeed Insights (with PNaCl) User-Agent Switcher for ChromeUser-Agent Switcher插件是一款可以使用Chrome浏览器访问网站的时候来制造一种其他浏览器正在访问该网站的一种“假象”。 国内下载地址：User-Agent Switcher for Chrome 官方下载地址：User-Agent Switcher for Chrome Responsive Web Design TesterResponsive Web Design Tester是一个能模拟网站在不同浏览器和设备上的行为，适合前端响应式网站开发。 国内下载地址：Responsive Web Design Tester 官方下载地址：Responsive Web Design Tester]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我心红蓝]]></title>
      <url>%2F2017%2F03%2F09%2F%E6%88%91%E5%BF%83%E7%BA%A2%E8%93%9D%2F</url>
      <content type="text"><![CDATA[new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: true, showlrc: 0, music: { title: "巴萨队歌", author: "巴萨", url: "http://og9ocpmwk.bkt.clouddn.com/%E5%B7%B4%E8%90%A8%E9%98%9F%E6%AD%8C.mp3", pic: "https://ooo.0o0.ooo/2017/03/09/58c165351ef44.jpg", } }); 今天凌晨看完球到现在久久不能平静，虽然加午休只睡了5个小时，但是到现在仍然竟然一点都不困，仍然处于亢奋状态，我想这就是足球的魅力吧。 看比赛前我觉得已巴萨这几场比赛的状态，我觉得打巴黎个4比0是不成问题的，毕竟大巴黎没了大奉先后，实力根本和巴萨不是一个档次的。 恩里克也排出了3-3-4阵型，我也是第一次在欧冠上看到一上来就是4前锋的阵型，巴萨全队看来是众志成城。 上半场理所当然的压着大巴黎，运气也在巴萨这边，小白造的乌龙球球真的是当时久攻不下的强心剂。当时我就想似乎按照这样下去巴萨有可能踢个4比0打加时，或者5比0直接晋级，当然这场被称为欧冠有史以来最伟大的逆转（没有之一）不可能这么简单就称为伟大。 下半场卡瓦尼的进球似乎想钉子一样把巴萨钉在了出局名单上，我承认当时我是绝望的。就好比巴黎的4比0捅了巴萨一刀，但是巴萨没死，挣扎着站起来的时候，大巴黎又捅了巴萨一刀。这放在哪个队都是直接放弃比赛，缴枪投降的。但是这是巴萨，苏亚雷斯没有放弃，他一次次冲击禁区，哪怕球出了底线也奋力追；梅西没有放弃，他一次次回撤组织进攻、不停跑位；内马尔也没有放弃，一次次不停突破、传中… 然而奇迹真的出现了，先是内马尔的任意球，划过美丽的弧线直奔死角；然后苏亚雷斯突破造点。此时已经是91分钟了，留给巴萨的时间真的不多了，要么被淘汰、要么再进一个逆转。 还是内马尔，一个轻盈的挑传，罗伯托像鬼魅般冒了出来，出现在正确的时间、正确的地点，用正确的方式把球捅进去。若不是怕影响舍友睡觉，此时我应该已经疯了吧，我狠狠地拍了拍枕头，“真TM牛逼！” 这样的球队你怎么能不爱，大巴黎连捅两刀，巴萨只要没死，就继续战斗，直到打败对手，这种逆转把足球乃至竞技体育的精神体现得淋漓尽致。 就像标题图片中球迷打出的标语：“Yes！We Can！”，是的，我们真的做到了，赛前连欧足联官方给出的比赛预测，巴萨晋级概率都是0，就这样，我萨还是做到了。 感谢巴萨，感谢这场世纪逆转， 让我们领略足球世界中的非凡魅力和无限可能性， 让我们重拾对生活的热爱，与对梦想的渴望追寻。 人生真是充满了阳光啊！ 最后以煤老板的霸气庆祝图结尾，我心红蓝！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之Angular模块]]></title>
      <url>%2F2017%2F03%2F07%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BAngular%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Angular模块化Angular 模块是一个由@NgModule装饰器提供元数据的类，元数据包括： 声明哪些组件、指令、管道属于该模块。 公开某些类，以便其它的组件模板可以使用它们。 导入其它模块，从其它模块中获得本模块所需的组件、指令和管道。 在应用程序级提供服务，以便应用中的任何组件都能使用它。 应用的根模块BrowserModule注册了一些关键的应用服务提供商。 它还包括了一些通用的指令，例如NgIf和NgFor，所以这些指令在该模块的任何组件模板中都是可用的。 @NgModule.bootstrap属性把这个AppComponent标记为引导 (bootstrap) 组件。 当 Angular 引导应用时，它会在 DOM 中渲染AppComponent，并把结果放进index.html的&lt;my-app&gt;元素标记内部。 引导根模块通过即时 (JiT) 编译器动态引导什么是Angular编译器？Angular编译器会把我们所写的应用代码转换成高性能的JavaScript代码。 在编译过程中，@NgModule的元数据扮演了很重要的角色。@NgModule元数据告诉Angular编译器要为当前模块编译哪些组件，以及如何把当前模块和其它模块链接起来。 Angular 编译器在浏览器中编译并引导该应用: 12345678// The browser platform with a compilerimport &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';// The app moduleimport &#123; AppModule &#125; from './app/app.module';// 编译并运行模块platformBrowserDynamic().bootstrapModule(AppModule); 使用预编译器 (AoT) 进行静态引导静态方案可以生成更小、启动更快的应用，建议优先使用它，特别是在移动设备或高延迟网络下。 使用静态选项，Angular 编译器作为构建流程的一部分提前运行，生成一组类工厂。它们的核心就是AppModuleNgFactory。 引导预编译的AppModuleNgFactory的语法和动态引导AppModule类的方式很相似。 12345678// The browser platform without a compilerimport &#123; platformBrowser &#125; from '@angular/platform-browser';// The app module factory produced by the static offline compilerimport &#123; AppModuleNgFactory &#125; from './app/app.module.ngfactory';// Launch with the app module factory.platformBrowser().bootstrapModuleFactory(AppModuleNgFactory); 由于整个应用都是预编译的，所以我们不用把 Angular 编译器一起发到浏览器中，也不用在浏览器中进行编译。 下载到浏览器中的应用代码比动态版本要小得多，并且能立即执行。引导的性能可以得到显著提升。 无论是 JiT 还是 AoT 编译器都会从同一份AppModule源码中生成一个AppModuleNgFactory类。 JiT 编译器动态地在浏览器的内存中创建这个工厂类。 AoT 编译器把工厂输出成一个物理文件，也就是我们在静态版本main.ts中导入的那个。 声明自定义的组件和指令声明在模块的declarations中。 导入BrowserModule导入了CommonModule并且重新导出了它。 最终的效果是：只要导入BrowserModule就自动获得了CommonModule中的指令。 模块可以重新导出其它模块，这会导致重新导出它们导出的所有类。 纯服务类的模块不会导出任何可供其它模块使用的可声明类，例如HttpModule 组件、指令和管道只能属于一个模块。永远不要再次声明属于其它模块的类。 如果有两个同名指令，只要在 import 时使用as关键字来为第二个指令创建个别名就可以了。 123import &#123; HighlightDirective as ContactHighlightDirective&#125; from './contact/highlight.directive'; 特性模块特性模块我们引导根模块来启动应用，但导入特性模块来扩展应用。特性模块可以对其它模块暴露或隐藏自己的实现。 几乎所有要在浏览器中使用的应用的根模块（AppModule）都应该从@angular/platform-browser中导入BrowserModule。 添加 ContactModuleBrowserModule还从@angular/common中重新导出了CommonModule，这意味着AppModule中的组件也同样可以访问那些每个应用都需要的Angular指令，如NgIf和NgFor。 在其它任何模块中都不要导入BrowserModule。 特性模块和惰性加载模块应该改成导入CommonModule。 它们需要通用的指令。它们不需要重新初始化全应用级的提供商。 通过路由器惰性加载模块应用路由惰性加载模块的位置是字符串而不是类型。 在本应用中，该字符串同时标记出了模块文件和模块类，两者用#分隔开。 12&#123; path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' &#125;,&#123; path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' &#125; 路由到特性模块当需要为根模块和特性模块分别提供不同的导入值时，forRoot和forChild是约定俗成的方法名。 共享模块通过让SharedModule重新导出CommonModule和FormsModule模块，可以消除CommonModule和FormsModule模块重复导入。 不要在共享模块中把应用级单例添加到providers中。 否则如果一个惰性加载模块导入了此共享模块，就会导致它自己也生成一份此服务的实例。 核心模块把这些一次性的类收集到CoreModule中，并且隐藏它们的实现细节。 简化之后的根模块AppModule导入CoreModule来获取其能力。 用forRoot配置核心服务模块的静态方法forRoot可以同时提供并配置服务。 它接收一个服务配置对象，并返回一个ModuleWithProviders。这个简单对象具有两个属性： ngModule - CoreModule类 providers - 配置好的服务提供商 根模块AppModule会导入CoreModule类并把它的providers添加到AppModule的服务提供商中。 一个可选的、被注入的UserServiceConfig服务扩展核心的UserService服务。 如果有UserServiceConfig，UserService就会据此设置用户名。 12345src/app/core/user.service.ts (constructor)constructor(@Optional() config: UserServiceConfig) &#123; if (config) &#123; this._userName = config.userName; &#125;&#125; CoreModule.forRoot接收UserServiceConfig对象： 12345678910src/app/core/core.module.ts (forRoot)static forRoot(config: UserServiceConfig): ModuleWithProviders &#123; return &#123; ngModule: CoreModule, providers: [ &#123;provide: UserServiceConfig, useValue: config &#125; ] &#125;;&#125; 在AppModule的imports列表中调用它: 123456imports: [ BrowserModule, ContactModule, CoreModule.forRoot(&#123;userName: 'Miss Marple'&#125;), AppRoutingModule], 只在应用的根模块AppModule中调用forRoot。 如果在其它模块（特别是惰性加载模块）中调用它则违反了设计意图，并会导致运行时错误。别忘了导入其返回结果，而且不要把它添加到@NgModule的其它任何列表中。 禁止重复导入CoreModule只有根模块AppModule才能导入CoreModule。 如果惰性加载模块导入了它，就会出问题。 如果我们错误的把CoreModule导入了一个惰性加载模块， @SkipSelf让 Angular 在其父注入器中查找CoreModule，这次，它的父注入器却是根注入器了。 当然，这次它找到了由根模块AppModule导入的实例。 该构造函数检测到存在parentModule，于是抛出一个错误。 123456constructor (@Optional() @SkipSelf() parentModule: CoreModule) &#123; if (parentModule) &#123; throw new Error( 'CoreModule is already loaded. Import it in the AppModule only'); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之CLI快速起步]]></title>
      <url>%2F2017%2F03%2F06%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BCLI%E5%BF%AB%E9%80%9F%E8%B5%B7%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[Angular-CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布。 设置开发环境node版本4.X.X以上，npm版本3.X.X以上。 全局安装Angular-CLI： 1npm install -g @angular/cli 创建新项目及应用骨架运行下面命名生成一个新项目以及应用的骨架代码： 1ng new my-app 启动开发服务器进入项目目录，并启动服务器。 12cd my-appng serve ng serve命令会启动开发服务器，监听文件变化，并在修改这些文件时重新构建此应用。 在浏览器中打开http://localhost:4200/，可以显示应用信息。 项目文件概览src文件夹你的应用代码位于src文件夹中。 所有的Angular组件、模板、样式、图片以及你的应用所需的任何东西都在那里。 这个文件夹之外的文件都是为构建应用提供支持用的。 12345678910111213141516171819src|--app| |-app.component.css| |-app.component.html| |-app.component.spec.ts| |-app.component.ts| |-app.module.ts|--assets| |-.gitkeep|--environments| |-environment.prod.ts| |-environment.ts|--favicon.ico|--index.html|--main.ts|--polyfills.ts|--styles.css|--test.ts|--tsconfig.json assets/*文件夹下放图片等任何东西，在构建应用时，它们全都会拷贝到发布包中。 environments/*文件夹中包括为各个目标环境准备的文件，它们导出了一些应用中要用到的配置变量。 这些文件会在构建应用时被替换。 比如你可能在产品环境中使用不同的API端点地址，或使用不同的统计Token参数。 甚至使用一些模拟服务。 index.html大多数情况下你都不用编辑它。 在构建应用时，CLI会自动把所有js和css文件添加进去，所以你不必在这里手动添加任何 或 标签。 polyfills.ts能帮我们把不同的浏览器对Web标准的支持程度进行标准化。 根目录src/文件夹是项目的根文件夹之一。 其它文件是用来帮助你构建、测试、维护、文档化和发布应用的。它们放在根目录下，和src/平级。 123456789101112131415my-app|--e2e| |-app.e2e-spec.ts| |-app.po.ts| |-tsconfig.json|--node_modules/...|--src/...|--.editorconfig|--.gitignore|--angular-cli.json|--karma.conf.js|--package.json|--protractor.conf.js|--README.md|--tslint.json protractor.conf.js给Protractor使用的端到端测试配置文件，当运行ng e2e的时候会用到它。 tslint.json给TSLint和Codelyzer用的配置信息，当运行ng lint时会用到。 Lint功能可以帮你保持代码风格的统一。 生成组件、指令、管道和服务12345678910ng generate component my-new-componentng g component my-new-component # 简写# 组件支持关联路径生成# 如果在src/app/feature/目录中，可以运行：ng g component new-cmp# 在src/app/feature/new-cmp中生成组件# 但是如果这样运行：ng g component ../newer-cmp# 组件将会在src/app/newer-cmp中生成 用下面的命令可以生成各种模板： 模板 用法 Directive ng g directive my-directive Component ng g component my-component Pipe ng g pipe my-pipe Service ng g service my-service Class ng g class my-class Interface ng g interface my-interface Enum ng g enum my-enum Module ng g module my-module]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现（三）]]></title>
      <url>%2F2017%2F03%2F03%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[之前在AngularJS2中一种button切换效果的实现和AngularJS2中一种button切换效果的实现（二）中实现了按钮的切换效果，但是方法比较low，这次我们使用Angular2的指令来实现。 指令实现hover效果123456789101112131415161718192021import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('mouseenter') onMouseEnter() &#123; this.highlight('red'); &#125; @HostListener('mouseleave') onMouseLeave() &#123; this.highlight(null); &#125; private highlight(color: string) &#123; this.el.nativeElement.style.backgroundColor = color; &#125;&#125; 123&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt; 123456789.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125; hover的效果直接参考Angular官网的代码。 指令实现click效果12345678910111213141516171819202122232425import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('click') onMouseClick() &#123; this.clickhighlight("black"); &#125; private clickhighlight(color: string) &#123; let obj = this.el.nativeElement; let btns = obj.parentNode.children; //背景色全部重置 for(let i=0; i&lt;btns.length; i++)&#123; btns[i].style.backgroundColor = "#3399ff"; &#125; //设置当前点击对象的背景色 obj.style.backgroundColor = color; &#125;&#125; 12345&lt;div&gt;&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 123456789.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125; click效果仍然用@HostListener装饰器引用属性型指令的宿主元素，首先把所有button的背景颜色重置，然后再设置当前点击对象的背景颜色，这样就达到了点击后背景颜色变化的效果。 指令实现click加hover效果12345678910111213141516171819202122232425import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('click') onMouseClick() &#123; this.clickhighlight("black"); &#125; private clickhighlight(color: string) &#123; let obj = this.el.nativeElement; let btns = obj.parentNode.children; //背景色全部重置 for(let i=0; i&lt;btns.length; i++)&#123; btns[i].style.backgroundColor = "#3399ff"; &#125; //设置当前点击对象的背景色 obj.style.backgroundColor = color; &#125;&#125; 12345&lt;div&gt;&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 12345678910111213.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125;.btn:hover&#123; background: black !important;&#125; 配合上文click效果，只要加上一行css代码就可以实现click和hover的组合效果，此处务必使用hover伪类，并用!important来提升样式的优先级，如果用@HostListener装饰器，mouseenter、mouseleave、click三者会打架：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript DOM编程艺术》学习笔记]]></title>
      <url>%2F2017%2F02%2F25%2F%E3%80%8AJavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[本书大部分demo参见DOM Scripting Demo，本人手敲，如有错误欢迎提交pr JavaScript语法准备工作12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="example.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 把&lt;script&gt;标签放在HTML文档最后，&lt;/body&gt;标签之前，这样即使加载脚本时，Windows对象的load事件依然可以执行对文档进行的各种操作。 因为位于&lt;head&gt;中的脚本会导致浏览器不能并行加载其他文件。一般来说，根据HTTP规范，浏览器每次从同一个域名中最多只能同时下载两个文件。 操作算术操作符字符串和数值拼接在一起结果是更长的字符串。 1alert("10"+20)； //输出1020 比较操作符JavaScript中，==并不表示严格相等，例如： 12345var a = false;var b = "";if (a == b)&#123; //true alert("a = b");&#125; 这个语句求值结果是ture，因为==认为空字符串与false的含义相同。要进行严格比较，就要使用另一种等号：===。这个全等操作符会执行严格的比较，不仅比较值，而且会比较变量的类型： 12345var a = false;var b = "";if (a === b)&#123; //flase alert("a = b");&#125; 函数如果在某个函数中使用var，那个变量就被看做局部变量，它只存在这个函数上下文中；如果没有使用var，这个变量就被看做是全局变量，如果脚本里面出现一个与之同名的全局变量，这个函数就会改变这个全局变量的值。 1234567891011121314151617function square(num)&#123; total = num * num; return total&#125;var total = 50;var number = square(20);alert(total); //输出400-------------我是分割线-------------function square(num)&#123; var total = num * num; return total&#125;var total = 50;var number = square(20);alert(total); //输出50 对象假设有个Person的对象，为了使用Person来描述人，需要创建一个Person对象的实例。实例是对象的具体个体。例如，你和我都是人，都可以用person对象来描述；但你和我是两个不同的个体，和可能有着不同的属性。因此对应着不同的Person对象–虽然都是Person对象，但是它们是两个不同的实例。 new关键字为对象创建一个新的实例： 1var tangcheng = new Person; 内建对象Array对象、Math对象、Date对象都是内建对象。 宿主对象有些已经预定义的对象是由运行环境提供，具体到web就是浏览器提供的，这些对象被称为宿主对象。不仅包括Form、Image、Element等，还包括document对象。 DOMwindow对象对应浏览器窗口本身，这个对象的属性和方法通常称为BOM（浏览器对象模型）。 DOM的节点树和家谱类似。 节点节点分为元素节点、文本节点、属性节点。 获取元素getElementByIdgetElementById返回的是一个对象。 getElementsByTagNamegetElementsByTagName返回的是一个对象数组，即使整个文档只有一个元素，getElementsByTagName返回的也是数组，数组长度为1。 getElementsByTagName允许把一个通配符作为参数，返回文档中所有元素，*必须放在引号中（为了与乘法操作符区别）。 1document.getElementsByTagName("*"); getElementsByTagName可以和getElementById结合起来使用： 123var shopping = document.getElementById("purchase");var items = shopping.getElementsByTagName("*");//返回shopping下面所有的标签 getElementsByClassNamegetElementsByClassName返回的是一个具有同类名元素的数组。 可以指定多个类名，只要在字符串参数中用空格分隔类名，匹配时类名顺序不重要，就算类名还带有其他类名也可以匹配： 1document.getElementsByClassName("tc zj"); getElementsByClassName兼容性可以使用下面的脚本实现： 123456789101112131415function getElementsByClassName(node, classname)&#123; if (node.getElementsByClassName)&#123; //使用现有方法 return node.getElementsByClassName(classname); &#125;else&#123; var results = new Array(); var elems = node.getElementsByTagName("*"); for (var i = 0; i&lt;elems.length; i++)&#123; if (elems[i].className.indexOf(classname)!=-1)&#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 获取和设置属性getAttributegetAttribute方法不属于document对象，只能通过元素节点对象调用。属性不存在时返回null。 如果something是null，if (something)和if (something != null)等价。 setAttributesetAttribute方法也只能通过元素节点对象调用。 1object.setAttribute(attribute,value); 通过setAttribute对文档做出的修改后，再通过浏览器的view source（查看源码）选项去查看文档的源码时看到的仍将是改变前的值，也就是说setAttribute做出的修改不会反映在文档本身的源码中。这是因为： DOM的工作模式是：先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力：对页面进行刷新不需要再浏览器里刷新页面。 案例研究：JavaScript图片库JavaScriptDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把从本书学到的DOM技巧运用在web浏览器以外的应用环境里，严格遵守”第1级DOM“能够让你避免与兼容性有关的任何问题。 应用这个JavaScript函数事件处理函数事件处理函数的工作机制：在给某个元素添加事件处理函数后，一旦事件发生，相应的JavaScript代码就会得到执行。被调用的JavaScript代码可以返回一个值，这个值将被传递给那个事件处理函数。 例如：给某个链接添加一个onclick事件处理函数，onclick事件处理函数所触发的JavaScript代码会返回false或者true。当这个链接被点击时，如果那段JavaScript代码返回的是true，onclick事件处理函数就认为”这个链接被点击了“；反之，如果返回值是false,onclick事件处理函数就认为”这个链接没有被点击“。 12&lt;!--当点击时，返回的是false，链接的默认行为没有被触发--&gt;&lt;a href="http://tc9011.com" onclick="return false"&gt;&lt;/a&gt; 对这个函数进行扩展childNodes属性在一颗节点树上，childNodes属性可以获取任何一个元素的所有子元素，它是一个包含这个元素全部子元素的数组。 nodeType属性每个节点都有nodeType属性，nodeType的值是一个数字： 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 nodeValue属性nodeValue属性用来获取或者设置一个节点的值。 &lt;p&gt;元素里的文本是另一种节点，&lt;p&gt;元素本身的nodeValue是一个空值： 1&lt;p id="description"&gt;Choose an image&lt;/p&gt; 1234var description = document.getElementById("description");alert(description.nodeValue);//输出nullalert(description.childNodes[0].nodeValue);//输出"Choose an image"alert(description.firstChild.nodeValue);//输出"Choose an image" 最佳实践平稳退化JavaScript使用window对象的open()方法来创建新的浏览器窗口。这个方法有三个参数： 1window.open(url,name,feature) 这三个参数都是可选的： 第一个参数是想在新窗口打开的URL地址。省略则弹出空白窗口。 第二个参数是新窗口的名字。可以在代码中通过这个名字与新窗口进行通信。 第三个参数是一个以逗号分隔的字符串，其内容是新窗口的各种属性。 ”javascript:“伪协议”javascript:“伪协议让我们通过一个链接来调用JavaScript函数。 1&lt;a href="javascript:popUp("http://tc9011.com");"&gt;tc9011.com&lt;/a&gt; 在HTML文档中通过”javascript:“伪协议调用JavaScript代码的做法非常不好。 分离JavaScript1&lt;a href="http://tc9011.com" onclick="popUp(this.href);return false"&gt;&lt;/a&gt; JavaScript语言不要求事件必须在HTML文档里处理（如上面的onclick事件可以分离到外部JavaScript文件中。），可以在外部的JavaScript文件里面把一个事件添加到HTML文档中某个元素上。 1getElementById(id).event = active 如果涉及多个元素，可以用getElementsByTagName和getAttribute把事件添加到有着特定属性的一组元素上： 123456789var links = document.getElementsByTagName("a");for (var i=0; i&lt;links.length; i++)&#123; if (links[i].getAttribute("class") == "popup")&#123; links[i].onclick = function()&#123; popUp(this.getAttribute("href")); return false; &#125; &#125;&#125; 以上代码把click操作从HTML文档中分离出来。 当HTML文档全部加载完毕将触发window.onload事件，这个事件触发时document对象已经存在，这样可以避免HTML没有加载完全时，JavaScript代码获取不到相应的id或者class。 性能考虑尽量减少访问DOM和尽量减少标记访问DOM对脚本性能会产生非常大的影响。多次访问相同的DOM，可以先把第一次搜索的结果保存在一个变量中。 12345678910111213if (document.getElementsByTagName("a").length &gt; 0)&#123; var links = document.getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++)&#123; //对每个链接节点做处理 &#125;&#125;------------优化后------------var links = document.getElementsByTagName("a");if (links.length &gt; 0)&#123; for (var i=0; i&lt;links.length; i++)&#123; //对每个链接节点做处理 &#125;&#125; 案例研究：图片库改进版它支持平稳退化吗href设置为真实值，在JavaScript被禁用的情况下，链接也能跳转。 1&lt;a href="images/1.jpg" title="A" onclick="showPic(this);return false"&gt;&lt;/a&gt; 它的JavaScript与HTML标记是分离的吗出现多个window.onload时，只会执行最后一个。可以使用自定义的addLoadEvent函数完成多个函数绑定到window.onload。 1234567891011121314function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != "function")&#123; window.onload = func; &#125;else &#123; window.onload = function () &#123; oldonload(); func(); &#125; &#125;&#125;------------使用------------addLoadEvent(firstFunction);addLoadEvent(secondFunction); 优化nodeName属性总是返回一个大写字母的值，即使元素在HTML文档里面是小写字母。 键盘访问用Tab键移动到某个链接然后按下回车键的动作也会出发onclick事件。 DOM Core和HTML-DOM getElementById getElementsByTagName getAttribute setAttribute 这些方法都是DOM Core的组成部分。它们并不专属于JavaScript，支持DOM和任何一种程序设计语言都可以使用它们。 onclick属性属于HTML-DOM，HTML-DOM只能用来处理web文档。HTML-DOM书写更简短： 1234567891011document.getElementsByTagName("form") --&gt;document.forms--------分割线--------element.getAttribute("src") --&gt;element.src--------分割线--------var source = whichpic.getAttribute("href") --&gt;var source = whichpic.href--------分割线--------placeholder.setAttribute("src",source) --&gt;placeholder.src = source 动态创建标记一些传统的方法document.writedocument.write最大的缺点是违背了“行为应该和表现分离”的原则，应该避免使用。 innerHTML属性innerHTML无法区分“插入一段HTML内容”和“替换一段HTML内容”，一旦使用这个属性，里面全部内容都将被替换。 DOM方法浏览器实际显示的是DOM节点树，不是物理文档的内容。 createElement方法createElement方法只能创建元素节点。 1document.createElement(nodeName); appendChild方法1parent.appendChild(child); createTextNode方法createTextNode方法用来创建文本节点。 重返图片库 如果元素存在只是为让DOM方法处理，用DOM方法来创建它们才是最合适的。 这样是不是太极端了，增加了对DOM的操作，会不会影响性能？ 在已有元素前插入一个新元素insertBefore()方法把一个新元素插入到现有元素的前面。 12parentElement.insertBefore(newElement,targetElement);parentElement 等于 targetElement.parentNode 在现有元素后插入一个新元素编写insertAfter函数DOM本身没有提供insertAfter函数，可以利用已有DOM方法和属性编写一个： 12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; AjaxXMLHttpRequest对象XMLHttpRequest对象充当浏览器中的脚本（客户端）与服务器之间的中间人的角色。 onreadystatechange是一个事件处理函数，它会在服务器给XMLHttpRequest对象送回响应的时候被触发执行。在这个处理函数中，可以根据服务器的具体响应做相应的处理。 服务器在向XMLHttpRequest对象发回响应时，浏览器会在不同阶段更新readyState属性的值： 0表示未初始化 1表示正在加载 2表示加载完毕 3表示正在交互 4表示完成 访问服务器发送回来的数据要通过两个属性完成。一个是responseText属性，这个属性用于保存文本字符串形式的数据。另一个属性是responseXML属性，用于保存content-Type头部中指定为text/xml的数据，其实是一个DocumentFragment对象。 充实文档的内容不应该做什么遵循下面两个原则：1、渐进增强。应该在最开始根据内容使用标记实现良好的结构，然后再逐步加强这些内容。这些增强工作可以是通过css改进呈现效果，也可以通过DOM添加各种行为。2、平稳退化。渐进增强的实现必然支持平稳退化。缺乏必要css和DOM支持的访问者仍然可以访问到核心内容。 CSS-DOM三位一体的网页结构层结构层由HTML或XHTML之类的标记语言负责创建。 表示层表示层由css负责完成。css描述页面内容应该如何呈现。 行为层行为层负责内容应该如何响应事件这一问题。这是JavaScript和DOM主宰的领域。 style属性每个元素的style属性是都是一个对象。 引用中间带减号的css属性时，DOM要求用驼峰命名法。例如：font-family变成element.style.fontFamily。 何时该用DOM脚本设置样式为有类似属性的多个元素声明样式： 123input[type*="text"] &#123; font-size: 1em;&#125; 根据元素位置声明样式： 123p:first-of-type &#123; font-of-size: 1em;&#125; 需要决定是采用纯粹的CSS来解决，还是利用DOM来设置样式，需要考虑以下因素： 这个问题最简单的解决方案是什么； 哪种解决方案会得到更多浏览器的支持。 className属性通过className属性直接赋值来设置某个元素的class属性将替换该元素的原有class属性。如要追加class属性，可以这样写： 1elem.className += " intro"; 用JavaScript实现动画效果动画基础知识位置position属性的合法值有static、fixed、relative和absolute四种。static是position属性的默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。relative含义和static相似，区别在于position属性等于relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 如果把某个元素的position属性设置为absolute，我们就可以把它摆放到容纳它的”容器“的任何位置。这个容器要么是文档本身，要么是一个有着fixed或者absolute属性的父元素。这个元素原始标记里出现的位置与它的显示位置无关，因为它的显示位置由top、left、right和bottom等属性决定。 时间递增量JavaScript函数parseInt可以把字符串里的数值信息提取出来。例如： 1parseInt("18 forbidden");//返回数值18 实用的动画W3C在web内容可访问性指南（Web Content Accessibility Guidelines）7.2节里给出这样的建议： 除非浏览器允许用户”冻结“移动着的内容，否则就应该避免让内容在页面中移动。（优先级2）。如果页面上有移动着的内容，就应该用脚本或插件的机制允许用户”冻结“这种移动或动态更新行为。 CSSCSS的overflow属性用来处理一个元素的尺寸超出其容器尺寸的情况。overflow属性有四个可取值： visible：不剪裁溢出的内容。浏览器将把溢出的内容呈现在其容器元素的显示区域以外，全部内容都可见。 hidden：隐藏溢出的内容。内容只显示在其容器元素的显示区域里，这意味着只有一部分内容可见。 scroll：类似于hidden，浏览器将对溢出的内容进行隐藏，但是显示一个滚动条以便让用户能够滚动看到内容的其他的地方。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条。如果内容没有溢出，就不显示滚动条。 父元素的position设置为relative，子元素的（0，0）坐标将固定在父元素的左上角。 变量作用域问题属性是只与某个特定元素有关的变量。JavaScript允许我们为元素创建属性： 1element.property = value; 这和创建变量很像，但是区别在于这是属于某个特定元素的变量。 下面是我自己改写的时候碰到的for循环中的闭包问题，按照错误的改写，for循环中i的值始终为2，要使得for循环每次正常输出，需要先把i的值赋给每个links的i属性，调用时候用this表示当前links来调用i属性。参考资料浅谈JavaScript for循环 闭包 12345678910111213141516171819202122232425 //把下面改写成for循环。 links[0].onmousemove = function () &#123; moveElement("preview",-110,0,10); &#125;; links[1].onmousemove = function () &#123; moveElement("preview",-220,0,10); &#125;; links[2].onmousemove = function () &#123; moveElement("preview",-330,0,10); &#125;;--------------错误改写-------------- for (var i=0; i&lt;links.length; i++)&#123; links[i].onmousemove = function () &#123; var x = (i+1)*-110; moveElement("preview",x,0,10); &#125;; &#125;--------------正确改写-------------- for (var i=0; i&lt;links.length; i++)&#123; links[i].i = i; links[i].onmousemove = function () &#123; var x = (this.i+1)*-110; moveElement("preview",x,0,10); &#125;; &#125; HTML5XHTML语法比HTML严格，如：标签一定要闭合、标签一定要是小写、所有属性都要赋值等。 几个示例音频和视频为了保证HTML5的最大兼容性，至少要包含下列三个版本： 基于H.264和AAC的MP4 WebM（VP8+Vorbis） 基于Theora视频和Vorbis音频的Ogg文件 为了最大程度兼容不支持HTML5的浏览器，一般还要准备一个flash或者QuickTime插件版的视频。 不同视频格式排序的时候应该把MP4放在第一位，因为IOS4之前版本中的Mobile Safari只能解析一个&lt;video&gt;元素，故把针对IOS格式的放在最前面 自定义控件&lt;video&gt;元素自定义控件可以通过一些DOM属性来实现，主要包括： currentTime，返回当前播放的位置，以秒表示； duration，返回媒体的总时长，以秒表示，对流媒体返回无穷大； pause，表示媒体是否处于暂停状态； 此外，还有一些与特定媒体相关的事件，可以用来触发你的脚本。主要事件有： play，在媒体播放开始时发生； pause，在媒体暂停时发生； loadeddata，在媒体可以从当前播放位置开始播放时发生； ended，在媒体已播放完成而停止时发生。 不管创建什么控件，都不要忘了在&lt;video&gt;元素中添加control属性： 1&lt;video src="movie.ogv" controls&gt;&lt;/video&gt; 表单新的输入控件类型包括： email url date number range，用于生成滑动条 search tel color，用于选择颜色 新的属性： autocomplete，用于文本输入框添加一组建议的输入项； autofocus，用于让表单元素自动获得焦点； form，用于对&lt;form&gt;标签外部的表单元素分组； min、max和step，用在范围（range）和数值（number）输入框中； pattern，用于定义一个正则表达式，以便验证输入的值； placeholder required，表示必填 综合示例css把css可以拆成几个模块，然后用@import导入到一个基本的样式表basic.css中，如果要添加或者删除一个样式，只要编辑basic.css就可以。在html中也只要引入basic.css就行。 颜色不管哪个元素应用什么颜色，都要同时给它一个背景颜色。 JavaScript取到当前页面的URL可以使用window.location.href。 表单每一个form对象都有一个elements.length属性，这个属性返回表单中包含的表单元素的个数： 1form.elements.length 这个返回值与childNodes.length不一样，后者返回的是元素中包含的所有节点的个数。而form对象的elements.length属性只关注那些属于表单元素的元素，如：input、textarea等。 form.elements是包含了所有表单元素的数组。 elements数组中的每个表单元素都有自己的一组属性。 elements.value保存了表单元素的当前值。 onfocus事件会在用户通过按Tab键或者单击表单字段时被触发。 onblur事件会在用户把焦点移除表单字段时触发。 encodeURIComponent函数把有歧义的字符串转换成对应的ASCⅡ编码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[听说你的placeholder想换行？]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%90%AC%E8%AF%B4%E4%BD%A0%E7%9A%84placeholder%E6%83%B3%E6%8D%A2%E8%A1%8C%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[这是同事遇到的一个问题，在&lt;textarea&gt;标签里面不仅要加上placeholder属性，还要换行。在stackoverflow上有相关的讨论，主要有下面几种做法： 官方说明官方说明： The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format. The attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters. The placeholder attribute should not be used as a replacement for a label. For a longer hint or other advisory text, place the text next to the control. 翻译过来就是： placeholder属性是用来帮助用户输入的简短提示（一个字或者一个短语），这个提示应该是简单的数值或者简短的描述。placeholder属性不应该作为label的替代者。对于较长或者复杂的提示，将文本置于控件旁边。 解决办法使用&amp;#10;1&lt;textarea name="foo" placeholder"hello you&amp;#10;Second line&amp;#10;Third line"&gt;&lt;/textarea&gt; 这个不能跨浏览器，在ie、chrome下是可以的，但是在firefox和safari中不行。 css解决办法1234567891011::-webkit-input-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125;::-moz-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125;:-ms-input-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125; 只适用于webkit内核的浏览器（chrome、safari），对firefox和ie没有效果。 使用jQuery的watermark控件通过watermark可以全平台兼容。下载控件后，引入到项目，然后在&lt;textarea&gt;中定义jq_watermark的class。 1234&lt;script type="text/javascript" src="jquery.watermark.js"&gt;&lt;/script&gt;&lt;label for="comments"&gt;Comments:&lt;/label&gt;&lt;br /&gt;&lt;textarea id="comments" placeholder="Tell Us&lt;br/&gt;What do you think...&lt;br/&gt;We are here" class="jq_watermark" rows="3" cols="80"&gt;&lt;/textarea&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[翻译]angular2-webpack-starter]]></title>
      <url>%2F2017%2F02%2F16%2F%5B%E7%BF%BB%E8%AF%91%5D-angular2-webpack-starter%2F</url>
      <content type="text"><![CDATA[在github上看到了这个项目，感觉挺好的，就拿过来翻译一下，顺便提高一下看英文文档的水平 Angular2 Webpack Starter本仓库作为Angular2初始化工具为所有寻找更快启动和运行Angular2和TypeScript的人提供帮助。这个项目使用webpack2来构建我们的文件和协助模块化。同时使用Protractor进行e2e测试、Karma进行单元测试。 这是Angular2在文件和应用架构方面最好的练习； 准备用webpack构建基于TypeScript的应用； 当尝试使用Angular2时，Angular2的案例已经准备好了； 对于想启动自己项目的人来说，这是一个极好的Angular2种子库； 为你产品构建的页面快速加载提供AoT编译； Tree shaking会自动删除包中没有用的代码； Webpack DLLs可以大大加快开发构建； 用Jasmine和Karma来测试Angular2的代码； 用Istanbul和Karma来进行测试覆盖； 用Protractor来进行Angular2代码的e2e测试； 用@type进行类型管理； 用webpack、@angularclass/hmr和@angularclass/hmr-loader来做模块热替换(HMR)； 用angular/material2来做Material Design； 通过修改package.json实现对Angular4以及未来Angular任何版本的支持。 Quick start确保你的node版本大于5.0，npm版本大于3.0。 克隆或者下载这个仓库后，编辑在/src/app/app.component.ts里的app.component.ts。 123456789101112131415161718# 克隆仓库# --depth 1 表示克隆最近一次commit.git clone --depth 1 https://github.com/angularclass/angular2-webpack-starter.git# 切换目录cd angular2-webpack-starter# 用npm安装库npm install# 起一个服务npm start# 使用模块热替换npm run server:dev:hmr# 如果在中国，请使用cnpm# https://github.com/cnpm/cnpm 在浏览器中打开 http://0.0.0.0:3000 或者 http://localhost:3000 。 Table of Contents文件结构我们在项目中使用组件化的方法，这是开发Angular app的新标准，是一种通过封装行为逻辑来确保代码可维护性的极好的方法。一个组件基本上是一个完整的app，它通常在一个文件或者文件夹里面包含style, template, specs, e2e, and component class。下面是文件结构的样子： 1234567891011121314151617181920212223242526272829303132333435angular2-webpack-starter/ ├──config/ * 配置 | ├──helpers.js * 配置文件的helper functions | ├──spec-bundle.js * 忽略这个设置Angular2测试环境的魔法 | ├──karma.conf.js * 单元测试的karma配置 | ├──protractor.conf.js * e2e测试的protractor配置 │ ├──webpack.dev.js * webpack开发环境配置 │ ├──webpack.prod.js * webpack产品环境配置 │ └──webpack.test.js * webpack测试环境配置 │ ├──src/ * 将被编译成js的源代码 | ├──main.browser.ts * 浏览器的入口文件 │ │ | ├──index.html * Index.html: 用来生成index页面 │ │ | ├──polyfills.ts * polyfills文件 │ │ │ ├──app/ * WebApp: 文件夹 │ │ ├──app.component.spec.ts * 在app.component.ts中的一个简单测试 │ │ ├──app.e2e.ts * 一个简单e2e测试 │ │ └──app.component.ts * 一个简单的App component │ │ │ └──assets/ * 静态资源存放在这边 │ ├──icon/ * www.favicon-generator.org图标列表 │ ├──service-worker.js * 忽略这个.service worker还没完成 │ ├──robots.txt * 让搜索引擎爬取你的网站 │ └──humans.txt * 让别人知道谁是开发者 │ │ ├──tslint.json * typescript lint配置 ├──typedoc.json * typescript文件生成 ├──tsconfig.json * typescript使用外部webpack的配置 ├──tsconfig.webpack.json * webpack对typescript使用的配置 ├──package.json * npm管理的项目依赖 └──webpack.config.js * webpack主要的配置文件 开始依赖运行这个app你需要： node和npm（通过brew安装node） 确保你运行最新版本的Nodev4.X.X(或者v5.X.X)和NPM3.X.X+ 如果你已经安装nvm—特别推荐（可以通过brew安装nvm）—你可以通过nvm install --lts &amp;&amp; nvm use来运行最新版本的Node。你也可以用zsh来帮你自动完成。 一旦你完成这些，你应该用npm insatll --global安装这些全局包。 webpack (npm install --global webpack) webpack-dev-server (npm install --global webpack-dev-server) karma (npm install --global karma-cli) protractor (npm install --global protractor) typescript (npm install --global typescript) 安装 fork 这个仓库 clone 你fork的仓库 npm install webpack-dev-server rimraf webpack -g 安装需要的全局依赖 npm install 安装所有的依赖或者yarn npm run server 在另一个标签启动一个服务 运行app安装完所有的依赖以后，现在可以运行这个app。运行npm run server来启动一个本地服务，这个服务利用webpack-dev-server 来监听、构件（在内存中）和重新加载。通过这个端口http://0.0.0.0:3000可以访问页面（如果你是IPv6或者使用express服务，通过http://[::1]:3000/访问）。 服务12345# developmentnpm run server# productionnpm run build:prodnpm run server:prod 其他命令构件文件123456# developmentnpm run build:dev# production (jit)npm run build:prod# AoTnpm run build:aot 模块热替换1npm run server:dev:hmr 监听和构件文件1npm run watch 运行单元测试1npm run test 监听和运行测试1npm run watch:test 运行e2e测试1234# 升级Webdriver (可选, 通过postinstall script自动完成)npm run webdriver:update# 启动服务并且启用Protractornpm run e2e 集成测试（一起运行单元测试和e2e测试）12# 测试JIT和AoT buildsnpm run ci 运行Protractor的elementExplorer (为e2e测试)1npm run e2e:live 构件Docker1npm run build:docker 配置 配置文件在config/目录下，一般用 webpack, karma, and protractor 作为项目的脚手架。 AoT禁忌下面是一些会使AoT编译失败的做法： 不需要为模板和样式声明，使用styleUrls and templateUrls，angular2-template-loader插件会在构建时声明； 不要使用默认的exports； 不要用 form.controls.controlName, 使用 form.get(‘controlName’)； 不要用 control.errors?.someError, 使用 control.hasError(‘someError’)； 不要在providers, routes 或者declarations中使用函数, 应该暴露一个函数，然后引用这个函数的名字； @Inputs, @Outputs, View , Content Child(ren), Hostbindings或者任何从模板、注释中使用的字段对Angular都应该是public。 外部样式任何导入到项目中的样式或者在src/styles文件夹下的样式 (Sass 或者 CSS) 都将被编译成外部的 .css 并嵌入你的产品构建。 例如用Bootstrap作为外部样式: 1) 在src/styles文件夹下创建一个 styles.scss 文件 (名字不重要) ； 2) 用 npm install 安装你想要的Boostrap版本； 3) 在 styles.scss 加上 @import &#39;bootstrap/scss/bootstrap.scss&#39;; 4) 在 src/app/app.module.ts 其他声明下面加上: import &#39;../styles/styles.scss&#39;; 贡献你可以用组件的形式引进更多的案例，但是它们必须引入一些新的概念，比如 Home component (独立文件夹)和Todo (服务)。我将会很乐意接受，所以尽情Pull-Request。 TypeScript 全局安装TypeScript，并使用带有TypeScript插件的编辑器，利用自动补全来充分使用TypeScript。 使用最新的TypeScriptTypeScript 2.1.x 包含所有你需要的东西。 请确保升级到这个版本，即使你之前已经安装了TypeScript。 1npm install --global typescript 使用支持TypeScript的编辑器推荐使用下面的编辑器: Visual Studio Code Webstorm 10 带 TypeScript plugin的Atom 带 Typescript-Sublime-Plugin的Sublime Text Visual Studio Code + Debugger for Chrome 安装 Debugger for Chrome ，然后去看操作指南 项目中的 .vscode 会自动连接到webpack development server 的 3000端口。 Types 当你引入一个没有定义类型的模块，你可以用@types引入外部类型定义。 比如，为了让YouTube api运行，在终端中输入下面的命令： 1npm i @types/youtube @types/gapi @types/gapi.youtube 在一些案例中，你的代码编辑器不支持Typescript 2或者这些类型不在tsconfig.json列表内，这时候把这些类型增加到“src/custom-typings.d.ts” 中来帮助编译时检查： 123import '@types/gapi.youtube';import '@types/gapi';import '@types/youtube'; 类型定义习惯如果需要用到第三方模块，当它没有提供类型定义时，同样需要为模块引入类型定义。你可以试着用@types来完成： 12npm install @types/nodenpm install @types/lodash 如果你不能在库中找到对应的类型定义，可以暂时在文件中使用ambient definition ： 123declare module "my-module" &#123; export function doesSomething(value: string): string;&#125; 如果导入的模块是使用Node.js，你需要这样引入： 1import * as _ from 'lodash'; 常见问题 如何知道当前浏览器时候支持Angular2？ 答：请查看这个更新列表：browser support for Angular 2。 为什么服务没有正确注入参数？ 答：请使用 @Injectable() ，以便让TypeScript的服务正确的依附上元数据（这是TypeScript的问题）。 怎么才能用node 0.12.X运行protractor？ 答：请切换到这个仓库以便使用老版本的protractor，参见 #146 在哪里写测试？ 答：可以在组件文件下写你的测试。 例如 /src/app/home/home.component.spec.ts 当报 EACCES 和 EADDRINUSE 错误时，如何启动app？ 答： EADDRINUSE 错误是 3000 端口已经被使用了， EACCES 错误是webpack在./dist/目录下没有权限来构建文件。 如何在css中使用 sass ？ 答：使用loaders: [&#39;raw-loader&#39;,&#39;sass-loader&#39;] 和 @Component({ styleUrls: [&#39;./filename.scss&#39;] }) ，参见 Wiki How to include SCSS in components, 或者 #136 问题。 如何测试服务？ 答：参见 #130 如何增加 vscode-chrome-debug 支持？ 答：VS Code chrome debug 插件的支持可以通过 launch.json 来实现，参见 #144。 如何让这个仓库在虚拟机上运行？ 答：host使用 0.0.0.0 ，参见 #205。 Angular 2的命名约定是什么？ 答：参见 #185 和 196。 如何引入bootstrap或者jQuery？ 答：参见 #215 和#214。 组件如何异步加载？ 答：参见 How-do-I-async-load-a-component-with-AsyncRoute。 Error: Cannot find module ‘tapable’ 答：移除 node_modules/ ，然后运行 npm cache clean ，最后 npm install。 如何开启模块热替换？ 答：运行 npm run server:dev:hmr。 RangeError: Maximum call stack size exceeded 答：这是压缩Angular2和JIT模板时的错误，可以把mangle 设置为false。 为什么app比development大？ 答：因为使用了inline source-maps和模块热替换，这回导致包的大小增加。 如果你在中国，请使用https://github.com/cnpm/cnpm。 如果希望增加Angular 2 Material Design，切换到material2分支。 node-pre-gyp ERR in npm install (Windows) 答：安装Python x86，Windows版本在2.5 和 3.0之间 参见： #626。 Error:Error: Parse tsconfig error [{&quot;messageText&quot;:&quot;Unknown compiler option &#39;lib&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;strictNullChecks&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;baseUrl&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;paths&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;types&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023}] 答：移除 node_modules/typescript ，然后运行 npm install typescript@beta。当前仓库使用的是ts 2.0。 “There are multiple modules with names that only differ in casing” 答：修改 c:\[path to angular2-webpack-starter] 为 C:\[path to angular2-webpack-starter] （c变为大写）参见： 926#issuecomment-245223547。 支持、问题和反馈 对这个项目或者Angular2有任何问题欢迎随时联系我们 Chat: AngularClass.slack Twitter: @AngularClass Gitter: AngularClass/angular2-webpack-starter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之Webpack简介]]></title>
      <url>%2F2017%2F02%2F11%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BWebpack%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[什么是WebpackWebpack是一个强力的模块打包器。 所谓包(bundle)就是一个JavaScript文件，它把一堆资源(assets)合并在一起，以便它们可以在同一个文件请求中发回给客户端。 包中可以包含JavaScript、CSS样式、HTML以及很多其它类型的文件。 Webpack会遍历你应用中的所有源码，查找import语句，构建出依赖图谱，并产出一个(或多个)包。 通过“加载器(loaders)”插件，Webpack可以对各种非JavaScript文件进行预处理和最小化(Minify)，比如TypeScript、SASS和LESS文件等。 我们通过一个JavaScript配置文件webpack.config.js来决定Webpack做什么以及如何做。 入口与输出给webpack提供一个或多个入口文件，通过入口来让它查找与合并那些从这些入口点发散出去的依赖。 123entry: &#123; app: 'src/app.ts'&#125; app.js输出包是个单一的JavaScript文件，它包含程序的源码及其所有依赖。 123output: &#123; filename: 'app.js'&#125; 多重包Webpack会构造出两个独立的依赖图谱，并产出两个包文件：一个叫做app.js，它只包含我们的应用代码；另一个叫做vendor.js，它包含所有的提供商依赖。 123456789entry: &#123; app: 'src/app.ts', vendor: 'src/vendor.ts'&#125;,output: &#123; filename: '[name].js'&#125;//在输出文件名中出现的[name]是一个Webpack的占位符，它将被替换为入口点的名字，分别是app和vendor。 加载器我们要通过加载器来告诉它如何把JavaScript、TypeScript、CSS、SASS、LESS、图片、HTML以及字体文件等处理成JavaScript文件。 12import &#123; AppComponent &#125; from './app.component.ts';import 'uiframework/dist/uiframework.css'; 12345678910loaders: [ &#123; test: /\.ts$/ loaders: 'ts' &#125;, &#123; test: /\.css$/ loaders: 'style!css' &#125;] 第一个import文件匹配上了.ts模式，于是Webpack就用awesome-typescript-loader加载器处理它。 导入的文件没有匹配上第二个模式，于是它的加载器就被忽略了。 第二个import匹配上了第二个.css模式，它有两个用叹号字符(!)串联起来的加载器。 Webpack会从右到左逐个应用串联的加载器，于是它先应用了css加载器(用来平面化CSS的@import和url(...)语句)， 然后应用了style加载器(用来把css追加到页面上的&lt;style&gt;元素中)。 插件Webpack有一条构建流水线，它被划分成多个经过精心定义的阶段(phase)。 我们可以把插件(比如uglify代码最小化插件)挂到流水线上： 123plugins: [ new webpack.optimize.UglifyJsPlugin()] 配置Webpack公共配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566config/webpack.common.jsvar webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');var helpers = require('./helpers');module.exports = &#123; //把应用拆成三个包：1.polyfills：我们在大多数现代浏览器中运行Angular程序时需要的标准填充物；2.vendor：提供商文件；3.app：应用代码。 entry: &#123; 'polyfills': './src/polyfills.ts', 'vendor': './src/vendor.ts', 'app': './src/main.ts' &#125;, //告诉Webpack如何通过查找匹配的文件来解析模块文件的加载请求 resolve: &#123; //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['', '.ts', '.js'] &#125;, //指定指定加载器 module: &#123; loaders: [ &#123; test: /\.ts$/, //awesome-typescript-loader - 一个用于把TypeScript代码转译成ES5的加载器，它会由tsconfig.json文件提供指导;angular2-template-loader - 用于加载Angular组件的模板和样式 loaders: ['awesome-typescript-loader', 'angular2-template-loader']//多重加载器也能使用数组形式串联起来。 &#125;, &#123; test: /\.html$/, //html - 为组件模板准备的加载器 loader: 'html' &#125;, &#123; test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'file?name=assets/[name].[hash].[ext]' &#125;, &#123; test: /\.css$/, //匹配应用级样式,它只包含了那些位于/src及其上级目录的.css文件 exclude: helpers.root('src', 'app'), loader: ExtractTextPlugin.extract('style', 'css?sourceMap') &#125;, &#123; test: /\.css$/, //匹配组件局部样式(就是在组件元数据的styleUrls属性中指定的那些),通过raw加载器把组件局部样式加载成字符串 include: helpers.root('src', 'app'), loader: 'raw' &#125; ] &#125;, plugins: [ //这里标记出了三个块之间的等级体系：app -&gt; vendor -&gt; polyfills。 当Webpack发现app与vendor有共享依赖时，就把它们从app中移除。 在vendor和polyfills之间有共享依赖时也同样如此，把提供商代码排除在app.js包之外 new webpack.optimize.CommonsChunkPlugin(&#123; name: ['app', 'vendor', 'polyfills'] &#125;), //Webpack可以通过HtmlWebpackPlugin自动为我们注入js和css文件的script和link标签。 new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;) ]&#125;; 开发环境配置12345678910111213141516171819202122232425262728config/webpack.dev.jsvar webpackMerge = require('webpack-merge');var ExtractTextPlugin = require('extract-text-webpack-plugin');var commonConfig = require('./webpack.common.js');var helpers = require('./helpers');module.exports = webpackMerge(commonConfig, &#123; devtool: 'cheap-module-eval-source-map', //HtmlWebpackPlugin(由webpack.common.js引入)插件使用了publicPath和filename设置， 来向index.html中插入适当的&lt;script&gt;和&lt;link&gt;标签。 output: &#123; path: helpers.root('dist'), publicPath: 'http://localhost:8080/', filename: '[name].js', chunkFilename: '[id].chunk.js' &#125;, //ExtractTextPlugin会把CSS提取成外部.css文件， 这样HtmlWebpackPlugin插件就会转而把一个&lt;link&gt;标签写进index.html了 plugins: [ new ExtractTextPlugin('[name].css') ], devServer: &#123; historyApiFallback: true, stats: 'minimal' &#125;&#125;); 产品环境配置123456789101112131415161718192021222324252627282930313233343536373839404142434445config/webpack.prod.jsvar webpack = require('webpack');var webpackMerge = require('webpack-merge');var ExtractTextPlugin = require('extract-text-webpack-plugin');var commonConfig = require('./webpack.common.js');var helpers = require('./helpers');const ENV = process.env.NODE_ENV = process.env.ENV = 'production';module.exports = webpackMerge(commonConfig, &#123; devtool: 'source-map', output: &#123; path: helpers.root('dist'), publicPath: '/', filename: '[name].[hash].js', chunkFilename: '[id].[hash].chunk.js' &#125;, htmlLoader: &#123; minimize: false // workaround for ng2 &#125;, plugins: [ //NoErrorsPlugin - 如果出现任何错误，就终止构建。 new webpack.NoErrorsPlugin(), //DedupePlugin - 检测完全相同(以及几乎完全相同)的文件，并把它们从输出中移除。 new webpack.optimize.DedupePlugin(), //UglifyJsPlugin - 最小化(minify)生成的包。 new webpack.optimize.UglifyJsPlugin(&#123; // https://github.com/angular/angular/issues/10618 mangle: &#123; keep_fnames: true &#125; &#125;), //ExtractTextPlugin - 把内嵌的css抽取成外部文件，并为其文件名添加“缓存无效哈希”。当这些哈希值变化时，自动更新index.html。 new ExtractTextPlugin('[name].[hash].css'), //DefinePlugin - 用来定义环境变量，以便我们在自己的程序中引用它。 new webpack.DefinePlugin(&#123; 'process.env': &#123; 'ENV': JSON.stringify(ENV) &#125; &#125;) ]&#125;); 测试环境配置123456789101112131415161718192021222324252627282930313233343536373839config/webpack.test.jsvar helpers = require('./helpers');module.exports = &#123; devtool: 'inline-source-map', resolve: &#123; extensions: ['', '.ts', '.js'] &#125;, module: &#123; loaders: [ &#123; test: /\.ts$/, loaders: ['awesome-typescript-loader', 'angular2-template-loader'] &#125;, &#123; test: /\.html$/, loader: 'html' &#125;, &#123; test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'null' &#125;, &#123; test: /\.css$/, exclude: helpers.root('src', 'app'), loader: 'null' &#125;, &#123; test: /\.css$/, include: helpers.root('src', 'app'), loader: 'raw' &#125; ] &#125;&#125; 如果有可能拖慢执行速度，甚至都不需要在单元测试中加载和处理应用全局样式文件，所以我们用一个null加载器来处理所有CSS。 123456789101112131415161718192021222324252627282930313233343536373839config/karma.conf.jsvar webpackConfig = require('./webpack.test');module.exports = function (config) &#123; var _config = &#123; basePath: '', frameworks: ['jasmine'], files: [ &#123;pattern: './config/karma-test-shim.js', watched: false&#125; ], preprocessors: &#123; './config/karma-test-shim.js': ['webpack', 'sourcemap'] &#125;, webpack: webpackConfig, webpackMiddleware: &#123; stats: 'errors-only' &#125;, webpackServer: &#123; noInfo: true &#125;, reporters: ['progress'], port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: ['PhantomJS'], singleRun: true &#125;; config.set(_config);&#125;; 123456789101112131415161718192021222324config/karma-test-shim.js//karma-test-shim告诉Karma哪些文件需要预加载，首要的是：带有“测试版提供商”的Angular测试框架是每个应用都希望预加载的。Error.stackTraceLimit = Infinity;require('core-js/es6');require('core-js/es7/reflect');require('zone.js/dist/zone');require('zone.js/dist/long-stack-trace-zone');require('zone.js/dist/proxy');require('zone.js/dist/sync-test');require('zone.js/dist/jasmine-patch');require('zone.js/dist/async-test');require('zone.js/dist/fake-async-test');var appContext = require.context('../src', true, /\.spec\.ts/);appContext.keys().forEach(appContext);var testing = require('@angular/core/testing');var browser = require('@angular/platform-browser-dynamic/testing');testing.TestBed.initTestEnvironment(browser.BrowserDynamicTestingModule, browser.platformBrowserDynamicTesting());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[块级元素和行内元素]]></title>
      <url>%2F2017%2F02%2F07%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[知识点虽然小，但是有的时候突然会忘记，记录一下，好记性不如烂笔头，文章参考块级元素。 块级元素 address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 区别1. 块级元素会独占一行，其宽度自动填满其父元素宽度；行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化2. 块级元素可以设置 width, height属性，行内元素设置width, height无效 （注意：块级元素即使设置了宽度，仍然是独占一行的）3. 块级元素可以设置margin 和 padding. 行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）4. 块级元素可以容纳内联元素和其他块元素，内联元素只能容纳文本或者其他内联元素(内联元素中嵌套块级元素时，块级元素无法继承内联元素的属性。) 网上还看到一个知识点，display:inline-block时元素之间默认有一定的间隙，如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo本地搜索无法使用解决办法]]></title>
      <url>%2F2017%2F02%2F05%2Fhexo%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[突然发现博客的本地搜索不能用了，这样就不能搜索学习笔记里面的内容了，这可是大事，得解决。 查找了github上的issues，发现local search这个issue下面有人提到博客搜索无法使用，显示链接是javascript:;，这不就是我的问题吗，但是这个问题有点蛋疼，需要在文章里面一个个找。 最后在hexo文章添加版权声明及一些特效中第二节中找到了这句话，删除后，搜索就可以用啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm中的AngularJS2模板插件使用]]></title>
      <url>%2F2017%2F02%2F03%2FWebstorm%E4%B8%AD%E7%9A%84AngularJS2%E6%A8%A1%E6%9D%BF%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Angular官方文档的风格指南提到使用IDE的模板来实现统一的风格，里面的IDE没有提到WebStorm，于是网上搜了一下相关资料。 安装插件参照WebStorm 最新 2016 AngularJs 2 代码提示插件安装。 在webstorm的setting或者performance（macos）中选择左侧Plugin选项，然后点击Browse repositories。 在搜索框中搜索Angular 2 TypeScript Live Templates，然后点击Install，会提示重启webstorm，重启后就安装好了。 如果电脑上设置了代理，点击左下角的HTTP proxy settings，选择auto-detect proxy settings，然后再进行下载。 使用插件Angular 2 TypeScript Live Templates (Snippets) for WebStorm的github上有使用说明，我按照这个说明演示一下。 TypeScript Snippets插件对于TypeScript有以下指令： 12345678ng2-component-root // Angular 2 root App componentng2-bootstrap // Angular 2 bootstraping, for main.tsng2-component // Angular 2 componentng2-pipe // Angular 2 pipeng2-routes // Angular 2 @Routesng2-route-path // Angular 2 routing pathng2-service // Angular 2 serviceng2-subscribe // Angular 2 observable subscription 指令会有提示，选择相应的指令会生成预设的模板。 HTML Snippets插件对Angular中的以下指令也有提示： 1234567ng2-ngClassng2-ngForng2-ngIfng2-ngModelng2-routerLinkng2-ngStyleng2-ngSwitch]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo文章添加版权声明及一些特效]]></title>
      <url>%2F2017%2F02%2F02%2Fhexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[看到有的博客上有版权声明的标记，感觉有点逼格，就想自己弄一下。 添加版权声明在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。 在网上找到一篇为Hexo博客的每一篇文章自动追加版权信息，可惜我木有成功。有兴趣的可以试一下。 这时候我想起了Hexo+nexT主题搭建个人博客的5.3中有在文章末尾添加“本文结束”标记的介绍。于是我就仿照写了一个版权声明。 新建 passage-end-tag.swig 文件 在路径\themes\next\layout\_macro中添加passage-end-tag.swig文件，其内容为： 123456789101112131415&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束 ------&lt;/div&gt;&lt;br/&gt;&lt;div style="border: 1px solid black"&gt;&lt;div style="margin-left:10px"&gt;&lt;span style="font-weight:blod"&gt;版权声明&lt;/span&gt;&lt;img src="此处填自己版权声明图片地址" &gt;&lt;br/&gt;&lt;p style="font-size: 10px;line-height: 30px"&gt;&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt; by &lt;a href="http://tc9011.com" style="color:#258FC6"&gt;Cheng Tang&lt;/a&gt; is licensed under a &lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6"&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;由&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;汤诚&lt;/a&gt;创作并维护的&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt;博客采用&lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6"&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;本文首发于&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt; 博客（ &lt;a href="http://tc9011.com" style="color:#258FC6"&gt;http://tc9011.com&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 修改 post.swig 文件 在\themes\next\layout\_macro\post.swig中，post-body之后，post-footer之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件中添加字段 在主题配置文件 _config.yml中添加以下字段开启此功能： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。 添加背景动画背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout\_layout.swig的&lt;/body&gt;上面添加 123&#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在\themes\next\_config.yml中添加以下字段开启此功能： 1234# background settings# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css\_schemes\Pisces\_layout.styl中，把.content-wrap中的background修改为none。 这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。 附上我的.content-wrap配置： 1234567891011121314151617181920212223.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: none; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() &#123; width: 100%; padding: 20px; border-radius: initial; &#125; +mobile() &#123; width: 100%; padding: 20px; min-height: auto; border-radius: initial; background: white; &#125;&#125; 修改一些样式never_yu‘Blog中的文章添加许多样式，看了一下github上的源码，在 themes\next\source\css\_custom\custom.styl 中，添加如下css： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359//修改文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125;//修改不在文章内的链接文本样式.link-blue&#123; color: #f36; &amp;:hover &#123; color: #f00; &#125;&#125;//修改文章内code样式code &#123;color:#fff;background:#333;&#125;//修改文章中图片样式，改为居中.posts-expand .post-body img &#123; margin: 0 auto;&#125;// 下载样式a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125;&#125;//阅读全文样式.post-more-link .btn &#123; position:relative; border: 2px solid #000; border-radius: 2px; padding: 0 10px; font-weight: bold; background: transparent; transition: all .5s ease; &amp;:hover &#123; background: #000; color: #eee; &#125;&#125;//// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-黑span#inline-black &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: black;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125;// 颜色块-红span#inline-red &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #df3e3e;&#125;// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125;//动画模块//第一篇博客中-精于心，简于形-的动画（https://neveryu.github.io/page/2/）span#yu-1 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:110%; cursor:pointer; &amp;:hover &#123; background-color: #000; color: #fff; animation: animate-yu-1 3s ease-in; &#125;&#125;@keyframes animate-yu-1 &#123; 0% &#123; left:-10px; top:0px; &#125; 10% &#123; left:10px; top:0px; &#125; 20% &#123; left:-8px; top:0px; &#125; 30% &#123; left:8px; top:0px; &#125; 40% &#123; left:-5px; top:0px; &#125; 50% &#123; left:5px; top:0px; &#125; 60% &#123; left:-3px; top:0px; &#125; 70% &#123; left:3px; top:0px; &#125; 80% &#123; left:-1px; top:0px; &#125; 90% &#123; left:1px; top:0px; &#125; 100% &#123; left:0px; top:0px; &#125;&#125;//留言页面-[最近访客]-的样式span#yu-2 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:130%;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之风格指南]]></title>
      <url>%2F2017%2F02%2F01%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[单一职责单一法则坚持每个文件只定义一样东西（例如服务或组件）。 考虑把文件大小限制在 400 行代码以内。 简单函数坚持定义简单函数 考虑限制在 75 行之内。 命名总体命名指导原则坚持所有符号使用一致的命名规则。 坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为feature.type.ts。 使用点和横杠分隔文件名坚持 在描述性名字中，用横杠来分隔单词。 坚持使用点来分隔描述性名字和类型。 坚持遵循先描述组件特性，再描述它的类型的模式，对所有组件使用一致的类型命名规则。推荐的模式为feature.type.ts。 坚持使用惯用的后缀来描述类型，包括*.service、*.component、*.pipe、.module、.directive。 必要时可以创建更多类型名，但必须注意，不要创建太多。 符号名与文件名坚持为所有东西使用一致的命名约定，以它们所代表的东西命名。 坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。 坚持在符号名后面追加约定的类型后缀（例如Component、Directive、Module、Pipe、Service）。 坚持在文件名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。 服务名坚持使用一致的规则命名服务，以它们的特性来命名。 坚持使用大写驼峰命名法命名服务。 坚持添加Service后缀，当不清楚它们是什么时（例如当它们是名词时）。 引导坚持把应用的引导程序和平台相关的逻辑放到名为main.ts的文件里。 坚持在引导逻辑中包含错误处理代码。 避免把应用逻辑放在main.ts中，而应放在组件或服务里。 指令选择器坚持使用小驼峰命名法来命名指令的选择器。 为组件添加自定义前缀坚持使用带连字符的小写元素选择器值（例如admin-users）。 坚持为组件选择器添加自定义前缀。 例如，toh前缀表示 Tour of Heroes（英雄指南），而前缀`admin表示管理特性区。 坚持使用前缀来识别特性区或者应用程序本身。 为指令添加自定义前缀坚持为指令的选择器添加自定义前缀（例如前缀toh来自Tour of Heroes）。 坚持用小驼峰形式拼写非元素选择器，除非该选择器用于匹配原生 HTML 属性。 管道名坚持为所有管道使用一致的命名约定，用它们的特性来命名。 单元测试文件名坚持测试规格文件名与被测试组件文件名相同。 坚持测试规格文件名添加.spec后缀。 端到端测试文件名坚持端到端测试规格文件和它们所测试的特性同名，添加.e2e-spec后缀。 Angular NgModule 命名坚持为符号名添加Module后缀 坚持为文件名添加.module.ts扩展名。 坚持用特性名和所在目录命名模块。 坚持为 RoutingModule 类名添加RoutingModule后缀。 坚持为 RoutingModule 的文件名添加-routing.module.ts后缀。 代码约定类坚持使用大写驼峰命名法来命名类。 常量坚持用const声明变量，除非它们的值在应用的生命周期内会发生变化。 考虑 把常量名拼写为小驼峰格式。 坚持容许现存的const常量沿用大写蛇形命名法。 123export const mockHeroes = ['Sam', 'Jill']; // preferexport const heroesUrl = 'api/heroes'; // preferexport const VILLAINS_URL = 'api/villains'; // tolerate 接口坚持使用大写驼峰命名法来命名接口。 考虑不要在接口名字前面加I前缀。（TypeScript 指导原则不建议使用 “I” 前缀。） 考虑用类代替接口。（单独一个类的代码量小于类+接口；类可以作为接口使用，只是用implements代替extends而已；在 Angular 依赖注入系统中，接口类可以作为服务提供商的查找令牌。） 属性和方法坚持使用小写驼峰命名法来命名属性和方法。 避免为私有属性和方法添加下划线前缀。 导入语句中的空行坚持在第三方导入和应用导入之间留一个空行。 考虑按模块名字的字母顺排列导入行。 考虑在解构表达式中按字母顺序排列导入的东西。 应用结构与Angular模块所有应用程序的源代码都放到名叫app的目录里。 所有特性区都在自己的文件夹中，带有它们自己的 Angular 模块。 所有内容都遵循每个文件一个特性的原则。每个组件、服务和管道都在自己的文件里。 所有第三方程序包保存到其它目录里，不是app目录。 LIFT坚持组织应用的结构，达到这些目的：快速定位 (Locate) 代码、一眼识别 (Identify) 代码、 尽量保持扁平结构 (Flattest) 和尝试 (Try) 遵循DRY (Do Not Repeat Yourself, 不重复自己) 原则。 坚持四项基本原则定义文件结构，上面的原则是按重要顺序排列的。 定位坚持直观、简单和快速地定位代码。 识别坚持命名文件到这个程度：看到名字立刻知道它包含了什么，代表了什么。 坚持文件名要具有说明性，确保文件中只包含一个组件。 避免创建包含多个组件、服务或者混合体的文件。 扁平坚持尽可能保持扁平的目录结构。 考虑当同一目录下达到 7 个或更多个文件时创建子目录。 考虑配置 IDE，以隐藏无关的文件，例如生成出来的.js文件和.js.map文件等。 T-DRY （尝试不重复自己）坚持 DRY（Don’t Repeat Yourself，不重复自己）。 避免过度 DRY，以致牺牲了阅读性。 总体结构指导原则坚持从零开始，但要考虑应用程序接下来的路往哪儿走。 坚持有一个近期实施方案和一个长期的愿景。 坚持把所有源代码都放到名为app的目录里。 坚持如果组件具有多个伴隨文件 (.ts、.html、.css和.spec)，就为它创建一个文件夹。 下面是符合规范的目录和文件结构： 按特性组织的目录结构坚持根据特性区命名目录。 坚持为每个特性区创建一个 Angular 模块。 应用的根模块坚持在应用的根目录创建一个 Angular 模块（例如/app）。 考虑把根模块命名为app.module.ts。 特性模块坚持为应用中每个明显的特性创建一个 Angular 模块。 坚持把特性模块放在与特性区同名的目录中（例如app/heroes）。 坚持特性模块的文件名应该能反映出特性区的名字和目录（例如app/heroes/heroes.module.ts）。 坚持特性模块的符号名应该能反映出特性区、目录和文件名（例如在app/heroes/heroes.module.ts中定义HeroesModule）。 共享特性模块坚持在shared目录中创建名叫SharedModule的特性模块（例如在app/shared/shared.module.ts中定义SharedModule）。 坚持把可能被应用其它特性模块使用的公共组件、指令和管道放在SharedModule中，这些资产倾向于共享自己的新实例（而不是单例）。 坚持在SharedModule中导入所有模块都需要的资产（例如CommonModule和FormsModule）。 坚持在SharedModule中声明所有组件、指令和管道。 坚持从SharedModule中导出其它特性模块所需的全部符号。 避免在SharedModule中指定应用级的单例服务提供商。但如果是故意设计的单例也可以，不过还是要小心。 核心特性模块坚持把那些“只用一次”的类收集到CoreModule中，并对外隐藏它们的实现细节。简化的AppModule会导入CoreModule，并且把它作为整个应用的总指挥。 坚持在core目录下创建一个名叫CoreModule的特性模块（例如在app/core/core.module.ts中定义CoreModule）。 坚持把一个要共享给整个应用的单例服务放进CoreModule中（例如ExceptionService和LoggerService）。 坚持导入CoreModule中的资产所需要的全部模块（例如CommonModule和FormsModule）。 坚持把应用级、只用一次的组件收集到CoreModule中。 只在应用启动时从AppModule中导入它一次，以后再也不要导入它（例如NavComponent和SpinnerComponent）。 避免在AppModule之外的任何地方导入CoreModule。 坚持从CoreModule中导出AppModule需导入的所有符号，使它们在所有特性模块中可用。 防止多次导入CoreModule坚持防范多次导入CoreModule，并通过添加守卫逻辑来尽快失败。(守卫可以阻止对CoreModule的多次导入,守卫会禁止创建单例服务的多个实例。) 1234567app/core/module-import-guard.tsexport function throwIfAlreadyLoaded(parentModule: any, moduleName: string) &#123; if (parentModule) &#123; throw new Error(`$&#123;moduleName&#125; has already been loaded. Import Core modules in the AppModule only.`); &#125;&#125; 惰性加载的目录坚持把惰性加载特性下的内容放进惰性加载目录中。 典型的惰性加载目录包含路由组件及其子组件以及与它们有关的那些资产和模块。 永远不要直接导入惰性加载的目录避免让兄弟模块和父模块直接导入惰性加载特性中的模块。 组件组件选择器命名坚持使用中线 (dashed) 命名法或烤串 (kebab) 命名法来命名组件中的元素选择器。 把组件当做元素坚持通过选择器把组件定义为元素。 把模板和样式提取到它们自己的文件坚持当超过 3 行时，把模板和样式提取到一个单独的文件。 坚持把模板文件命名为[component-name].component.html，其中，[component-name] 是组件名。 坚持把样式文件命名为[component-name].component.css，其中，[component-name] 是组件名。 内联输入和输出属性装饰器坚持 使用@Input和@Output，而非@Directive和@Component装饰器的inputs和outputs属性: 坚持把@Input()或者@Output()放到所装饰的属性的同一行。 避免重命名输入和输出避免重命名输入和输出。 成员顺序坚持把属性成员放在前面，方法成员放在后面。 坚持先放公共成员，再放私有成员，并按照字母顺序排列。 12345678910111213141516171819202122232425262728293031export class ToastComponent implements OnInit &#123; // public properties message: string; title: string; // private fields private defaults = &#123; title: '', message: 'May the Force be with You' &#125;; private toastElement: any; // public methods activate(message = this.defaults.message, title = this.defaults.title) &#123; this.title = title; this.message = message; this.show(); &#125; ngOnInit() &#123; this.toastElement = document.getElementById('toh-toast'); &#125; // private methods private hide() &#123; this.toastElement.style.opacity = 0; window.setTimeout(() =&gt; this.toastElement.style.zIndex = 0, 400); &#125; private show() &#123; console.log(this.message); this.toastElement.style.opacity = 1; this.toastElement.style.zIndex = 9999; window.setTimeout(() =&gt; this.hide(), 2500); &#125;&#125; 把逻辑放到服务里坚持在组件中只包含与视图相关的逻辑。所有其它逻辑都应该放到服务中。 坚持把可重用的逻辑放到服务中，保持组件简单，聚焦于它们预期目的。 不要给输出属性加前缀坚持命名事件时，不要带前缀on。 坚持把事件处理器方法命名为on前缀之后紧跟着事件名。 12345export class HeroComponent &#123; @Output() savedTheDay = new EventEmitter&lt;boolean&gt;();&#125;&lt;toh-hero (savedTheDay)="onSavedTheDay($event)"&gt;&lt;/toh-hero&gt; 把表现层逻辑放到组件类里坚持把表现层逻辑放进组件类中，而不要放在模板里。 指令使用指令来加强已有元素坚持当你需要有表现层逻辑，但没有模板时，使用属性型指令。 使用 HostListener 和 HostBinding 类装饰器考虑优先使用@HostListener和@HostBinding，而不是@Directive和@Component装饰器的host属性。 坚持让你的选择保持一致。 12345678910import &#123; Directive, HostBinding, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[tohValidator]'&#125;)export class ValidatorDirective &#123; @HostBinding('attr.role') role = 'button'; @HostListener('mouseenter') onMouseEnter() &#123; // do work &#125;&#125; 服务注入器中，服务总是单例的坚持在同一个注入器内，把服务当做单例使用。用它们来共享数据和功能。 单一职责坚持创建单一职责的服务，用职责封装在它的上下文中。 坚持当服务成长到超出单一用途时，创建一个新服务。 提供一个服务坚持将服务提供到共享范围内的顶级组件的 Angular 注入器。 使用 @Injectable() 类装饰器坚持当使用类型作为令牌来注入服务的依赖时，使用@Injectable类装饰器，而非@Inject参数装饰器。 数据服务分离数据调用坚持把数据操作和互动重构到服务里。 坚持让数据服务来负责 XHR 调用、本地储存、内存储存或者其它数据操作。 生命周期钩子使用生命周期钩子来介入到 Angular 暴露的重要事件里。 实现生命周期钩子接口坚持实现生命周期钩子接口。 附录Codelyzer坚持使用 codelyzer 来实施本指南。 考虑调整 codelyzer 的规则来满足你的需求。 文档模板和代码片段坚持使用文件模板或代码片段来帮助实现一致的风格和模式。 考虑使用 Visual Studio Code的代码片段 来实施本风格指南。 考虑使用 Atom 的代码片断来实施本风格指南。 考虑使用 Sublime Text的代码片断 来实施本风格指南。 考虑使用 Vim 的代码片断来实施本风格指南。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之开发指南]]></title>
      <url>%2F2017%2F01%2F31%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[根模块import数组12345678910import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser'; //必须要有import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; imports: [ BrowserModule ], declarations: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; Angular 模块的imports数组与文件顶部的import语句功能是不同的。 JavaScript 的import声明允许你访问在其他文件中导出的符号，这样你可以在当前文件引用它们。 它们与 Angular 毫无关系，Angular 对它们也一无所知。 模块的imports数组声明的组件模板需要的类所在的其它模块（引入所需的其他模块的组件模板），告诉 Angular 特定 Angular 模块的信息 — 用@NgModule装饰的类 — 应用需要它们来正常工作。 declarations数组声明本模块中拥有的视图类（组件、指令和管道）。 bootstrap数组引导根模块来启动应用，数组中的组件是插入到浏览器的DOM中的。 每个被引导的组件都是它自己的组件树的根。 插入一个被引导的组件通常触发一系列组件的创建并形成组件树。 在main.ts中引导1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); 通过动态 (JiT) 编译创建浏览器平台来引导根模块。根模块调用组件，插入到组件选择器中。 显示数据使用插值表达式显示组件属性通过插值表达式 (interpolation) 来绑定属性名。要使用插值表达式，就把属性名包裹在双花括号里放进视图模板。 Angular 在index.html中查找一个&lt;my-app&gt;元素， 然后实例化一个AppComponent，并将其渲染到&lt;my-app&gt;标签中。不需要通过new来实例化AppComponent类。 通过构造函数来声明和初始化属性。 使用ngFor显示数组属性ngFor用于显示一个“数组”， 但ngFor可以为任何可迭代的 (iterable)对象重复渲染条目。 应用代码最好不要直接在组件内部直接定义数据。用一个 TypeScript 类来为我们的组件描述模型数据并显示模型的属性。 12345export class Hero &#123; constructor( public id: number, public name: string) &#123; &#125;&#125; 1234567heroes = [ new Hero(1, 'Windstorm'), new Hero(13, 'Bombasto'), new Hero(15, 'Magneta'), new Hero(20, 'Tornado')];myHero = this.heroes[0]; 通过 NgIf 进行条件显示NgIf中Angular 并不是在显示和隐藏这条消息，它是在从 DOM 中添加和移除这个段落元素。 用户输入绑定到用户输入事件使用Angular 事件绑定机制来响应任何 DOM 事件。要绑定 DOM 事件，只要把 DOM 事件的名字包裹在圆括号中，然后用放在引号中的模板语句对它赋值就可以了。 通过 $event 对象取得用户输入（不推荐）下面的代码监听keyup事件，并将整个事件载荷 ($event) 传递给组件的事件处理器。当用户按下并释放一个按键时，触发keyup事件，Angular 在$event变量提供一个相应的 DOM 事件对象，上面的代码将它作为参数传递给onKey()方法。 1234template: ` &lt;input (keyup)="onKey($event)"&gt; &lt;p&gt;&#123; &#123;values&#125; &#125;&lt;/p&gt;` 1234567export class KeyUpComponent_v1 &#123; values = ''; onKey(event:any) &#123; // without type info this.values += event.target.value + ' | '; &#125;&#125; $event对象的属性取决于 DOM 事件的类型。所有标准 DOM 事件对象都有一个target属性， 引用触发该事件的元素。 在本例中，target是&lt;input&gt;元素， value.target.value返回该元素的当前内容。 event.key可以用来记录每次按键本身。 $event的类型是KeyboardEvent。 不是所有的元素都有value属性，所以它将target转换为输入元素。 OnKey方法更加清晰的表达了它期望从模板得到什么，以及它是如何解析事件的。 1234567export class KeyUpComponent_v1 &#123; values = ''; onKey(event: KeyboardEvent) &#123; // with type info this.values += (&lt;HTMLInputElement&gt;event.target).value + ' | '; &#125;&#125; 传入 $event 是靠不住的做法，反对把整个 DOM 事件传到方法中，因为这样组件会知道太多模板的信息。 只有当它知道更多它本不应了解的 HTML 实现细节时，它才能提取信息。 这就违反了模板（用户看到的）和组件（应用如何处理用户数据）之间的分离关注原则。(事件一定要定义类型)。 从一个模板引用变量中获得用户输入使用 Angular 的模板引用变量。 这些变量提供了从模块中直接访问元素的能力。 在标识符前加上井号 (#) 就能声明一个模板引用变量。 12345678@Component(&#123; selector: 'loop-back', template: ` &lt;input #box (keyup)="0"&gt; //(keyup)="0"可以当成将keyup事件初始化 &lt;p&gt;&#123; &#123;box.value&#125; &#125;&lt;/p&gt; `&#125;)export class LoopbackComponent &#123; &#125; 这个模板引用变量名叫box，在&lt;input&gt;元素声明，它引用&lt;input&gt;元素本身。 代码使用box获得输入元素的value值，并通过插值表达式把它显示在&lt;p&gt;标签中。 这个模板完全是完全自包含的。它没有绑定到组件，组件也没做任何事情。 只有在应用做了些异步事件（如击键），Angular 才更新绑定（并最终影响到屏幕）。 本例代码将keyup事件绑定到了数字0，这是可能是最短的模板语句。 虽然这个语句不做什么，但它满足 Angular 的要求，所以 Angular 将更新屏幕。 12345678910111213@Component(&#123; selector: 'key-up2', template: ` &lt;input #box (keyup)="onKey(box.value)"&gt; &lt;p&gt;&#123; &#123;values&#125; &#125;&lt;/p&gt; `&#125;)export class KeyUpComponent_v2 &#123; values = ''; onKey(value: string) &#123; this.values += value + ' | '; &#125;&#125; 组件代码从视图中获得了干净的数据值。再也不用了解$event变量及其结构了。 按键事件过滤（通过key.enter）(keyup)事件处理器监听每一次按键。 有时只在意回车键，因为它标志着用户结束输入。 解决这个问题的一种方法是检查每个$event.keyCode，只有键值是回车键时才采取行动。 更简单的方法是：绑定到 Angular 的keyup.enter 模拟事件。 然后，只有当用户敲回车键时，Angular 才会调用事件处理器。 1234567891011@Component(&#123; selector: 'key-up3', template: ` &lt;input #box (keyup.enter)="onEnter(box.value)"&gt; &lt;p&gt;&#123; &#123;value&#125; &#125;&lt;/p&gt; `&#125;)export class KeyUpComponent_v3 &#123; value = ''; onEnter(value: string) &#123; this.value = value; &#125;&#125; 失去焦点事件 (blur)1234567891011121314@Component(&#123; selector: 'key-up4', template: ` &lt;input #box (keyup.enter)="update(box.value)" (blur)="update(box.value)"&gt; //监听失去焦点事件 &lt;p&gt;&#123; &#123;value&#125; &#125;&lt;/p&gt; `&#125;)export class KeyUpComponent_v4 &#123; value = ''; update(value: string) &#123; this.value = value; &#125;&#125; 小结1234567891011121314151617181920@Component(&#123; selector: 'little-tour', template: ` &lt;input #newHero (keyup.enter)="addHero(newHero.value)" (blur)="addHero(newHero.value); newHero.value='' "&gt; &lt;button (click)=addHero(newHero.value)&gt;Add&lt;/button&gt; &lt;ul&gt;&lt;li *ngFor="let hero of heroes"&gt;&#123; &#123;hero&#125; &#125;&lt;/li&gt;&lt;/ul&gt; `&#125;)export class LittleTourComponent &#123; heroes = ['Windstorm', 'Bombasto', 'Magneta', 'Tornado']; addHero(newHero: string) &#123; if (newHero) &#123; this.heroes.push(newHero); &#125; &#125;&#125; 使用模板变量来引用元素 — newHero模板变量引用了&lt;input&gt;元素。 你可以在&lt;input&gt;的任何兄弟或子级元素中引用newHero。 传递数值，而非元素 — 获取输入框的值并将它传递给组件的addHero，而不要传递newHero。 保持模板语句简单 — (blur)事件被绑定到两个 JavaScript 语句。 第一句调用addHero。第二句newHero.value=&#39;&#39;在添加新英雄到列表中后清除输入框。 表单创建 Hero 模型类12345678export class Hero &#123; constructor( public id: number, public name: string, public power: string, public alterEgo?: string //?表示alterEgo是可选的，调用构造函数时可省略 ) &#123; &#125;&#125; 创建表单组件12345678910111213141516import &#123; Component &#125; from '@angular/core';import &#123; Hero &#125; from './hero';@Component(&#123; moduleId: module.id, selector: 'hero-form', templateUrl: 'hero-form.component.html'&#125;)export class HeroFormComponent &#123; powers = ['Really Smart', 'Super Flexible', 'Super Hot', 'Weather Changer']; model = new Hero(18, 'Dr IQ', this.powers[0], 'Chuck Overstreet'); submitted = false; onSubmit() &#123; this.submitted = true; &#125; // TODO: Remove this when we're done get diagnostic() &#123; return JSON.stringify(this.model); &#125;&#125; 创建初始 HTML 表单模板1234567891011121314&lt;div class="container"&gt; &lt;h1&gt;Hero Form&lt;/h1&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control" id="name" required&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt; &lt;input type="text" class="form-control" id="alterEgo"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; Name &lt;input&gt;控件具有 HTML5 的required属性。container、form-group、form-control和btn类来自 Twitter Bootstrap。 添加样式表。 在应用的根目录下打开终端窗口，输入如下命令： 1npm install bootstrap --save 打开index.html文件并且把下列链接添加到&lt;head&gt;中。 1&lt;link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css"&gt; 使用 ngModel 进行双向数据绑定1234&lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name"&gt; TODO: remove this: &#123; &#123;model.name&#125; &#125; &lt;input&gt;标签还添加了name属性 (attribute)，并设置为 “name”，表示英雄的名字。 使用任何唯一的值都可以，但使用具有描述性的名字会更有帮助。 当在表单中使用[(ngModel)]时，必须要定义name属性。 1234567891011121314151617181920&#123; &#123;diagnostic&#125; &#125; &lt;!--反映出诊断信息--&gt;&lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt; &lt;input type="text" class="form-control" id="alterEgo" [(ngModel)]="model.alterEgo" name="alterEgo"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="power"&gt;Hero Power&lt;/label&gt; &lt;select class="form-control" id="power" required [(ngModel)]="model.power" name="power"&gt; &lt;option *ngFor="let pow of powers" [value]="pow"&gt;&#123; &#123;pow&#125; &#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 每个 input 元素都有id属性，label元素的for属性用它来匹配到对应的输入控件。 每个 input 元素都有name属性，Angular 表单用它注册控件。 在属性绑定中，值从模型中流动到屏幕上的目标属性 (property)。 通过把属性名括在方括号中来标记出目标属性，[]。 这是从模型到视图的单向数据绑定。 在事件绑定中，值从屏幕上的目标属性流动到模型。 通过把属性名括在圆括号中来标记出目标属性，()。 这是从视图到模型的反向单向数据绑定。 Angular 选择了组合标点 [()] 来标记出双向数据绑定和双向数据流。 123[(ngModel)] = 'model.name' 等同于[ngModel]="model.name" name="name" +(ngModelChange)="model.name = $event" ngModelChange并不是&lt;input&gt;元素的事件。 它实际上是来自NgModel指令的事件属性。 当 Angular 在表单中看到[(x)]的绑定目标时， 它会期待这个x指令有一个名为x的输入属性，和一个名为xChange的输出属性。 通过 ngModel 跟踪修改状态与有效性验证在表单中使用ngModel可以获得比仅使用双向数据绑定更多的控制权。 NgModel 指令不仅仅跟踪状态。它还使用特定的 Angular CSS 类来更新控件，以反映当前状态。 可以利用这些 CSS 类来修改控件的外观，显示或隐藏消息。 12345&lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name" #spy &gt;&lt;br&gt;TODO: remove this: &#123; &#123;spy.className&#125; &#125; spy.className输出当前状态下的class。在表单中不同状态下，Angular会赋予特定的css类。 添加用于视觉反馈的自定义 CSS1234567.ng-valid[required], .ng-valid.required &#123; border-left: 5px solid #42A948; /* green */&#125;.ng-invalid:not(form) &#123; border-left: 5px solid #a94442; /* red */&#125; 这些样式的作用于两个 Angular 有效性类和 HTML 5 的 “required” 属性。 显示和隐藏验证错误信息123456789&lt;label for="name"&gt;Name&lt;/label&gt;&lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name" #name="ngModel" &gt;&lt;div [hidden]="name.valid || name.pristine" class="alert alert-danger"&gt; Name is required&lt;/div&gt; 模板引用变量可以访问模板中输入框的 Angular 控件。 这里，创建了名叫name的变量，并且赋值为 “ngModel”。把name设置为ngModel是因为ngModel指令的exportAs属性设置成了 “ngModel”。 [hidden]把属性hidden绑定到模板变量为name的属性。当控件是有效的 (valid) 或全新的 (pristine) 时，隐藏消息。 “全新的”意味着从它被显示在表单中开始，用户还从未修改过它的值（即页面一打开时，就隐藏提示信息）。 添加英雄及重置表单更换了英雄并不会重置控件的“全新”状态，在调用newHero()方法后调用表单的reset()方法即可清除所有标记。 1&lt;button type="button" class="btn btn-default" (click)="newHero(); heroForm.reset()"&gt;New Hero&lt;/button&gt; 使用 ngSubmit 提交表单1&lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt; 定义了模板变量heroForm，并初始化为ngForm。heroForm变量引用的是NgForm指令，它代表的是表单的整体。 NgForm指令为form元素扩充了额外的特性。 它持有通过ngModel指令和name属性为各个元素创建的那些控件，并且监视它们的属性变化，包括有效性。 它还有自己的valid属性，只有当其中所有控件都有效时，它才有效。 1&lt;button type="submit" class="btn btn-default" [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt; 通过heroForm变量把按钮的disabled属性绑定到表单的整体有效性。 切换两个表单区域12345678&lt;div [hidden]="submitted"&gt; &lt;h1&gt;Hero Form&lt;/h1&gt; &lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt; &lt;!-- ... all of the form ... --&gt; &lt;/form&gt;&lt;/div&gt; 把div的hidden属性绑定到HeroFormComponent.submitted属性。主表单从一开始就是可见的，因为submitted属性是 false，直到提交了这个表单。 1234567891011121314151617&lt;div [hidden]="!submitted"&gt; &lt;h2&gt;You submitted the following:&lt;/h2&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;Name&lt;/div&gt; &lt;div class="col-xs-9 pull-left"&gt;&#123; &#123; model.name &#125; &#125;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;Alter Ego&lt;/div&gt; &lt;div class="col-xs-9 pull-left"&gt;&#123; &#123; model.alterEgo &#125; &#125;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;Power&lt;/div&gt; &lt;div class="col-xs-9 pull-left"&gt;&#123; &#123; model.power &#125; &#125;&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;button class="btn btn-default" (click)="submitted=false"&gt;Edit&lt;/button&gt;&lt;/div&gt; 当表单处于已提交状态时，submitted属性是true，hidden属性为false，通过差值表达式把已填内容显示为只读内容。 依赖注入为什么需要依赖注入？依赖注入是一种编程模式，可以让类从外部源中获得它的依赖，而不必亲自创建它们。 一个对象不需要知道如何创建另外的对象，只需简单地请求想要什么，注入器就会交付给它们。 Angular 依赖注入在服务中暴露获取数据的方法，通过注册provider来配置注入器。provider为应用创建所需服务。 NgModule 中的provider是被注册到根注入器。这意味着在 NgModule 中注册的provider可以被整个应用访问。 在应用组件中注册的provider只在该组件及其子组件中可用。 构造函数参数类型中引入所需的服务。 构造函数参数类型、@Component装饰器和父级的providers信息合起来告诉 Angular 的注入器， 任何新建HeroListComponent的时候，注入一个HeroService的实例。 Angular DI 是一个分层的依赖注入系统，这意味着嵌套的注入器可以创建它们自己的服务实例。 设计一个适合依赖注入的类，可以让这个类更容易测试。 要有效的测试应用中的一部分，只需要在构造函数的参数中列出依赖。 1234567let expectedHeroes = [&#123;name: 'A'&#125;, &#123;name: 'B'&#125;]let mockService = &lt;HeroService&gt; &#123;getHeroes: () =&gt; expectedHeroes &#125;it('should have heroes when HeroListComponent created', () =&gt; &#123; let hlc = new HeroListComponent(mockService); expect(hlc.heroes.length).toEqual(expectedHeroes.length);&#125;); 当服务需要别的服务时，同样用构造函数注入模式添加所需服务。 @Injectable() 标识一个类可以被注入器实例化。 通常，在试图实例化没有被标识为@Injectable()的类时，注入器会报错。 每个服务类都添加@Injectable()，包括那些没有依赖严格来说并不需要它的。 @Component（和随后将会学到的@Directive和@Pipe一样）是 Injectable的子类型。 在运行时，注入器可以从编译后的 JavaScript 代码中读取类的元数据， 并使用构造函数的参数类型信息来决定注入什么。 总是使用@Injectable()的形式，不能只用@Injectable。 如果忘了括号，应用就会神不知鬼不觉的失败！ 注入器的提供商们提供商提供依赖值的一个具体的、运行时的版本。 注入器依靠提供商创建服务的实例，注入器再将服务的实例注入组件或其它服务。 必须为注入器注册一个服务的提供商，否则它不知道该如何创建该服务。 Provider类和 provide对象常量providers: [Logger]这其实是用于注册提供商的简写表达式。 使用的是一个带有两个属性的提供商对象字面量：[{ provide: Logger, useClass: Logger }]。 第一个是令牌 (token)，它作为键值 (key) 使用，用于定位依赖值和注册提供商。 第二个是供应商定义对象。 可以把它看做是指导如何创建依赖值的配方。 备选的类提供商某些时候，我们会请求一个不同的类来提供服务。 下列代码告诉注入器，当有人请求Logger时，返回BetterLogger。 1[&#123; provide: Logger, useClass: BetterLogger &#125;] 别名类提供商123[ NewLogger, // Alias OldLogger w/ reference to NewLogger &#123; provide: OldLogger, useExisting: NewLogger&#125;] 使用useExisting选项指定别名，实现在同时存在新老类的情况下，使用老类名称的时候也能调用新类的功能。 值提供商有时，提供一个预先做好的对象会比请求注入器从类中创建它更容易。 12345// An object in the shape of the logger servicelet silentLogger = &#123; logs: ['Silent logger says "Shhhhh!". Provided via "useValue"'], log: () =&gt; &#123;&#125;&#125;; 可以通过useValue选项来注册提供商，它会让这个对象直接扮演 logger 的角色。 1[&#123; provide: Logger, useValue: silentLogger &#125;] 工厂提供商有时，我们需要动态创建这个依赖值，因为它所需要的信息直到最后一刻才能确定。 也许这个信息会在浏览器的会话中不停地变化。还假设这个可注入的服务没法通过独立的源访问此信息。这种情况下使用工厂提供商。 构造函数带上一个布尔型的标志，来控制是否显示隐藏的英雄。 123456789constructor( //服务中的构造函数 private logger: Logger, private isAuthorized: boolean) &#123; &#125;getHeroes() &#123; let auth = this.isAuthorized ? 'authorized ' : 'unauthorized'; this.logger.log(`Getting heroes for $&#123;auth&#125; user.`); return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);&#125; 我们可以注入Logger，但是不能注入逻辑型的isAuthorized。 我们不得不通过通过工厂提供商创建这个HeroService的新实例。工厂提供商需要一个工厂方法： 123let heroServiceFactory = (logger: Logger, userService: UserService) =&gt; &#123; return new HeroService(logger, userService.user.isAuthorized);&#125;; 虽然HeroService不能访问UserService，但是工厂方法可以。同时把Logger和UserService注入到工厂提供商中，并且让注入器把它们传给工厂方法： 12345export let heroServiceProvider = &#123; provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService] &#125;; useFactory字段告诉 Angular：这个提供商是一个工厂方法，它的实现是heroServiceFactory。 deps属性是提供商令牌数组。 Logger和UserService类作为它们自身类提供商的令牌。 注入器解析这些令牌，把相应的服务注入到工厂函数中相应的参数中去。 注意，我们在一个导出的变量中捕获了这个工厂提供商：heroServiceProvider。 这个额外的步骤让工厂提供商可被复用。 无论哪里需要，都可以使用这个变量注册HeroService。 依赖注入令牌当向注入器注册提供商时，实际上是把这个提供商和一个 DI 令牌关联起来了。 注入器维护一个内部的令牌-提供商映射表，这个映射表会在请求依赖时被引用到。 令牌就是这个映射表中的键值。 在前面的所有例子中，依赖值都是一个类实例，并且类的类型作为它自己的查找键值。 在下面的代码中，HeroService类型作为令牌，直接从注入器中获取HeroService 实例： 1heroService: HeroService = this.injector.get(HeroService); 编写需要基于类的依赖注入的构造函数对我们来说是很幸运的。 只要定义一个HeroService类型的构造函数参数， Angular 就会知道把跟HeroService类令牌关联的服务注入进来： 1constructor(heroService: HeroService) 非依赖类注入的东西是一个字符串，函数或者对象时，需要定义和使用 OpaqueToken（不透明的令牌）。 123import &#123; OpaqueToken &#125; from '@angular/core';export let APP_CONFIG = new OpaqueToken('app.config'); 使用这个OpaqueToken对象注册依赖的提供商： 1providers: [&#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;] 在@Inject装饰器的帮助下，这个配置对象可以注入到任何需要它的构造函数中： 123constructor(@Inject(APP_CONFIG) config: AppConfig) &#123; this.title = config.title;&#125; 或者在 ngModule 中提供并注入这个配置对象，如AppModule。 1234providers: [ UserService, &#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;], 可选依赖HeroService需要一个Logger，但是如果想不提供 Logger 也能得到它，该怎么办呢？ 可以把构造函数的参数标记为@Optional()，告诉 Angular 该依赖是可选的： 1234567import &#123; Optional &#125; from '@angular/core';constructor(@Optional() private logger: Logger) &#123; if (this.logger) &#123; this.logger.log(some_message); &#125;&#125; 当使用@Optional()时，代码必须准备好如何处理空值。 如果其它的代码没有注册一个 logger，注入器会设置该logger的值为空 null。 模板语法插值表达式1&lt;p&gt;My current hero is &#123; &#123;currentHero.firstName&#125; &#125;&lt;/p&gt; 插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值。 一般来说，括号间的素材是一个模板表达式，Angular 先对它求值，再把它转换成字符串。 模板表达式模板表达式产生一个值。 Angular 执行这个表达式，并把它赋值给绑定目标的属性，这个绑定目标可能是 HTML 元素、组件或指令。 当我们写{ {1 + 1} }时，是往插值表达式的括号中放进了一个模板表达式。 在属性绑定中会再次看到模板表达式，它出现在=右侧的引号中，看起来像这样：[property]=&quot;expression&quot;。 JavaScript中在Angular模板表达式中禁止的运算符： 赋值 (=, +=, -=, …) new运算符 使用;或,的链式表达式 自增或自减操作符 (++和--) 不支持位运算|和&amp; 具有新的模板表达式运算符，比如|和?. 模板表达式不能引用全局命名空间中的任何东西。 它们被局限于只能访问来自表达式上下文中的成员。 典型的表达式上下文就是这个组件实例，它是各种绑定值的来源。 通常，组件本身就是表达式的上下文，这种情况下，模板表达式会引用那个组件。 表达式的上下文可以包括组件之外的对象。 模板引用变量就是备选的上下文对象之一。 模板表达式要遵循： 没有可见的副作用。模板表达式除了目标属性的值以外，不应该改变应用的任何状态。 执行迅速。表达式应该快速结束，否则用户就会感到拖沓，特别是在较慢的设备上。 非常简单。常规是属性名或方法调用。偶尔的逻辑取反 (!) 也还凑合。 幂等性。幂等的表达式应该总是返回完全相同的东西，直到某个依赖值发生改变。 模板语句模板语句用来响应由绑定目标（如 HTML 元素、组件或指令）触发的事件。它出现在=号右侧的引号中，就像这样：(event)=&quot;statement&quot;。它支持基本赋值 (=) 和表达式链 (;和,)。 然而，某些 JavaScript 语法仍然是不允许的： new运算符 自增和自减运算符：++和-- 操作并赋值，例如+=和-= 位操作符|和&amp; 模板表达式运算符 语句只能引用语句上下文中 —— 通常是正在绑定事件的那个组件实例。 在事件绑定语句中，经常会看到被保留的$event符号，它代表触发事件的“消息”或“有效载荷”。 绑定语法 1&lt;button [disabled]="isUnchanged"&gt;Save&lt;/button&gt; 一旦开始数据绑定，就不再跟 HTML attribute 打交道了。 这里不是设置 attribute，而是设置 DOM 元素、组件和指令的 property。 attribute 是由 HTML 定义的。property 是由 DOM (Document Object Model) 定义的。 少量 HTML attribute 和 property 之间有着 1:1 的映射，如id。 有些 HTML attribute 没有对应的 property，如colspan。 有些 DOM property 没有对应的 attribute，如textContent。 大量 HTML attribute看起来映射到了property…… 但却不像我们想的那样！ attribute 初始化 DOM property，然后它们的任务就完成了。property 的值可以改变；attribute 的值不能改变。 例如，当浏览器渲染`时，它将创建相应 DOM 节点， 其value` property 被初始化为 “Bob”。 当用户在输入框中输入 “Sally” 时，DOM 元素的value property 变成了 “Sally”。 但是这个 HTML value attribute 保持不变。如果我们读取 input 元素的 attribute，就会发现确实没变： input.getAttribute(&#39;value&#39;) // 返回 &quot;Bob&quot;。 HTML attribute value指定了初始值；DOM value property 是当前值。 模板绑定是通过 property 和事件来工作的，而不是 attribute。 在 Angular 的世界中，attribute 唯一的作用是用来初始化元素和指令的状态。 当进行数据绑定时，只是在与元素和指令的 property 和事件打交道，而 attribute 就完全靠边站了。 属性绑定当要把视图元素的属性 (property) 设置为模板表达式时，就要写模板的属性 (property) 绑定。 属性绑定是单向数据绑定，因为值的流动是单向的，从组件的数据属性流动到目标元素的属性。 不能使用属性绑定来从目标元素拉取值，也不能绑定到目标元素的属性来读取它。只能设置它。 也不能使用属性绑定来调用目标元素上的方法。 如果这个元素触发了事件，可以通过事件绑定来监听它们。 如果必须读取目标元素上的属性或调用它的某个方法，得用ViewChild 和 ContentChild。 包裹在方括号中的元素属性名标记着目标属性，比如： 1&lt;img [src]="heroImageUrl"&gt; 严格来说，Angular 正在匹配指令的输入属性的名字。 这个名字是指令的inputs数组中所列的名字，或者是带有@Input()装饰器的属性。 这些输入属性被映射为指令自己的属性。 表达式可能会调用具有副作用的属性或方法。但 Angular 没法知道这一点，也没法阻止我们。 一般建议是，只绑定数据属性和那些只返回值而不做其它事情的方法。 模板表达式应该返回目标属性所需类型的值。 当下列条件满足时，应该省略括号： 目标属性接受字符串值。 字符串是个固定值，可以直接合并到模块中。 这个初始值永不改变。 下列这几对绑定做的事情完全相同： 12345&lt;p&gt;&lt;img src="&#123; &#123;heroImageUrl&#125; &#125;"&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;img [src]="heroImageUrl"&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;span&gt;"&#123; &#123;title&#125; &#125;" is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="title"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt; 实际上，在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定。 没有技术上的理由能决定哪种形式更好。 我们倾向于可读性，所以倾向于插值表达式。 建议建立代码风格规则，选择一种形式， 这样，既遵循了规则，又能让手头的任务做起来更自然。 不管是插值表达式还是属性绑定，都不会允许带有 script 标签的 HTML 泄漏到浏览器中。 12345evilTitle = 'Template &lt;script&gt;alert("evil never sleeps")&lt;/script&gt;Syntax';&lt;p&gt;&lt;span&gt;"&#123; &#123;evilTitle&#125; &#125;" is the &lt;i&gt;interpolated&lt;/i&gt; evil title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="evilTitle"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; evil title.&lt;/p&gt; &lt;!--属性绑定把script中的内容忽略--&gt; 插值表达式处理 script 标签与属性绑定有所不同，但是二者都只渲染没有危害的内容。 attribute、class 和 style 绑定可以通过attribute 绑定来直接设置 attribute 的值。 当元素没有属性可绑的时候，就必须使用 attribute 绑定。 ARIA， SVG 和 table 中的 colspan/rowspan 等 attribute， 它们是纯粹的 attribute，没有对应的property可供绑定。（table合并单元格colspan和rowspan）。 attribute 绑定的语法与property绑定类似。 但方括号中的部分不是元素的属性名，而是由attr前缀，一个点 (.) 和 attribute 的名字组成。 可以通过值为字符串的表达式来设置 attribute 的值。 12345678910&lt;table border=1&gt; &lt;!-- expression calculates colspan=2 --&gt; &lt;tr&gt;&lt;td [attr.colspan]="1 + 1"&gt;One-Two&lt;/td&gt;&lt;/tr&gt; &lt;!-- ERROR: There is no `colspan` property to set! &lt;tr&gt;&lt;td colspan="&#123; &#123;1 + 1&#125; &#125;"&gt;Three-Four&lt;/td&gt;&lt;/tr&gt; --&gt; &lt;tr&gt;&lt;td&gt;Five&lt;/td&gt;&lt;td&gt;Six&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; CSS 类绑定绑定的语法与属性绑定类似。 但方括号中的部分不是元素的属性名，而是由class前缀，一个点 (.)和 CSS 类的名字组成， 其中后两部分是可选的。形如：[class.class-name]。 通过css类添加和移除类名的方法： 1 变量赋值 123&lt;!-- reset/override all class names with a binding --&gt;&lt;div class="bad curly special" [class]="badCurly"&gt;Bad curly&lt;/div&gt; 2 绑定到特定的类名 123456&lt;!-- toggle the "special" class on/off with a property --&gt;&lt;div [class.special]="isSpecial"&gt;The class binding is special&lt;/div&gt;&lt;!-- binding to `class.special` trumps the class attribute --&gt;&lt;div class="special" [class.special]="!isSpecial"&gt;This one is not so special&lt;/div&gt; 最好使用ngClass来管理多个类名。 通过样式绑定，可以设置内联样式。 样式绑定的语法与属性绑定类似。 但方括号中的部分不是元素的属性名，而由style前缀，一个点 (.)和 CSS 样式的属性名组成。 形如：[style.style-property]。 12&lt;button [style.color] = "isSpecial ? 'red': 'green'"&gt;Red&lt;/button&gt;&lt;button [style.background-color]="canSave ? 'cyan': 'grey'" &gt;Save&lt;/button&gt; 有些样式绑定中的样式带有单位。 12&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt; 最好用NgStyle来设置多个内联样式。 事件绑定事件绑定语法由等号左侧带圆括号的目标事件和右侧引号中的模板语句组成。 在事件绑定中，Angular 会为目标事件设置事件处理器。当事件发生时，这个处理器会执行模板语句。 典型的模板语句通常涉及到响应事件执行动作的接收器，例如从 HTML 控件中取得值，并存入模型。 绑定会通过名叫$event的事件对象传递关于此事件的信息（包括数据值）。 事件对象的形态取决于目标事件。如果目标事件是原生 DOM 元素事件， $event就是 DOM事件对象，它有像target和target.value这样的属性。 123&lt;input [value]="currentHero.firstName" (input)="currentHero.firstName=$event.target.value" &gt;&lt;!--通过路径$event.target.value来获取更改后的值。--&gt; 通常，指令使用 Angular EventEmitter来触发自定义事件。 指令创建一个EventEmitter实例，并且把它作为属性暴露出来。 指令调用EventEmitter.emit(payload)来触发事件，可以传入任何东西作为消息载荷。 父指令通过绑定到这个属性来监听事件，并通过$event对象来访问载荷。 12345678template: `&lt;div&gt; &lt;img src="&#123; &#123;heroImageUrl&#125; &#125;"&gt; &lt;span [style.text-decoration]="lineThrough"&gt; &#123; &#123;prefix&#125; &#125; &#123; &#123;hero?.fullName&#125; &#125; &lt;/span&gt; &lt;button (click)="delete()"&gt;Delete&lt;/button&gt;&lt;/div&gt;` 1234567// This component make a request but it can't actually delete a hero.deleteRequest = new EventEmitter&lt;Hero&gt;();delete() &#123; this.deleteRequest.emit(this.hero);&#125;//当用户点击删除时，组件会调用delete()方法，让EventEmitter发出一个Hero对象。 123&lt;!--假设宿主的父组件绑定了HeroDetailComponent的deleteRequest事件。--&gt;&lt;hero-detail (deleteRequest)="deleteHero($event)" [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;!--当deleteRequest事件触发时，Angular 调用父组件的deleteHero方法， 在$event变量中传入要删除的英雄（来自HeroDetail）。--&gt; 双向数据绑定Angular 提供一种特殊的双向数据绑定语法：[(x)]。 [(x)]语法结合了属性绑定的方括号[x]和事件绑定的圆括号(x)。双向绑定语法实际上是属性绑定和事件绑定的语法糖。 要理解双向绑定，先要理解元素设置的属性x和对应的事件xChange： 1234567891011121314151617181920import &#123; Component, EventEmitter, Input, Output &#125; from '@angular/core';@Component(&#123; selector: 'my-sizer', template: ` &lt;div&gt; &lt;button (click)="dec()" title="smaller"&gt;-&lt;/button&gt; &lt;button (click)="inc()" title="bigger"&gt;+&lt;/button&gt; &lt;label [style.font-size.px]="size"&gt;FontSize: &#123; &#123;size&#125; &#125;px&lt;/label&gt; &lt;/div&gt;`//属性绑定初始值&#125;)export class SizerComponent &#123; @Input() size: number | string; @Output() sizeChange = new EventEmitter&lt;number&gt;(); dec() &#123; this.resize(-1); &#125; inc() &#123; this.resize(+1); &#125; resize(delta: number) &#123; this.size = Math.min(40, Math.max(8, +this.size + delta)); this.sizeChange.emit(this.size); &#125;&#125; 下面是双向绑定： 12&lt;my-sizer [(size)]="fontSizePx"&gt;&lt;/my-sizer&gt;&lt;div [style.font-size.px]="fontSizePx"&gt;Resizable Text&lt;/div&gt; 可以分解为： 1&lt;my-sizer [size]="fontSizePx" (sizeChange)="fontSizePx=$event"&gt;&lt;/my-sizer&gt; $event变量包含了SizerComponent.sizeChange事件的荷载。 当用户点击按钮时，Angular 将$event赋值给AppComponent.fontSizePx。 原生 &lt;input&gt;和&lt;select&gt;这样的 HTML 元素不遵循x值和xChange事件的模式。Angular 以 NgModel指令为桥梁，允许在表单元素上使用双向数据绑定。 使用 NgModel 进行双向数据绑定在使用ngModel做双向数据绑定之前，得先导入FormsModule， 把它加入 Angular 模块的imports列表。 NgModel指令进行双向数据绑定让用户做出变更时更新显示变得更加容易。 12345678910111213141516171819&lt;input [value]="currentHero.firstName" (input)="currentHero.firstName=$event.target.value" &gt;&lt;!--升级--&gt;&lt;!--ngModel指令通过它自己的ngModel输入属性和ngModelChange输出属性隐藏了直接绑定元素的原生属性。ngModel数据属性设置元素的 value 属性，ngModelChange事件属性监听元素 value 的变化。除非写一个合适的值访问器，否则不能把[(ngModel)]用在自定义组件上。--&gt;&lt;input [ngModel]="currentHero.firstName" (ngModelChange)="currentHero.firstName=$event"&gt;&lt;input [ngModel]="currentHero.firstName" (ngModelChange)="setUpperCaseFirstName($event)"&gt;&lt;!--[(ngModel)]展开形式实现让输入值变成大写形式--&gt;&lt;!--升级--&gt;&lt;!--[(ngModel)]语法只能设置一个数据绑定属性。 如果需要做更多或不同的事情，就得自己用它的展开形式（上面代码）。--&gt;&lt;input [(ngModel)]="currentHero.firstName"&gt; 内置指令NgClass通过绑定到NgClass，可以同时添加或移除多个类。CSS 类绑定 是添加或删除单个类的最佳途径。当想要同时添加或移除多个 CSS 类时，NgClass指令可能是更好的选择。 12345678910&lt;div [ngClass]="setClasses()"&gt;This div is saveable and special&lt;/div&gt;setClasses() &#123; let classes = &#123; saveable: this.canSave, // true modified: !this.isUnchanged, // false special: this.isSpecial, // true &#125;; return classes;&#125; NgStyleNgStyle绑定可以同时设置多个内联样式。样式绑定是设置单一样式值的简单方式。如果要同时设置多个内联样式，NgStyle指令可能是更好的选择。 12345678910111213&lt;div [ngStyle]="setStyles()"&gt; This div is italic, normal weight, and extra large (24px).&lt;/div&gt;setStyles() &#123; let styles = &#123; // CSS property names 'font-style': this.canSave ? 'italic' : 'normal', // italic 'font-weight': !this.isUnchanged ? 'bold' : 'normal', // normal 'font-size': this.isSpecial ? '24px' : '8px', // 24px &#125;; return styles;&#125; NgIf通过绑定NgIf指令到真值表达式，可以把元素子树（元素及其子元素）添加到 DOM 上。绑定到假值表达式将从 DOM 中移除元素子树。 可以通过类绑定或样式绑定来显示和隐藏元素子树（元素及其子元素）。 123456789&lt;!-- isSpecial is true --&gt;&lt;div [class.hidden]="!isSpecial"&gt;Show with class&lt;/div&gt;&lt;div [class.hidden]="isSpecial"&gt;Hide with class&lt;/div&gt;&lt;!-- HeroDetail is in the DOM but hidden --&gt;&lt;hero-detail [class.hidden]="isSpecial"&gt;&lt;/hero-detail&gt;&lt;div [style.display]="isSpecial ? 'block' : 'none'"&gt;Show with style&lt;/div&gt;&lt;div [style.display]="isSpecial ? 'none' : 'block'"&gt;Hide with style&lt;/div&gt; 当NgIf为false时，Angular 从 DOM 中物理地移除了这个元素子树。 它销毁了子树中的组件及其状态，也潜在释放了可观的资源，最终让用户体验到更好的性能。 NgSwitch当需要从一组可能的元素树中根据条件显示一个时，我们就把它绑定到NgSwitch。 Angular 将只把选中的元素树放进 DOM 中。 1234567&lt;span [ngSwitch]="toeChoice"&gt; &lt;span *ngSwitchCase="'Eenie'"&gt;Eenie&lt;/span&gt; &lt;span *ngSwitchCase="'Meanie'"&gt;Meanie&lt;/span&gt; &lt;span *ngSwitchCase="'Miney'"&gt;Miney&lt;/span&gt; &lt;span *ngSwitchCase="'Moe'"&gt;Moe&lt;/span&gt; &lt;span *ngSwitchDefault&gt;other&lt;/span&gt;&lt;/span&gt; 把作为父指令的NgSwitch绑定到能返回开关值的表达式。 任何时候，这些 span 中最多只有一个会出现在 DOM 中。 这里有三个相互合作的指令： ngSwitch：绑定到返回开关值的表达式 ngSwitchCase：绑定到返回匹配值的表达式 ngSwitchDefault：用于标记出默认元素的 attribute 不要在ngSwitch的前面加星号 (*)，而应该用属性绑定。 要把星号 (*) 放在ngSwitchCase和ngSwitchDefault的前面。 NgForNgFor是一个重复器指令 —— 自定义数据显示的一种方式。 赋值给*ngFor的字符串不是模板表达式。 它是一个微语法 —— 由 Angular 自己解释的小型语言。 1&lt;hero-detail *ngFor="let hero of heroes" [hero]="hero"&gt;&lt;/hero-detail&gt; hero前面的let关键字创建了名叫hero的模板输入变量。 ngFor指令支持可选的index，它在迭代过程中会从 0 增长到“数组的长度”。 可以通过模板输入变量来捕获这个 index，并在模板中使用。 1&lt;div *ngFor="let hero of heroes; let i=index"&gt;&#123; &#123;i + 1&#125; &#125; - &#123; &#123;hero.fullName&#125; &#125;&lt;/div&gt; 追踪函数告诉 Angular：我们知道两个具有相同hero.id的对象其实是同一个英雄。 下面就是这样一个函数： 123trackByHeroes(index: number, hero: Hero) &#123; return hero.id; &#125;&lt;div *ngFor="let hero of heroes; trackBy:trackByHeroes"&gt;(&#123; &#123;hero.id&#125; &#125;) &#123; &#123;hero.fullName&#125; &#125;&lt;/div&gt; 追踪函数不会阻止所有 DOM 更改。 如果同一个英雄的属性变化了，Angular 就可能不得不更新DOM元素。 但是如果这个属性没有变化 —— 而且大多数时候它们不会变化 —— Angular 就能留下这些 DOM 元素。列表界面就会更加平滑，提供更好的响应。 * 与 &lt;template&gt;*是一种语法糖，它让那些需要借助模板来修改 HTML 布局的指令更易于读写。 NgFor、NgIf和NgSwitch都会添加或移除元素子树，这些元素子树被包裹在`标签中。 没有看到标签，那是因为这种*`前缀语法让我们忽略了这个标签， 而把注意力直接聚焦在所要包含、排除或重复的那些 HTML 元素上。 展开*ngIf12345678910&lt;hero-detail *ngIf="currentHero" [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;!--展开第一步--&gt;&lt;hero-detail template="ngIf:currentHero" [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;!--展开第二步--&gt;&lt;template [ngIf]="currentHero"&gt; &lt;hero-detail [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;/template&gt;&lt;!--不要误写为ngIf="currentHero"！ 这种语法会把一个字符串"currentHero"赋值给ngIf。 在 JavaScript 中，非空的字符串是真值，所以ngIf总会是true，而 Angular 将永远显示hero-detail, 即使根本没有currentHero--&gt; 展开*ngSwitch1234567891011121314151617&lt;span [ngSwitch]="toeChoice"&gt; &lt;!-- with *NgSwitch --&gt; &lt;span *ngSwitchCase="'Eenie'"&gt;Eenie&lt;/span&gt; &lt;span *ngSwitchCase="'Meanie'"&gt;Meanie&lt;/span&gt; &lt;span *ngSwitchCase="'Miney'"&gt;Miney&lt;/span&gt; &lt;span *ngSwitchCase="'Moe'"&gt;Moe&lt;/span&gt; &lt;span *ngSwitchDefault&gt;other&lt;/span&gt; &lt;!-- with &lt;template&gt; --&gt; &lt;template [ngSwitchCase]="'Eenie'"&gt;&lt;span&gt;Eenie&lt;/span&gt;&lt;/template&gt; &lt;template [ngSwitchCase]="'Meanie'"&gt;&lt;span&gt;Meanie&lt;/span&gt;&lt;/template&gt; &lt;template [ngSwitchCase]="'Miney'"&gt;&lt;span&gt;Miney&lt;/span&gt;&lt;/template&gt; &lt;template [ngSwitchCase]="'Moe'"&gt;&lt;span&gt;Moe&lt;/span&gt;&lt;/template&gt; &lt;template ngSwitchDefault&gt;&lt;span&gt;other&lt;/span&gt;&lt;/template&gt;&lt;/span&gt; *ngSwitchWhen和*ngSwitchDefault用和*ngIf完全相同的方式展开。 ngSwitch本身没有定义内容，它的工作是控制一组模板，所以不能用星号 (*) 前缀。 展开*ngFor123456789&lt;hero-detail *ngFor="let hero of heroes; trackBy:trackByHeroes" [hero]="hero"&gt;&lt;/hero-detail&gt;&lt;!--展开第一步--&gt;&lt;hero-detail template="ngFor let hero of heroes; trackBy:trackByHeroes" [hero]="hero"&gt;&lt;/hero-detail&gt;&lt;!--展开第二步--&gt;&lt;template ngFor let-hero [ngForOf]="heroes" [ngForTrackBy]="trackByHeroes"&gt; &lt;hero-detail [hero]="hero"&gt;&lt;/hero-detail&gt;&lt;/template&gt; 模板引用变量模板引用变量是模板中对 DOM 元素或指令的引用。 它能在原生 DOM 元素中使用，也能用于 Angular 组件。 1234567&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;&lt;input #phone placeholder="phone number"&gt;&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt;&lt;!-- fax refers to the input element; pass its `value` to an event handler --&gt;&lt;input ref-fax placeholder="fax number"&gt;&lt;button (click)="callFax(fax.value)"&gt;Fax&lt;/button&gt; 1234567&lt;form (ngSubmit)="onSubmit(theForm)" #theForm="ngForm"&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input class="form-control" name="name" required [(ngModel)]="currentHero.firstName"&gt; &lt;/div&gt; &lt;button type="submit" [disabled]="!theForm.form.valid"&gt;Submit&lt;/button&gt;&lt;/form&gt; theForm变量的值是个ngForm，对 Angular 内置指令NgForm的引用。 它包装了原生的HTMLFormElement并赋予它更多超能力，比如跟踪用户输入的有效性。 输入与输出属性绑定到的目标位于绑定声明中的左侧。 这些指令的属性必须被声明成输入或输出。 绑定的目标是在=左侧的部分， 源则是在=右侧的部分。 绑定的目标是绑定符：[]、()或[()]中的属性或事件名， 源则是引号 (&quot; &quot;) 中的部分或插值符号 ({ {} }) 中的部分。 源指令中的每个成员都会自动在绑定中可用。 不需要特别做什么，就能在模板表达式或语句中访问指令的成员。 访问目标指令中的成员则受到限制。 只能绑定到那些显式标记为输入或输出的属性。 123&lt;img [src]="iconUrl"/&gt;&lt;button (click)="onSave()"&gt;Save&lt;/button&gt;&lt;!--iconUrl和onSave是组件的成员，它们在=右侧引号语法中被引用了。它们既不是组件的输入也不是输出。它们是绑定的数据源。--&gt; 123&lt;hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)"&gt;&lt;/hero-detail&gt;&lt;!--HeroDetailComponent.hero和HeroDetailComponent.deleteRequest都在绑定声明的左侧。 HeroDetailComponent.hero在方括号中，它是属性绑定的目标。 HeroDetailComponent.deleteRequest在圆括号中，它是事件绑定的目标。--&gt; 目标属性必须被显式的标记为输入或输出。 12@Input() hero: Hero;@Output() deleteRequest = new EventEmitter&lt;Hero&gt;(); 另外，还可以在指令元数据的inputs或outputs数组中标记出这些成员。比如这个例子： 1234@Component(&#123; inputs: ['hero'], outputs: ['deleteRequest'],&#125;) 输入属性通常接收数据值。 输出属性暴露事件生产者，如EventEmitter对象。 输入和输出这两个词是从目标指令的角度来说的。 从HeroDetailComponent角度来看，HeroDetailComponent.hero是个输入属性， 因为数据流从模板绑定表达式流入那个属性。 从HeroDetailComponent角度来看，HeroDetailComponent.deleteRequest是个输出属性， 因为事件从那个属性流出，流向模板绑定语句中的处理器。 在指令类中，直接用指令名作为自己的属性名通常都不是好的选择。把别名传进@Input/@Output装饰器，就可以为属性指定别名，就像这样： 1@Output('myClick') clicks = new EventEmitter&lt;string&gt;(); 或者： 123@Directive(&#123; outputs: ['clicks:myClick'] // propertyName:alias&#125;) 模板表达式操作符管道操作符 ( | )管道是一个简单的函数，它接受一个输入值，并返回转换结果。 它们很容易用于模板表达式中，只要使用管道操作符 (|) 就行了。 1234567891011121314151617&lt;div&gt;Title through uppercase pipe: &#123; &#123;title | uppercase&#125; &#125;&lt;/div&gt;&lt;!-- Pipe chaining: convert title to uppercase, then to lowercase --&gt;&lt;div&gt; Title through a pipe chain: &#123; &#123;title | uppercase | lowercase&#125; &#125;&lt;/div&gt;&lt;!--使用参数, pipe with configuration argument =&gt; "February 25, 1970" --&gt;&lt;div&gt;Birthdate: &#123; &#123;currentHero?.birthdate | date:'longDate'&#125; &#125;&lt;/div&gt;&lt;!--json管道对调试绑定特别有用,它生成的输出是类似于这样的：&#123; "firstName": "Hercules", "lastName": "Son of Zeus", "birthdate": "1970-02-25T08:00:00.000Z", "url": "http://www.imdb.com/title/tt0065832/", "rate": 325, "id": 1 &#125;--&gt;&lt;div&gt;&#123; &#123;currentHero | json&#125; &#125;&lt;/div&gt; 安全导航操作符 ( ?. ) 和空属性路径Angular 的安全导航操作符 (?.) 是一种流畅而便利的方式，用来保护出现在属性路径中 null 和 undefined 值。 下例中，当currentHero为空时，保护视图渲染器，让它免于失败。 1The current hero's name is &#123; &#123;currentHero?.firstName&#125; &#125; 表达式会在它遇到第一个空值的时候跳出。 显示是空的，但应用正常工作，而没有发生错误。 数据绑定中属性为空，会显示不出或者抛出空引用错误： 1TypeError: Cannot read property 'firstName' of null in [null].]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts改造之动态显示]]></title>
      <url>%2F2017%2F01%2F23%2FEcharts%E6%94%B9%E9%80%A0%E4%B9%8B%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[官网动态数据实例中展示了数据动态变化的案例，这个如何移植到Angular2中去呢？首先要读懂官网的这个例子，不然会有坑。 官网案例分析首先，数据处理和图表生成最好放在一起，根据官网的例子，在设置定时器之前，对应的配置项中已经设定好10个数据，而定时器，只是向对应的配置项中不断删除第一个数据，然后push新的数据。官网原话如下： 设置图表实例的配置项以及数据，万能接口，所有参数和数据的修改都可以通过setOption完成，ECharts 会合并新的参数和数据，然后刷新图表。如果开启动画的话，ECharts 找到两组数据之间的差异然后通过合适的动画去表现数据的变化。 其次，myChart这个变量要设置为全局变量，不然每次echarts会重新复制图表，而不是像官网例子一样，呈现出向左推送的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html style="height: 100%"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body style="height: 100%; margin: 0"&gt; &lt;div id="container" style="height: 100%"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts-all-3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ZUONbpqGBsYGXNIYHicvbAbM"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;var dom = document.getElementById("container");var myChart = echarts.init(dom);var app = &#123;&#125;;option = null;option = &#123; title: &#123; text: '动态数据', subtext: '纯属虚构' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data:['最新成交价', '预购队列'] &#125;, toolbox: &#123; show: true, feature: &#123; dataView: &#123;readOnly: false&#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, dataZoom: &#123; show: false, start: 0, end: 100 &#125;, xAxis: [ &#123; type: 'category', boundaryGap: true, data: (function ()&#123; var now = new Date(); var res = []; //预先设置好初始值 var len = 10; //定义x轴数据个数 while (len--) &#123; res.unshift(now.toLocaleTimeString().replace(/^\D*/,'')); now = new Date(now - 2000); &#125; return res; &#125;)() &#125;, &#123; type: 'category', boundaryGap: true, data: (function ()&#123; var res = []; var len = 10; while (len--) &#123; res.push(len + 1); &#125; return res; &#125;)() &#125; ], yAxis: [ &#123; type: 'value', scale: true, name: '价格', max: 30, min: 0, boundaryGap: [0.2, 0.2] &#125;, &#123; type: 'value', scale: true, name: '预购量', max: 1200, min: 0, boundaryGap: [0.2, 0.2] &#125; ], series: [ &#123; name:'预购队列', type:'bar', xAxisIndex: 1, yAxisIndex: 1, data:(function ()&#123; var res = []; var len = 10; while (len--) &#123; res.push(Math.round(Math.random() * 1000)); &#125; return res; &#125;)() &#125;, &#123; name:'最新成交价', type:'line', data:(function ()&#123; var res = []; var len = 0; while (len &lt; 10) &#123; res.push((Math.random()*10 + 5).toFixed(1) - 0); len++; &#125; return res; &#125;)() &#125; ]&#125;;app.count = 11;setInterval(function ()&#123; axisData = (new Date()).toLocaleTimeString().replace(/^\D*/,''); var data0 = option.series[0].data; var data1 = option.series[1].data; data0.shift(); //数组去头 data0.push(Math.round(Math.random() * 1000));//推送新的数据 data1.shift(); data1.push((Math.random() * 10 + 5).toFixed(1) - 0); option.xAxis[0].data.shift(); option.xAxis[0].data.push(axisData); option.xAxis[1].data.shift(); option.xAxis[1].data.push(app.count++); myChart.setOption(option);&#125;, 2100);;if (option &amp;&amp; typeof option === "object") &#123; myChart.setOption(option, true);&#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 移植到ANgular2首先创建一个dynamic-line.component.ts文件，@Component装饰器和import按照自己需求配置好。在class中先定义一些全局变量，并配置好echarts的option： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950url:any;id:string;userdata:any;dom:any;myoption:any;myChart:any;option:any = &#123; tooltip: &#123; show: true, trigger: 'axis' &#125;, toolbox: &#123; show: true, feature: &#123; dataZoom: &#123;show: true&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125; &#125; &#125;, legend: &#123; selectedMode: true, selected: &#123;&#125;, right: '0px', top: '80px', orient: 'vertical', textStyle: &#123; fontSize: 12, &#125;, show: true, data: [] &#125;, xAxis: &#123; data: [], axisLabel: &#123; interval: 0, &#125; &#125;, grid: &#123; left: '9%', x2: 150, &#125;, yAxis: [ &#123; type: 'value', name: '', &#125; ], series: []&#125;; 然后从外部传入url，以供echarts读取数据和刷新： 1@Input() url:any; 设置从后端获取数据的函数（获取数据后，因为后端数据有点乱，为了方便，我把数据重新处理了一下，定义了一个setMyoption()的函数，把处理后的数据，用json对象的形式存放在myoption这个变量中）： 123456789101112 getUrlData() &#123; let that = this; //从接口获取数据(省略) that.userdata = ...... &#125; setMyoption() &#123; let that = this; that.myoption = &#123; "data": [] &#125;;//处理数据后，存放在data中(省略) &#125; 根据数据配置legend，因为legend不需要刷新，所以独立成单独的函数： 1234567setLegend() &#123; let legend = []; //把数据处理后push到legend数组中（省略）； that.option.legend.data = legend; &#125; 设置配置option中x轴数据和series数据： 123setDataToOption() &#123; //把数据处理后push到xaxis的data数组和series数组中（省略）&#125; 设置生成echarts的函数： 123456createCharts() &#123; let that = this; that.dom = document.getElementById(that.id); that.myChart = echarts.init(that.dom, 'macarons'); that.myChart.setOption(that.option); &#125; 接下来在ngAfterViewInit中调用相关函数，让页面加载完后显示echarts： 123456789101112131415161718192021222324252627ngAfterViewInit() &#123; let that = this; that.myUrl = that.url; //把导入的url赋值给myUrl that.getUrlData(); that.setMyoption(); //清空原始数组 that.option.legend.data = []; that.option.series.data = []; that.option.xAxis.data = []; that.option.series = []; //配置Legend that.setLegend(); //配置option that.setDataToOption(); //调用echarts画图 that.createCharts(); //走到这步就已经把echarts初始化好了，下面要对特定的数据进行动态推送 //动态推送 setInterval(function () &#123; that.setDynamicData(); &#125;, 6000) &#125; 下面就设置动态推送数据的函数： 123456789101112131415161718setDynamicData() &#123; let that = this; let xaxisData = that.option.xAxis.data; that.getUrlData(); //读取的数据中不包含之前的数据 that.setMyoption(); for (let i = 0; i &lt; that.userdata.length; i++) &#123; //多个数据一个个推送 let time = that.myoption.data[0].systime[i]; xaxisData.shift(); xaxisData.push(time); for (let n = 0; n &lt; that.option.series.length; n++) &#123; let pushData = that.myoption.data[n].value[i]; that.option.series[n].data.shift(); that.option.series[n].data.push(pushData); &#125; that.myChart.setOption(that.option); //mychart必须是全局变量 &#125; &#125; 最后的效果就是这样：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown--你值得拥有]]></title>
      <url>%2F2017%2F01%2F18%2FMarkdown-%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%2F</url>
      <content type="text"><![CDATA[什么是Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 官方文档创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown工具一般写文章大家会用word，那写makdown用什么呢？ mac平台收费的有： Ulysses Ⅲ， Mou ，Bear 免费的有：Typora Windows平台免费的有：Typora，MarkdownPad，MarkPad 这里推荐使用Typora，通吃Windows、mac和Linux三大平台。Typora 在 Markdown 的基础上，保持了应有的简洁和优雅，又一定程度地改良了 Markdown 本身较为不合理和烦琐的地方，适度地引入一些高级的编辑功能，使得一切都觉得如此顺手。 Markdown语法标题在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3.符号要和文字之间加上一个字符的空格。 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可显示引用格式。 图片与连接插入链接与插入图片的语法很像，区别在一个 !号 插入图片的地址需要图床，这里推荐 u图床 （mac）和MPic （Windows）的服务，生成URL地址即可。 在Typora中支持把图片拖拽进去，自动生成Markdown格式。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 代码框用两个 ` 把中间的代码包裹起来。 代码块输入三个```，选择语言，然后输入代码，你会发现代码块中的代码自动高亮。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可。 表格Markdown 写表格比较累人。 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 生成的表格如下： 但是Typora中提供了比较方便的写表格的方法。通过菜单栏或快捷键 Command+T 可以插入表格，Typora 会弹出一个表格插入设置，你可以预先设定好行数和列数，确定后表格就出现了。每一列上面还有三个按钮，可以控制本列的文字向左、居中、向右对齐。甚至，你可以点击左上角改变表格的行数和列数。 删除线用~~包围住文字： Markdown还支持直接写HTML，例如#标题等价于&lt;h1&gt;标题&lt;/h1&gt;。 格式转化在Typora的file—&gt;Export中可以把md格式文件转化成pdf、word、html等格式文件。转word需要安装插件： Download Page。 md格式： 转化成word格式：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm那些事儿]]></title>
      <url>%2F2017%2F01%2F16%2FWebStorm%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
      <content type="text"><![CDATA[关于webstorm WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 快捷键代码注释注释一行代码：ctrl+/(windows) ​ command+/(mac) 注释大段代码： 1 ctrl+/(windows) command+/(mac) ​ 2 ctrl+shif+/(windows) shift+command+/(mac) 格式化代码格式化代码：ctrl+alt+L(windows) ​ option+command+L(mac) shift+F6shift+F6（windows） shift+fn+F6（mac） 1 替换局部变量 ​ 2 重构函数名 快速跳转​ 快速跳转：ctrl+单击(windows) ​ command+单击（mac） 删除代码删除代码:ctrl+Y(windows) ​ Command+delete(mac) 多行编辑多行编辑：1 鼠标选择时按住alt(windows) ​ 鼠标按住时按住option（mac） ​ 2 长按alt+J，自动选择相同的元素（windows） ​ 选中元素后，按ctrl+g（mac） zencoding按tab键自动展开为完整html标签 后代：&gt; 兄弟：+ 上级：^ 分组：() 乘法：* 自增符号：$想显示几位数就使用几个$,$@-倒序，$@3从3开始计数 ​ ID和类属性:#和. 自定义属性:[] 文本:{} zencoding更多资料参见：zen coding 教程zen coding使用方法，大量实例和Zen Coding: 一种快速编写HTML/CSS代码的方法 自定义模板在setting&gt;Editor&gt;Live Templates中可以自定义模板，方便自己调用。 使用效果： 代码对比不同文件代码对比先把需要对比的代码复制到剪切板，然后右击有个compare with Clipboard，就会有个对话框弹出，里面标记了两个代码不同的地方。 相同文件历史代码对比右击有个Local History，选择Show History]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现（二）]]></title>
      <url>%2F2017%2F01%2F11%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[之前用三目表达式和ng-class实现了按钮切换效果，似乎达到了我的预期，但是我觉得还有改进空间，网上找了一些资料，大概还有以下几种实现方式： 路由12&lt;button class="btn1" routerLink="component1" routerLinkActive="active" type="submit"&gt;btn1&lt;/button&gt;&lt;button class="btn2" routerLink="component2" routerLinkActive="active" type="submit"&gt;btn2&lt;/button&gt; 123.active &#123; background-color: white;&#125; 将button切换的页面写成一个component，通过routerLink链接到对应的component并显示出来，routerLinkActive来控制路由链接激活后button的样式应用的class。 但是这个有局限性，适合button按下去后，整个页面会有大幅变化的应用场景，那么还有其他方法吗？答案是肯定的。 [class]与(click)还是通过ngclass和ngclick配合，不过方法和之前写的略有不同。 字符串数组形式12&lt;button [class]="&#123;true:'btn1',false:'btn2'&#125;[isChange]" (click)="isChange=true"&gt;btn1&lt;/button&gt;&lt;button [class]="&#123;false:'btn1',true:'btn2'&#125;[isChange]" (click)="isChange=false" &gt;btn2&lt;/button&gt; 123456789101112131415161718.btn1&#123; width: 120px; height: 43px; border: 1px solid #EEEEEE; background: white; border-bottom: none; text-align: center;&#125;.btn2&#123; border: 1px solid #EEEEEE; border-top: 2px solid #238FF9; width: 120px; height: 42px; background: white; border-bottom: none; text-align: center;&#125; 字符串数组形式是针对class简单变化，具有排斥性的变化，true是什么class，false是什么class。若要设置初识状态的class，可以在component中的构造函数中预先赋值。 对象key/value处理1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 这种方法可以对多个对象赋不同的class。或者可以实现多个button互斥性变化： 1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn1','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn1','four':'btn2'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn2','four':'btn1'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 参考资料： angularJs的ng-class切换class]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts改造之数据分离]]></title>
      <url>%2F2017%2F01%2F08%2FEcharts%E6%94%B9%E9%80%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
      <content type="text"><![CDATA[Echarts官网中的数据都是写死的，如何让Echarts根据后台传过来的数据进行变化呢？下面介绍一下Angular2中嵌入Echarts，并实现数据分离。 先创建一个line.component.ts文件，component装饰器中这样写： 123456@Component(&#123; moduleId: module.id, selector: 'line', templateUrl: 'line.html', styleUrls: ['line.component.css'],&#125;) class中实现AfterViewInit接口，用于初始化组件视图后调用： 12345export class LineComponent implements AfterViewInit &#123; ngAfterViewInit()&#123; &#125;&#125; 在class中首先定义一些变量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546lineData:Line; id:string; option:any = &#123; tooltip: &#123; show: true, trigger: 'axis' &#125;, toolbox: &#123; show: true, feature: &#123; magicType: &#123;show: true, type: ['bar']&#125;, dataZoom: &#123;show: true&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125; &#125; &#125;, legend: &#123; selectedMode: true, selected: &#123;&#125;, right: '0px', top: '80px', orient: 'vertical', textStyle: &#123; fontSize: 12, &#125;, show: true, data: [] &#125;, xAxis: &#123; data: [], axisLabel: &#123; interval: 0, &#125; &#125;, grid: &#123; left: '9%', x2: 150, &#125;, yAxis: [ &#123; type: 'value', name: '', &#125; ], series: [] &#125;; 在需要调用line.component.ts的父组件html中添加下面代码，把父组件中的myOption中的数据传递给data属性： 1&lt;line [data]='myOption'&gt;&lt;/line&gt; 在父组件的ts文件中，从后端读取数据，并把数据写入myOption（这里其实对原始数据进行了一次处理，让传给line.component.ts的数据更加容易处理）： 12345678910111213141516171819myOption:any; constructor()&#123; this.myOption = &#123; "data": [] &#125;;&#125;setMyOption()&#123; let that = this; let obj = &#123; "name": fieldkey, "value": [], "systime": [] &#125;; that.myOption.data = []; //先往obj中写入数据，再往data数组中写入对象&#125;getUrlData()&#123; //从后端读取数据&#125; 再回到line.component.ts中，引入myOption中的数据： 1@Input() data:any; 实现AfterViewInit接口： 12345678910111213141516ngAfterViewInit() &#123; let that = this; that.lineData = that.data; //data赋值给linedata //清空原始数组 that.option.legend.data = []; that.option.series.data = []; that.option.xAxis.data = []; that.option.series = []; //配置option that.setDataToOption(); //调用echarts画图 that.createCharts(); &#125; 往echarts中写入从后端读取的数据： 1234567891011121314151617181920212223242526272829303132333435setDataToOption() &#123; let that = this; let dataLength = this.lineData.data.length; let xAxisData = that.option.xAxis.data; let legend = that.option.legend; for (let n = 0; n &lt; dataLength; n++) &#123; let item = that.lineData.data[n]; legend.selected[item.name] = false; //往legend的selected中推送数据 let seriesData = &#123; name: item.name, type: 'line', showAllSymbol: true, data: [] &#125;; let legendData = &#123; name: item.name, icon: 'square' &#125;; let arr = Object.keys(item.value); for (let t = 0; t &lt; arr.length; t++) &#123; seriesData.data.push(item.value[t]); if (n === 0) &#123; xAxisData.push(item.systime[t]); //往x轴推送数据 &#125; &#125; legend.data.push(legendData); //往legend的data中推送数据 that.option.series.push(seriesData); //往series中推送数据 &#125; //设置x轴间隔 if (xAxisData.length &gt; 10) &#123; that.option.xAxis.axisLabel.interval = Math.ceil(xAxisData.length/10); &#125;&#125; 创建echarts： 123456createCharts() &#123; let that = this; let dom:any = document.getElementById(that.id); let myChart:any = echarts.init(dom, 'macarons'); myChart.setOption(that.option); &#125; 这样就实现了从后端读取数据，然后echarts显示在界面上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之架构概览]]></title>
      <url>%2F2017%2F01%2F02%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[模块NgModuleNgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是： declarations - 声明本模块中拥有的视图类。 Angular 有三种视图类：组件、指令和管道。 exports - declarations 的子集，可用于其它模块的组件模板（暴露出来供外部使用）。 imports - 本模块声明的组件模板需要的类所在的其它模块（引入所需的其他模块的组件模板）。 providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。 bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。 通过main.ts引导AppModule: 1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); JavaScript模块 JavaScript 也有自己的模块系统，用来管理一组 JavaScript 对象。 它与 Angular 的模块系统完全不同且完全无关。 JavaScript 中，每个文件是一个模块，文件中定义的所有对象都从属于那个模块。 通过export关键字，模块可以把它的某些对象声明为公共的。 其它 JavaScript 模块可以使用import 语句来访问这些公共对象。 12import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component'; 1export class AppModule &#123; &#125; Angular模块库Angular模块库是一组JavaScript模块，名字带有@angular前缀。用 JavaScript 的import语句导入。 组件组件控制视图。在类中定义组件的应用逻辑。 应用可以通过生命周期钩子在组件生命周期的各个时间点上插入自己的操作，例如ngOnInit()`。 模板模板定义组件的视图，以HTML形式存在。 模板除了可以使用典型的HTML元素，还可以使用Angular的模板语法，例如：*ngFor、、(click)、[hero]和&lt;hero-detail&gt;等。 &lt;hero-detail&gt;是HeroDetailComponent组件自定义的HTML标签，HeroDetailComponent是HeroListComponent的子组件。 元数据用装饰器来附加元数据: 123456@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;) @Component的配置项包括： moduleId: 为与模块相关的 URL（例如templateUrl）提供基地址。（简单的理解为给url分配一个当前module的Id，便于区分） selector： CSS 选择器，它告诉 Angular 在父级 HTML 中查找&lt;hero-list&gt;标签，创建并插入该组件。 例如，如果应用的 HTML 包含&lt;hero-list&gt;&lt;/hero-list&gt;， Angular 就会把HeroListComponent的一个实例插入到这个标签中。 templateUrl：组件 HTML 模板的模块相对地址。 providers - 组件所需服务的依赖注入提供商数组。 这是在告诉 Angular：该组件的构造函数需要一个HeroService服务，这样组件就可以从服务中获得英雄数据。 数据绑定数据绑定的语法有以下四种形式。每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。 123&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;&lt;hero-detail [hero]="selectedHero"&gt;&lt;/hero-detail&gt;&lt;li (click)="selectHero(hero)"&gt;&lt;/li&gt; 插值表达式在&lt;li&gt;标签中显示组件的hero.name属性的值。 [hero]属性绑定把父组件HeroListComponent的selectedHero的值传到子组件HeroDetailComponent的hero属性中。 (click) 事件绑定在用户点击英雄的名字时调用组件的selectHero方法。 双向数据绑定是重要的第四种绑定形式，它使用ngModel指令组合了属性绑定和事件绑定的功能。 1&lt;input [(ngModel)]="hero.name"&gt; 在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。 Angular 在每个 JavaScript 事件循环中处理所有的数据绑定，它会从组件树的根部开始，递归处理全部子组件。 双向绑定的应用： 模板与对应组件的交互 父组件与子组件的通讯 指令 指令是一个带有“指令元数据”的类。在 TypeScript 中，要通过@Directive装饰器把元数据附加到类上。Angular根据指令提供的操作对DOM进行转换。（严格来说组件就是一个指令）。 结构型指令结构型指令通过在 DOM 中添加、移除和替换元素来修改布局。 12&lt;li *ngFor="let hero of heroes"&gt;&lt;/li&gt;&lt;hero-detail *ngIf="selectedHero"&gt;&lt;/hero-detail&gt; *ngFor告诉 Angular 为heroes列表中的每个英雄生成一个&lt;li&gt;标签。 *ngIf表示只有在选择的英雄存在时，才会包含HeroDetail组件。 属性型指令属性型指令修改一个现有元素的外观或行为。在模板中，它们看起来就像是标准的 HTML 属性。例如：ngModule。 服务服务是一个广义范畴，包括：值、函数，或应用所需的特性。 组件类应保持精简。组件本身不从服务器获得数据、不进行验证输入，也不直接往控制台写日志。 它们把这些任务委托给服务。 组件的任务就是提供用户体验，仅此而已。它介于视图（由模板渲染）和应用逻辑（通常包括模型的某些概念）之间。 设计良好的组件为数据绑定提供属性和方法，把其它琐事都委托给服务。 依赖注入 Angular 使用依赖注入来提供新组件以及组件所需的服务。Angular 通过查看构造函数的参数类型得知组件需要哪些服务。 1constructor(private service: HeroService) &#123; &#125; 当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。 注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。 当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。 这就是依赖注入 。(注入器将服务作为参数，注入到构造函数中) 当注入器没有服务时，通过provide创建并返回一个服务。 provide可以在根模块上添加provide以便任何地方使用服务的同一个实例，或者在@component元数据中添加provide以便在组件层中使用，把它注册在组件级表示该组件的每一个新实例都会有一个服务的新实例。 需要记住的关于依赖注入的要点是： 依赖注入渗透在整个 Angular 框架中，被到处使用。 注入器 (injector) 是本机制的核心。 注入器负责维护一个容器，用于存放它创建过的服务实例。 注入器能使用提供商创建一个新的服务实例。 提供商是一个用于创建服务的配方。 把提供商注册到注入器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2中的base标签]]></title>
      <url>%2F2016%2F12%2F31%2FAngular2%E4%B8%AD%E7%9A%84base%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[Angular2官方hero教程中，提到了&lt;base href=&quot;/&quot;&gt;，写的很简单，当时我也没有留意，今天写自己的开源项目的时候，突然遇到这个问题，正好讲一下。 我的路由是这样的： 12345const routes: Routes = [ &#123; path: '', redirectTo: '/line', pathMatch: 'full' &#125;, &#123; path: 'line', component: LineComponent &#125;, &#123; path: 'bar', component: BarComponent &#125;,]; 第一次加载页面的时候，url是：http://localhost:3000/line， 如果在&lt;head&gt;里没写&lt;base href=&quot;/&quot;&gt;，那么当你浏览器自动刷新的时候，url会变成：http://localhost:3000/line/line，也就是说，浏览器的前缀没有清空，这样会导致加载时出现404错误。这时候只要在&lt;head&gt;里加上&lt;base href=&quot;/&quot;&gt;，就可以了，或者加上： 1&lt;script&gt;document.write('&lt;base href="' + document.location + '" /&gt;');&lt;/script&gt; 来保护当前的URL，保证当我们导航到深层次的url时候，资源可以被正确加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[愿17可期]]></title>
      <url>%2F2016%2F12%2F27%2F%E6%84%BF17%E5%8F%AF%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[[ti:5.野子-苏运莹] [ar: 是] [al:] [by:] [offset:0] [00:00.10]野子 - 苏运莹 [00:00.20]词：苏运莹 [00:00.30]曲：苏运莹 [00:00.40] [00:25.72]怎么大风越狠 [00:28.82]我心越荡 [00:30.91] [00:31.96]幻如一丝尘土 [00:33.79]随风自由的在狂舞 [00:37.62] [00:38.32]我要握紧手中坚定 [00:41.40]却又飘散的勇气 [00:44.78]我会变成巨人 [00:46.73]踏着力气 踩着梦 [00:49.22] [00:51.22]怎么大风越狠 [00:54.29]我心越荡 [00:57.53]又如一丝消沙 [00:59.38]随风轻飘的在狂舞 [01:03.91]我要深埋心头上秉持 [01:07.10]却又重小的勇气 [01:10.21]一直往大风吹的方向走过去 [01:16.20]吹啊吹啊 我的骄傲放纵 [01:19.58]吹啊吹不毁我纯净花园 [01:22.27]任风吹 任它乱 [01:24.02]毁不灭是我 尽头的展望 [01:29.15]吹啊吹啊 我赤脚不害怕 [01:32.34]吹啊吹啊 无所谓 扰乱我 [01:35.52]你看我在勇敢地微笑 [01:37.98] [01:38.50]你看我在勇敢地去挥手啊 [01:42.88] [01:55.14]是你吗 会给我一扇心房 [01:57.60]让我勇敢前行 [02:00.48] [02:01.47]是你呀 会给我一扇灯窗 [02:04.39]让我让我无所畏惧 [02:07.56]吹啊吹啊 我的骄傲放纵 [02:10.76]吹啊吹不毁我纯净花园 [02:13.54]任风吹 任它乱 [02:15.23]毁不灭是我 尽头的展望 [02:19.72] [02:20.46]吹啊吹啊 我赤脚不害怕 [02:23.53]吹啊吹啊 无所谓 扰乱我 [02:26.62]你看我在勇敢地微笑 [02:29.72]你看我在勇敢地去挥手啊 [02:33.97] [02:40.03]怎么大风越狠 我心越荡 [02:46.28] [02:46.93]我会变成巨人 [02:49.75]踏着力气 踩着梦 new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: true, showlrc: 2, music: { title: "野子", author: "苏运莹", url: "http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a", pic: "http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg", } }); 即将过去的一年对我来说太重要，以至于像我这样害怕写总结的人也拿起键盘，敲下了这一段文字。 记得在15年11月吧，在深圳青旅认识的蔡浩凯大哥来上海出差，正好抽空一起吃了一顿饭，交流了一下工作心得，在诺基亚和IBM就职过的浩凯大哥给了我很多职业规划方面的意见，也给我种下一颗转行的种子。 大概是16年3月，我开始在网上看java，每天上班回来，看一小时一建和一小时java，到后来工作太忙，以至于我下决心彻底放弃一建，专心看java，期间汪汪和田野还给我寄了一大箱java的书，虽然我最后去做前端了，哈哈哈。IT上的版本管理工具、IDE、各种开源论坛、各种资料的分享让我看到了一种自己想要的工作模式。 于是16年8月底辞职，去了趟成都和九寨沟散散心，顺便找昭哥和玉玺小聚了一下。回来后便安心的开始看前端。 辞职后，遇到很多朋友都没有透露我转行的消息。其实，当时自己真的挺迷茫的，要填的坑太多，甚至都不确定自己是否会成功，只晓得沿着自己计划的方向走，至于失败还是成功就留给老天吧。 自学期间顺手搭了这个博客，作为程序猿，有自己搭的博客，赶脚逼格max，哈哈哈。11月，在汪汪童鞋的建议下，我开始投简历，可能运气比较好，第二个面试就被录用了。就这样，我也算跨入了程序猿的行列。 工作一个多月，发现自己的选择是正确的，这种Geek的工作模式让我感到充满动力，每次调完bug，那种如沐春风的感觉，真的很棒。 很庆幸，能做自己想做的事情，不管未来是怎么样，至少自己努力了。 感谢蔡浩凯大哥、汪汪、田野，把我领进了IT的大门。 感谢郑部、王博、超哥在面试后决定录用我，虽然我至今都觉得自己技术漏洞太多，被录用简直是奇迹。 感谢中兴通讯虚拟化上海一部DG2的所有同事，面对我的很多问题都能耐心解答，让我成功避开了很多坑。 感谢家人、女友在这一年的支持，在我迷茫的时候给我继续前进的动力。 最后，愿17可期。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo添加音乐、high一下及一些坑]]></title>
      <url>%2F2016%2F12%2F24%2Fhexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
      <content type="text"><![CDATA[hexo添加音乐需要几个步骤？添加音乐当然可以用其他网站的外链，但是一般外链是&lt;iframe&gt;，这个影响网站的SEO，逼格也不够高。 下面我就隆重介绍一款html5音乐播放器：Aplayer。把Aplayer加入hexo需要用到hexo-tag-aplayer插件。 切换到hexo目录，运行： 1npm install hexo-tag-aplayer@2.0.1 这里直接运行npm install hexo-tag-aplayer只会安装2.0.0，这个版本会出现以下错误： 12FATAL Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;Error: Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos; 作者给出来解决方案是用2.0.1版本，FATAL Cannot find module解决办法。 安装完成后，在需要添加音乐的地方加上： 1&#123;% aplayer "平凡之路" "朴树" "https://ogd99kckh.qnssl.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3" "https://ogd99kckh.qnssl.com/1.jpg" "autoplay" %&#125; 就会出现你想要的音乐啦，这里我把音乐和专辑封面添加到七牛上，加载速度嗖嗖的。 如果你想加入歌单，把上面的代码换成下面代码就行，参数的用法可以参照插件的使用说明。 1&#123;% aplayerlist %&#125;&#123;"narrow": false,"autoplay": true,"showlrc": 3,"mode": "random","music": [&#123;"title": "平凡之路","author": "朴树","url": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic": "https://ogd99kckh.qnssl.com/1.jpg","lrc": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"&#125;,&#123;"title": "野子","author": "苏运莹","url": "http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a","pic": "http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt"&#125;]&#125;&#123;% endaplayerlist %&#125; 当然，Aplayer的作者还有一款html5的视频播放器，叫Dplayer，对应有一款hexo的插件，叫hexo-tag-dplayer，有需求的可以去看看，用法都差不多。 一起high一下这个功能是我在Hexo high一下小功能上看到的，觉得很有意思，于是就引进来，改造了一下。 首先是重新封装了一个high.js文件，代码中注释的地方可下载下来放到七牛，加快国内访问速度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150function shake() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake.mp3"; //可下载下来放到七牛，加快国内访问速度 var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake-style.css";//可下载下来放到七牛，加快国内访问速度 var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125; 把这个文件保存在七牛上，在themes—&gt;next—&gt;layout—&gt;_partials—&gt;head.swig中加入这样一段代码，引入high.js文件(src里的内容请替换成自己的外链)： 1&lt;script type="text/javascript" src="https://ogd99kckh.qnssl.com/high.js"&gt;&lt;/script&gt; 然后在themes—&gt;next—&gt;layout—&gt;_macro—&gt;sidebar.swig中加入注释包围中的代码： 1234567891011121314151617&lt;div class="links-of-author motion-element"&gt; &#123;% if theme.social %&#125; &#123;% for name, link in theme.social %&#125; &lt;span class="links-of-author-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; &#123;% if theme.social_icons.enable %&#125; &lt;i class="fa fa-fw fa-&#123;&#123; theme.social_icons[name] | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;% endif %&#125; &#123;&#123; name &#125;&#125; &lt;/a&gt; &lt;/span&gt; &#123;% endfor %&#125; &lt;!--以下是加入关于high一下的代码--&gt; &lt;span class="links-of-author-item"&gt;&lt;a title="小high一下~" style="underline: none;color:red" rel="alternate" class="mw-harlem_shake_slow wobble shake" href="javascript:shake()"&gt;&lt;i class="fa fa-music"&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;High&lt;/a&gt;&lt;/span&gt; &lt;!--以上是加入关于high一下的代码--&gt; &#123;% endif %&#125; &lt;/div&gt; style中我用了红色，这样显眼一点，不喜欢的话可以改掉。 接下来点击high这个按钮，会出现一下效果： 大坑当我吭哧吭哧的弄完后，突然发现我运行hexo g命令后，出现下面两行提示后就不动了~ 12INFO Start processingINFO Files loaded in 3.9 s 我用了各种方法，包括版本回退，好像都没用。于是我就尝试切换到hexo默认主题，结果又可以hexo g，估计是next主题出问题了，于是我重新下了next主题，把我的配置都重新弄了一遍，结果好了~~，不过页脚的地方与之前博客不同，少了”power by hexo”这几个字眼。 更新next后遇到的第一个问题是，不显示文章发表时间了，github上的解答是这样的,文章标题下的发表时间不见了,在主题配置文件里面加上下面的配置，然后就出来了。 12345# Post meta display settingspost_meta: created_at: true updated_at: false categories: true 第二个问题，我hexo s成功后，登陆localhost:4000，发现出现下面的提示： 原因是，我开了shadowsocks的全局模式，切换到自动代理模式，就可以显示网页了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular官方文档学习笔记之hero教程]]></title>
      <url>%2F2016%2F12%2F21%2FAngular%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bhero%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[ES6工具链 systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载 es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块 traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码。systemjs会自动加载 这个模块。 Hello World 根据官方文档的快速起步，按照自己的理解画了上面的流程图（有不对的地方还请指正）。 包括Angular在内的Angular应用通过NgModules分成不同的代码块，需要哪个块，就import，这样可以减少文件体积。 每一个Angular应用都至少有一个模块和组件，组件通过与它相关的模板来控制屏幕上的一小块（视图View），main.ts负责初始化应用平台，进行应用引导。 为了方便测试组件，应用的引导应与组件或者模块分开，这样实现了MVM（model-view-whatever） Hero教程官网的Hero教程是建立在quickstart上的，所以可以把quickstart直接拿过来用。 英雄编辑器class中可以定义一些变量、方法甚至是构造函数（用于初始化），export出来的class可以被外部使用。 在Angular中{{}}用来取值。 一个ts文件中可以定义多个export class，但是官方不提倡。 id:number和hero:Hero = {}都是指定了变量的类型。 template中双引号改成反引号，可以写成多行形式。 表单输入双向绑定需要导入FormsModule模块，@NgModule中的import数组是应用中用到的外部模块列表。 用到Angular自带的模块，在import数组中声明；用到自定义的组件在declarations数组中声明。 主从结构123456789101112const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; 这段代码中的const是ES6中定义变量的关键字，在ES6中， const 代表一个值的常量索引，变量名字在内存中的指针不能够改变，但是指向这个变量的值 可能 改变。例如： 1234567const names = [ ] ;names . push ( “Jordan” ) ;console . log ( names ) ;const names = [ ] ;names = [ ] ; // Error! *ngFor=&quot;let hero of heroes&quot;中ngFor的*前缀表示``及其子元素组成了一个主控模板。 ngFor指令在AppComponent.heroes属性返回的heroes数组上迭代，并输出此模板的实例。 引号中赋值给ngFor的那段文本表示“从heroes数组中取出每个英雄，存入一个局部的hero变量，并让它在相应的模板实例中可用”。 为一个组件指定样式时，它们的作用域将仅限于该组件。 ngIf指令为false则从 DOM 中移除整段 HTML。 [class.selected]=&quot;hero === selectedHero&quot; 这个写法很有意思，.可以理解为css类选择器，在class上为selected类添加一个属性绑定（绑定了style中的.selected这个样式），当后面的表达式为true时，绑定这个样式，false时不绑定。而[]实现了从数据源(hero === selectedHero表达式)到class属性的单向数据流动。 多个组件可以将需要多次引用的类单独写入一个ts文件中。 &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;通过标签中的[hero]=&quot;selectedHero&quot;可以在不同组件之间传递数据。在需要引用hero的地方，用@Input() hero: Hero;来引入hero。 服务当 TypeScript 看到@Injectable()装饰器时，就会记下本服务的元数据。 如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。 HeroService从mock-heroes.ts获取数据，并提供给其他组件使用。其他组件使用HeroService时，用构造函数定义一个私有属性，作为注入HeroService的靶点。 providers数组告诉 Angular，当它创建新的AppComponent组件时，也要创建一个HeroService的新实例。 可以把HeroService看做中转站，而providers数组告诉 Angular，这是中转站。中转站中记录着哪里的有元数据，并随时准备注入所需要的组件中。 OnInit 接口会在组件刚创建时、每次变化时，以及最终被销毁时被Angular调用。OnInit 接口中会有一个带有初始化逻辑的ngOnInit方法，可以用来初始化。 承诺，在有了结果时，它承诺会回调我们。 我们请求一个异步服务去做点什么，并且给它一个回调函数。 它会去做（在某个地方），一旦完成，它就会调用我们的回调函数，并通过参数把工作结果或者错误信息传给我们。 123getHeroes(): void &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);&#125; 这个方法基于承诺的，并在承诺的事情被解决时再行动。 一旦承诺的事情被成功解决，就会显示英雄数据。then方法把回调函数作为参数传给承诺对象。 路由路由告诉路由器，当用户点击链接或者把 URL 粘贴到浏览器地址栏时，应该显示哪个视图。 路由定义包括以下部分： path: 路由器会用它来匹配浏览器地址栏中的地址，如heroes。 component: 导航到此路由时，路由器需要创建的组件（HeroesComponent）。 路由有两种实现方式： 第一种是通过RouterLink指令，绑定到heroes的路由路径，在app.module.ts中指定了&#39;/heroes&#39;就是指向HeroesComponent的那个路由的路径，并且需要告诉路由把激活的组件显示在&lt;router-outlet&gt;里面。 12345template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a routerLink="/heroes"&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; ` 1234567891011121314151617181920212223@NgModule(&#123; imports: [ BrowserModule, FormsModule, RouterModule.forRoot([ &#123; path: 'heroes', component: HeroesComponent &#125; ]) ], declarations: [ AppComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123;&#125; 第二种是通过函数来实现，触发click事件后，调用gotoDetail函数，该函数将路由导航到detail的组件上。 123gotoDetail(): void &#123; this.router.navigate(['/detail', this.selectedHero.id]);&#125; 1&lt;button (click)="gotoDetail()"&gt;View Details&lt;/button&gt; 浏览器启动时，在地址栏中使用的路径是/。如果要在应用启动的时候就显示仪表盘，而且希望在浏览器的地址栏看到一个好看的 URL，比如/dashboard，这就需要用到重定向： 12345&#123; path: '', redirectTo: '/dashboard', pathMatch: 'full'&#125;, 设置moduleId属性到module.id后，才能使用templateUrl。 路径中的冒号 (:) 表示:id是一个占位符: 1234&#123; path: 'detail/:id', component: HeroDetailComponent&#125;, 通过[routerLink]绑定了一个包含链接参数数组的表达式。 该数组有两个元素，目标路由和一个用来设置当前英雄的 id 值的路由参数。这两个元素与上面定义中的 path 和 :id 对应。 1&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt; 典型路由模块值得注意的有： 将路由抽出到一个变量中。你将来可能会导出它，而且它让路由模块模式更加明确。 添加RouterModule.forRoot(routes)到imports。 添加RouterModule到exports，这样关联模块的组件可以访问路由的声明，比如RouterLink和RouterOutlet。 无declarations！声明是关联模块的任务。 如果你有守卫服务，添加模块providers。 Angular路由器提供了routerLinkActive指令，我们可以用它来为匹配了活动路由的 HTML 导航元素自动添加一个 CSS 类。 12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink="/dashboard" routerLinkActive="active"&gt;Dashboard&lt;/a&gt; &lt;a routerLink="/heroes" routerLinkActive="active"&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 123nav a.active &#123; color: #039be5;&#125; 好不容易走到路由这步，我按照我的理解画了一个脑图： HTTP准备HTTP服务@angular/http库中的HttpModule保存着这些 HTTP 相关服务提供商的全集。 模拟web API123// Imports for loading &amp; configuring the in-memory web apiimport &#123; InMemoryWebApiModule &#125; from 'angular-in-memory-web-api';import &#123; InMemoryDataService &#125; from './in-memory-data.service'; InMemoryWebApiModule将Http客户端默认的后端服务替换成了内存 Web API服务。 1InMemoryWebApiModule.forRoot(InMemoryDataService), forRoot配置方法需要InMemoryDataService类实例，用来向内存数据库填充数据。 英雄与HTTP12345678910private heroesUrl = 'app/heroes'; // URL to web apiconstructor(private http: Http) &#123; &#125;getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data as Hero[]) .catch(this.handleError);&#125; HTTP承诺Angular 的http.get返回一个RxJS的Observable对象。 Observable（可观察对象）是一个管理异步数据流的强力方式。 1.toPromise() 利用toPromise操作符把Observable直接转换成Promise对象。Angular 的Observable并没有一个toPromise操作符，需要从 RxJS 库中导入它们。 1import 'rxjs/add/operator/toPromise'; 在then 回调中提取出数据1.then(response =&gt; response.json().data as Hero[]) 在 promise 的then回调中，调用 HTTP 的Reponse对象的json方法，以提取出其中的数据。 错误处理1.catch(this.handleError); 1234private handleError(error: any): Promise&lt;any&gt; &#123; console.error('An error occurred', error); // for demo purposes only return Promise.reject(error.message || error);&#125; catch了服务器的失败信息，并把它们传给了错误处理器 更新英雄详情hero服务的update方法12345678910private headers = new Headers(&#123;'Content-Type': 'application/json'&#125;);update(hero: Hero): Promise&lt;Hero&gt; &#123; const url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError);&#125; 通过一个编码在 URL 中的英雄 id 来告诉服务器应该更新哪个英雄。put 的 body 是该英雄的 JSON 字符串，它是通过调用JSON.stringify得到的。 并且在请求头中标记出的 body 的内容类型（application/json）。 添加英雄12345678910111213141516&lt;div&gt; &lt;label&gt;Hero name:&lt;/label&gt; &lt;input #heroName /&gt; &lt;button (click)="add(heroName.value); heroName.value=''"&gt; Add &lt;/button&gt;&lt;/div&gt; add(name: string): void &#123; name = name.trim(); if (!name) &#123; return; &#125; this.heroService.create(name) .then(hero =&gt; &#123; this.heroes.push(hero); this.selectedHero = null; &#125;);&#125; 当指定的名字不为空的时候，点击处理器就会委托 hero 服务来创建一个具有此名字的英雄， 并把这个新的英雄添加到数组中。 删除一个英雄1234567&lt;li *ngFor="let hero of heroes" (click)="onSelect(hero)" [class.selected]="hero === selectedHero"&gt; &lt;span class="badge"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;hero.name&#125;&#125;&lt;/span&gt; &lt;button class="delete" (click)="delete(hero); $event.stopPropagation()"&gt;x&lt;/button&gt;&lt;/li&gt; delete按钮的点击处理器应该阻止点击事件向上冒泡 ，否则它会选中我们要删除的这位英雄。 可观察对象 (Observable)一个可观察对象是一个事件流，我们可以用数组型操作符来处理它。 把Observable转换成了Promise通常是更好地选择，我们通常会要求http.get获取单块数据。只要接收到数据，就算完成。 使用承诺这种形式的结果是让调用方更容易写，并且承诺已经在 JavaScript 程序员中被广泛接受了。 按名搜索12345678910111213import &#123; Injectable &#125; from '@angular/core';import &#123; Http, Response &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs';import &#123; Hero &#125; from './hero';@Injectable()export class HeroSearchService &#123; constructor(private http: Http) &#123;&#125; search(term: string): Observable&lt;Hero[]&gt; &#123; return this.http .get(`app/heroes/?name=$&#123;term&#125;`) .map((r: Response) =&gt; r.json().data as Hero[]); &#125;&#125; 不再调用toPromise，而是直接返回可观察对象。 HeroSearchComponent12345678910&lt;div id="search-component"&gt; &lt;h4&gt;Hero Search&lt;/h4&gt; &lt;input #searchBox id="search-box" (keyup)="search(searchBox.value)" /&gt; &lt;div&gt; &lt;div *ngFor="let hero of heroes | async" (click)="gotoDetail(hero)" class="search-result" &gt; &#123;&#123;hero.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; heroes属性现在是英雄列表的Observable对象，而不再只是英雄数组。 *ngFor不能用可观察对象做任何事，除非我们在它后面跟一个async pipe (AsyncPipe)。 这个async管道会订阅到这个可观察对象，并且为*ngFor生成一个英雄数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Router &#125; from '@angular/router';import &#123; Observable &#125; from 'rxjs/Observable';import &#123; Subject &#125; from 'rxjs/Subject';import &#123; HeroSearchService &#125; from './hero-search.service';import &#123; Hero &#125; from './hero';@Component(&#123; moduleId: module.id, selector: 'hero-search', templateUrl: 'hero-search.component.html', styleUrls: [ 'hero-search.component.css' ], providers: [HeroSearchService]&#125;)export class HeroSearchComponent implements OnInit &#123; heroes: Observable&lt;Hero[]&gt;; private searchTerms = new Subject&lt;string&gt;(); constructor( private heroSearchService: HeroSearchService, private router: Router) &#123;&#125; // Push a search term into the observable stream. search(term: string): void &#123; this.searchTerms.next(term); &#125; ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) // wait for 300ms pause in events .distinctUntilChanged() // ignore if next search term is same as previous .switchMap(term =&gt; term // switch to new observable each time // return the http search observable ? this.heroSearchService.search(term) // or the observable of empty heroes if no search term : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; // TODO: real error handling console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;); &#125; gotoDetail(hero: Hero): void &#123; let link = ['/detail', hero.id]; this.router.navigate(link); &#125;&#125; 搜索词123456private searchTerms = new Subject&lt;string&gt;();// Push a search term into the observable stream.search(term: string): void &#123; this.searchTerms.next(term);&#125; Subject（主题）是一个可观察的事件流中的生产者。 searchTerms生成一个产生字符串的Observable，用作按名称搜索时的过滤条件。 每当调用search时都会调用next来把新的字符串放进该主题的可观察流中。 初始化 HEROES 属性(NGONINIT)1234567891011121314151617heroes: Observable&lt;Hero[]&gt;;ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) // wait for 300ms pause in events .distinctUntilChanged() // ignore if next search term is same as previous .switchMap(term =&gt; term // switch to new observable each time // return the http search observable ? this.heroSearchService.search(term) // or the observable of empty heroes if no search term : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; // TODO: real error handling console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);&#125; Subject也是一个Observable对象。 要把搜索词的流转换成Hero数组的流，并把结果赋值给heroes属性。 如果我们直接把每一次用户按键都直接传给HeroSearchService，就会发起一场 HTTP 请求风暴。我们不希望占用服务器资源，也不想耗光蜂窝移动网络的流量。 幸运的是，我们可以在字符串的Observable后面串联一些Observable操作符，来归并这些请求。 我们将对HeroSearchService发起更少的调用，并且仍然获得足够及时的响应。做法如下： 在传出最终字符串之前，debounceTime(300)将会等待，直到新增字符串的事件暂停了 300 毫秒。 我们实际发起请求的间隔永远不会小于 300ms。 distinctUntilChanged确保只在过滤条件变化时才发送请求， 这样就不会重复请求同一个搜索词了。 switchMap会为每个从debounce和distinctUntilChanged中通过的搜索词调用搜索服务。 它会取消并丢弃以前的搜索可观察对象，只保留最近的。 switchMap操作符 (以前叫”flatMapLatest”)是非常智能的。每次符合条件的按键事件都会触发一次对http方法的调用。即使在发送每个请求前都有 300 毫秒的延迟， 我们仍然可能同时拥有多个在途的 HTTP 请求，并且它们返回的顺序未必就是发送时的顺序。switchMap保留了原始的请求顺序，并且只返回最近一次 http 调用返回的可观察对象。 这是因为以前的调用都被取消或丢弃了。如果搜索框为空，我们还可以短路掉这次http方法调用，并且直接返回一个包含空数组的可观察对象。注意，取消HeroSearchService的可观察对象并不会实际中止 (abort) 一个未完成的 HTTP 请求， 除非服务支持这个特性，这个问题我们以后再讨论。 目前我们的做法只是丢弃不希望的结果。 导入RxJS操作符123456789101112// Observable class extensionsimport 'rxjs/add/observable/of';import 'rxjs/add/observable/throw';// Observable operatorsimport 'rxjs/add/operator/catch';import 'rxjs/add/operator/debounceTime';import 'rxjs/add/operator/distinctUntilChanged';import 'rxjs/add/operator/do';import 'rxjs/add/operator/filter';import 'rxjs/add/operator/map';import 'rxjs/add/operator/switchMap'; 把整个应用中要用的那些 RxJS Observable扩展组合在一起，放在一个单独的 RxJS 导入文件中。我们在顶级的AppModule中导入rxjs-extensions就可以一次性加载它们。 1import './rxjs-extensions';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON那些事]]></title>
      <url>%2F2016%2F12%2F18%2FJSON%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[最近用echarts时和json打交道比较多，在此记录一下关于json的一些事情。 什么是JSONw3school上给出的描述是： JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 * JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON数据书写格式是： 1name : value 其中value的值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON对象与JSON数组JSON对象JSON对象在{}中书写，对象可以包含多个键值对； 1&#123;"firstName":"John" , "lastName":"Doe"&#125; 一般JSON对象中有多个键值对时，用,隔开，最后一个键值对结束时可以不写,。 JSON数组JSON数组在[]中书写，数组可以包含多个对象。 举个栗子： 1234567&#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ]&#125; &quot;employees&quot;这个json对象包含了三个json对象的数组。 JSON的操作获取value举个例子: 12345var employees = [&#123; "firstName":"Bill" , "lastName":"Gates" &#125;,&#123; "firstName":"George" , "lastName":"Bush" &#125;,&#123; "firstName":"Thomas" , "lastName": "Carter" &#125;]; 如果要得到Bill的firstName，可以这样写： 1employees[0].firstName; 因为employees是数组，首先通过employees[0]来获取第一个对象，然后用.加要访问的字段名称，就可以获取该字段对应的值。 添加和删除JSON对象1234567var json = &#123;&#125;; //空json对像 json['firstname'] = "cheng"; //添加二个元素 json['lastname'] = "tang"; console.log(json); delete json['lastname']; //删除json中的某个元素 console.log(json); JSON数组123456789var json1 = [&#123;"name":"tang","total":"1"&#125;,&#123;"name":"zhou","total":"2"&#125;,&#123;"name":"he","total":"3"&#125;]; var add = &#123;"name":"may"&#125;; json1.push(add); //添加一个元素 console.log(json1); delete json1[2]; //删除一个元素 console.log(json1); 遍历JSON对象假设有一个JSON对象： 1var data=&#123;'a':10,'b':20,'c':30,'d':40&#125;; 怎么遍历这个对象呢，可以用for-in: 1234567for(var n in data)&#123; console.log(n); //输出 a，b，c，d console.log(data[n]); //输出 10，20，30，40&#125; 在JavaScript中[]等同于. ，所以 data[n]可以理解为data.n，只不过n是变量，用.获取不到对应的值。 JSON数组假设有一个JSON数组： 1var data=[&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125;]; 遍历这个数组： 12345678910for(var n in data)&#123; console.log(n); //输出：0，1，2，3 console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; 或者： 1234567for (var n = 0;n &lt; data.length; n++)&#123; console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; eval()与JSON.parse()eval()可以将字符串转换为 JavaScript 对象： 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = eval('('+test+')'); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 通过这个方法我们就可以动态设置key的值。但是使用这个方法会存在潜在的安全问题，所以可以用JSON.parse()，这个方法需要较高版本的浏览器支持。 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = JSON.parse(test); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 接下来就可以通过json[key] = value来设置key对应的value值。 Object.keys() Object.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。 123456789101112var bookAuthors = &#123; "Farmer Giles of Ham": "J.R.R. Tolkien", "Out of the Silent Planet": "C.S. Lewis", "The Place of the Lion": "Charles Williams", "Poetic Diction": "Owen Barfield"&#125;;var arr = Object.keys(bookAuthors);console.log(arr);//输出: Array [ "Farmer Giles of Ham", "Out of the Silent Planet", "The Place of the Lion", "Poetic Diction" ]console.log(arr.length);//输出: 4 用这个方法可以把json对象转换成数组，这样可以方便的对这个数组进行一些操作。 1234567var test = &#123; "name ": "tangcheng", "value": [1,2,3,4,5]&#125;var arr = Object.keys(test);console.log(arr.length); //输出： 2console.log(test.length) //输出：undefined Object.keys()方法，只能使用在高版本浏览器，IE8及以下是不支持的，如果想支持IE低版本，可以参考Javascript 计算Object的长度中提供的方法。 参考文章： JSON中让key作为参数传入的方法； Javascript 计算Object的长度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰Git教程学习笔记]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%BB%96%E9%9B%AA%E5%B3%B0Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[粗略看过git方面的视频，工作之前自己写的代码量少，管理方便，git方面的知识也够用。但是最近工作的时候用git总是有各种问题，于是拿起廖雪峰老师的教程，开始撸一遍完整的。 创建版本库git创建版本库很简单，只要用以下命令即可 123$ mkdir tangcheng //创建文件夹$ cd tangcheng $ git init //创建版本库 完成后文件夹下面会有一个.git的隐藏目录，这是git的版本库。 版本库管理工作区与暂存区 廖老师的这个图很清楚，工作区就是tangcheng这个文件夹，这个文件夹里面的.git隐藏目录就是版本库。 通过git add告诉git把文件添加到仓库，然后用git commit把文件提交到仓库。 git commit成功后git会记录你的修改，如果不add到暂存区，那就不会加入到commit中。可以多次git add文件，git commit一次提交多个文件。 Git基本命令git status可以参看仓库状态; git diff可以参看difference，显示格式是Unix通用的diff格式; git log可以显示从近到远的提交日志，日志中的一大串字母和数字的组合就是版本号。 git reset --hard HEAD^表示回退版本，上一个版本是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。如果回退到上一个旧版本，当前的版本则会在log中删除，若要从上一个版本回退到已经删除的版本，需要在用回退命令的命令窗口中，通过版本号找回，例如$ git reset --hard 3628164，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 若上一段中的用回退命令的命令窗口已经关闭，可以用git reflog来查看你每一次的命令和对应操作的版本号。 git checkout -- tangcheng.txt意思就是，把tangcheng.txt文件在工作区的修改（包括删除文件的操作）全部撤销，就是让这个文件回到最近一次git commit或git add时的状态。命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。 git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区 git rm从版本库中删除文件。 远程仓库把本地仓库的内容推送到GitHub仓库，在本地的tangcheng仓库下运行命令： 1$ git remote add origin git@github.com:tangcheng/tangcheng.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 $ git push -u origin master是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 1$ git clone git@github.com:tangcheng/tangcheng.git 克隆一个本地库。GitHub给出的地址不止一个，还可以用https://github.com/tangcheng/tangcheng.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理1$ git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 12$ git branch dev$ git checkout dev 用git branch命令查看当前分支。 git branch命令会列出所有分支，当前分支前面会标一个*号。 git merge dev```把`dev`分支的工作成果合并到`master`分支上，`git merge`命令用于合并指定分支到当前分支。1234567删除`dev`分支:```sh$ git branch -d dev 当Git无法自动合并分支时，就必须首先解决冲突。Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 1$ git merge --no-ff -m "merge with no-ff" dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 要查看远程库的信息，用git remote或者，用git remote -v显示更详细的信息。 推送分支： 1$ git push origin master //把master推送到远程分支 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 标签管理git tag &lt;name&gt;就可以打一个新标签。有commit为什么还要标签呢，因为commit是很长一串数字和字母的组合，阅读性差。commit和tag的关系类似于ip和域名。 用命令git tag查看所有标签。默认标签是打在最新提交的commit上的。标签不是按时间顺序列出，而是按字母排序的。 对特定的commit id打标签： 1$ git tag v0.9 6224937 可以用git show查看标签信息 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m "version 0.1 released" 3628164 如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag 'v0.1' (was e078af9) 如果要推送某个标签到远程，使用命令git push origin： 1$ git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1$ git push origin --tags 命令git push origin :refs/tags/可以删除一个远程标签。 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理。 你确实想添加该文件，可以用-f强制添加到Git： 1$ git add -f App.class .gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查 配置别名我们只需要敲一行命令，告诉Git，以后st就表示status： 1$ git config --global alias.st status 这样以后敲git st就表示git status --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 每个仓库的Git配置文件都放在.git/config文件中，别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。 配置一个git last，让其显示最后一次提交信息： 1$ git config --global alias.last 'log -1' 这样，用git last就能显示最近一次的提交： 1234567$ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现]]></title>
      <url>%2F2016%2F12%2F08%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[最近在AngularJS2中要实现一个按钮切换的效果，我采用三目表达式和ng-class的方式来实现了这一效果，比较简单粗暴。 首先，我的项目的XX.Component.ts中的template有个button标签： 12&lt;button type="submit"&gt;列表&lt;/button&gt;&lt;button type="submit"&gt;折线图&lt;/button&gt; 创建XX.Component.css，为标签添加简单的样式（我只是举个例子，这个样式的定义还可以再优化一下）： 12345678910111213141516171819.active &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: #0086FD; padding: 5px; outline: none; width: 55px;&#125;.btn-lt &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: gray; padding: 5px; outline: none; width: 55px;&#125; 然后我需要实现的效果是：加载完页面后，两个按钮都是灰色的，当你点击其中一个按钮时，按钮变成蓝色。 为了实现这个效果，我引入了begin和blue两个变量，分别控制起始状态和点击时的状态。当blue为true且begin===1时按钮变蓝色；当blue为false时或者begin！= 1时按钮变灰色。代码如下： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 这个方法还可以组合出其他不同的效果，比如说点击后当前按钮变灰： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 比如把begin去掉，可以实现加载完成后有一个按钮处于激活状态，这里我就不做gif了，可以自己尝试一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts使用小结]]></title>
      <url>%2F2016%2F12%2F04%2FEcharts%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[这周项目上写了一个基于Angular2.0的Echarts3组件，踩了好几个坑，也算有一点使用心得了。 Echarts是什么鬼 ECharts 是指 Enterprise Charts（商业产品图表库），提供商业产品常用图表库，底层基于 ZRender，创建了坐标系，图例，提示，工具箱等基础组件，并在此上构建出折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、地图、力导向布局图，同时支持任意维度的堆积和多图表混合展现。 Echarts提供了多种图表展示方式： Echarts提供了包括值域漫游、大规模散点图、数据动态添加、数据区域漫游、图例开关、动态类型切换等在内的多种数据操作方式。Echarts升级到3.0后，增加了对移动端的支持，而且体积更小，实乃数据分析必备良药。 Echarts正确打开方式首先来看官方案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 怎么样，是不是觉得很好玩，当然这只是最基本的数据展示功能，下面我们来玩一个进阶一点的Demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="gb2312"&gt; &lt;title&gt;echarts3&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;echarts3 demo&lt;/h1&gt; &lt;!--定义有大小的DOM容器--&gt; &lt;div id="barChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="lineChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="radarChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="pieChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="dotChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;!--导入js代码--&gt; &lt;script type="text/javascript" src='./jquery.js'&gt;&lt;/script&gt; &lt;script type="text/javascript" src='./echarts.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //界面最先运行这个代码块 $(document).ready(function() &#123; initBarEcharts(); initLineEcharts(); initRadarEcharts(); initPieEcharts(); initDotEcharts(); &#125;); //初始化柱状图 function initBarEcharts() &#123; var myChart = echarts.init(document.getElementById('barChart')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, dataZoom: &#123; type: 'slider', show: true, start: 1, end: 35 &#125;, tooltip: &#123;&#125;, toolbox: &#123; show: true, feature: &#123; saveAsImage: &#123; show: true, type: 'jpeg', &#125;, restore: &#123; show: true, &#125;, dataView: &#123; show: true, &#125;, magicType: &#123; show: true, &#125; &#125;, &#125;, legend: &#123; data: ['销量'] &#125;, xAxis: &#123; //x轴数据，数组形式 data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化折线图图 function initLineEcharts() &#123; var myChart = echarts.init(document.getElementById('lineChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '堆叠区域图' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎'] &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis: [&#123; type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] &#125;], yAxis: [&#123; type: 'value' &#125;], series: [&#123; name: '邮件营销', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: '联盟广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: '视频广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: '直接访问', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [320, 332, 301, 334, 390, 330, 320] &#125;, &#123; name: '搜索引擎', type: 'line', stack: '总量', label: &#123; normal: &#123; show: true, position: 'top' &#125; &#125;, areaStyle: &#123; normal: &#123;&#125; &#125;, data: [820, 932, 901, 934, 1290, 1330, 1320] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化雷达图 function initRadarEcharts() &#123; var myChart = echarts.init(document.getElementById('radarChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '基础雷达图' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['预算分配（Allocated Budget）', '实际开销（Actual Spending）'] &#125;, radar: &#123; // shape: 'circle', indicator: [&#123; name: '销售（sales）', max: 6500 &#125;, &#123; name: '管理（Administration）', max: 16000 &#125;, &#123; name: '信息技术（Information Techology）', max: 30000 &#125;, &#123; name: '客服（Customer Support）', max: 38000 &#125;, &#123; name: '研发（Development）', max: 52000 &#125;, &#123; name: '市场（Marketing）', max: 25000 &#125;] &#125;, series: [&#123; name: '预算 vs 开销（Budget vs spending）', type: 'radar', // areaStyle: &#123;normal: &#123;&#125;&#125;, data: [&#123; value: [4300, 10000, 28000, 35000, 50000, 19000], name: '预算分配（Allocated Budget）' &#125;, &#123; value: [5000, 14000, 28000, 31000, 42000, 21000], name: '实际开销（Actual Spending）' &#125;] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化饼图 function initPieEcharts() &#123; var myChart = echarts.init(document.getElementById('pieChart')); // 指定图表的配置项和数据 option = &#123; backgroundColor: '#2c343c', title: &#123; text: 'Customized Pie', left: 'center', top: 20, textStyle: &#123; color: '#ccc' &#125; &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, visualMap: &#123; show: false, min: 80, max: 600, inRange: &#123; colorLightness: [0, 1] &#125; &#125;, series: [&#123; name: '访问来源', type: 'pie', radius: '55%', center: ['50%', '50%'], data: [&#123; value: 335, name: '直接访问' &#125;, &#123; value: 310, name: '邮件营销' &#125;, &#123; value: 274, name: '联盟广告' &#125;, &#123; value: 235, name: '视频广告' &#125;, &#123; value: 400, name: '搜索引擎' &#125;].sort(function(a, b) &#123; return a.value - b.value &#125;), roseType: 'angle', label: &#123; normal: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125;, smooth: 0.2, length: 10, length2: 20 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#c23531', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化散点图 function initDotEcharts() &#123; var myChart = echarts.init(document.getElementById('dotChart')); // 指定图表的配置项和数据 var data = [ [ [28604, 77, 17096869, 'Australia', 1990], [31163, 77.4, 27662440, 'Canada', 1990], [1516, 68, 1154605773, 'China', 1990], [13670, 74.7, 10582082, 'Cuba', 1990], [28599, 75, 4986705, 'Finland', 1990], [29476, 77.1, 56943299, 'France', 1990], [31476, 75.4, 78958237, 'Germany', 1990], [28666, 78.1, 254830, 'Iceland', 1990], [1777, 57.7, 870601776, 'India', 1990], [29550, 79.1, 122249285, 'Japan', 1990], [2076, 67.9, 20194354, 'North Korea', 1990], [12087, 72, 42972254, 'South Korea', 1990], [24021, 75.4, 3397534, 'New Zealand', 1990], [43296, 76.8, 4240375, 'Norway', 1990], [10088, 70.8, 38195258, 'Poland', 1990], [19349, 69.6, 147568552, 'Russia', 1990], [10670, 67.3, 53994605, 'Turkey', 1990], [26424, 75.7, 57110117, 'United Kingdom', 1990], [37062, 75.4, 252847810, 'United States', 1990] ], [ [44056, 81.8, 23968973, 'Australia', 2015], [43294, 81.7, 35939927, 'Canada', 2015], [13334, 76.9, 1376048943, 'China', 2015], [21291, 78.5, 11389562, 'Cuba', 2015], [38923, 80.8, 5503457, 'Finland', 2015], [37599, 81.9, 64395345, 'France', 2015], [44053, 81.1, 80688545, 'Germany', 2015], [42182, 82.8, 329425, 'Iceland', 2015], [5903, 66.8, 1311050527, 'India', 2015], [36162, 83.5, 126573481, 'Japan', 2015], [1390, 71.4, 25155317, 'North Korea', 2015], [34644, 80.7, 50293439, 'South Korea', 2015], [34186, 80.6, 4528526, 'New Zealand', 2015], [64304, 81.6, 5210967, 'Norway', 2015], [24787, 77.3, 38611794, 'Poland', 2015], [23038, 73.13, 143456918, 'Russia', 2015], [19360, 76.5, 78665830, 'Turkey', 2015], [38225, 81.4, 64715810, 'United Kingdom', 2015], [53354, 79.1, 321773631, 'United States', 2015] ] ]; option = &#123; backgroundColor: new echarts.graphic.RadialGradient(0.3, 0.3, 0.8, [&#123; offset: 0, color: '#f7f8fa' &#125;, &#123; offset: 1, color: '#cdd0d5' &#125;]), title: &#123; text: '1990 与 2015 年各国家人均寿命与 GDP' &#125;, legend: &#123; right: 10, data: ['1990', '2015'] &#125;, xAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125; &#125;, yAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125;, scale: true &#125;, series: [&#123; name: '1990', data: data[0], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(120, 36, 50, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(251, 118, 123)' &#125;, &#123; offset: 1, color: 'rgb(204, 46, 72)' &#125;]) &#125; &#125; &#125;, &#123; name: '2015', data: data[1], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(25, 100, 150, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(129, 227, 238)' &#125;, &#123; offset: 1, color: 'rgb(25, 183, 207)' &#125;]) &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Echarts与Angular2.0我做组件的时候定义了ky-line标签，通过&lt;ky-line [data]=&quot;myoption&quot;&gt;&lt;/ky-line&gt;里的data属性来传递option的数据，这样拿到后端的数据后，往myoption里面push数据，并通过ky-line标签，把数据传递给Echarts中的option，这样就可以实现给echarts动态写入数据。不过要注意的是，给echarts中动态增加数据的时候，首先要搞清楚json对象和json数组的概念，不然容易出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oh_My_Zsh-终端改造]]></title>
      <url>%2F2016%2F11%2F28%2FOh-My-Zsh-%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
      <content type="text"><![CDATA[周末的时候无意中看到一篇文章终极 Shell，介绍的就是今天讲的主角Oh My Zsh 。 什么是Oh My Zsh Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 Oh My Zsh这个名字听起来就很有意思，它是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。 Oh My Zsh只是一个对zsh命令行环境的配置包装框架，但它不提供命令行窗口，更不是一个独立的APP。 更详细介绍可到官网了解，Oh My Zsh官网：http://ohmyz.sh 安装Oh My Zsh前提条件：必须已安装ZSH 我们可以在命令行中输入这个命令来查看我们的电脑上是否安装了zsh命令行 1$ zsh --version 如果安装了，这个命令就会输出zsh当前的版本号。确定 zsh 已经安装后，我们就可以继续安装Oh My Zsh了。 安装Oh My Zsh Oh My Zsh 的安装方式非常简单，可以通过curl或wget的方式，用一条命令即可安装。 curl 方式 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; wget 方式 1$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装过程中输出如下 12345678910111213141516171819202122Cloning Oh My Zsh...Cloning into &apos;/root/.oh-my-zsh&apos;...remote: Counting objects: 712, done.remote: Compressing objects: 100% (584/584), done.remote: Total 712 (delta 15), reused 522 (delta 4), pack-reused 0Receiving objects: 100% (712/712), 443.58 KiB | 27.00 KiB/s, done.Resolving deltas: 100% (15/15), done.Checking connectivity... done.Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrcCopying your current PATH and adding it to the end of ~/.zshrc for you.Time to change your default shell to zsh! __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 到这里，Oh My Zsh 就安装成功了。 设置主题安装完毕后，我们就可以使用了，咱们先来简单配置一下。Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格，主题的配置在 ~/.zshrc 文件中可以看到，用一个自己熟悉的编辑器打开这个文件，可以找到这一项： 1ZSH_THEME=&quot;robbyrussel&quot; 可以看到，我们默认使用的主题叫做robbyrussel。 Oh My Zsh默认自带了一些默认主题，存放在~/.oh-my-zsh/themes目录中。我们可以查看这些主题 12345678910111213$ ls ~/.oh-my-zsh/themes3den.zsh-theme essembeh.zsh-theme junkfood.zsh-theme rgm.zsh-themeSoliah.zsh-theme evan.zsh-theme kafeitu.zsh-theme risto.zsh-themeadben.zsh-theme example.zsh-theme kardan.zsh-theme rixius.zsh-themeaf-magic.zsh-theme fino-time.zsh-theme kennethreitz.zsh-theme rkj-repos.zsh-themeafowler.zsh-theme fino.zsh-theme kiwi.zsh-theme rkj.zsh-themeagnoster.zsh-theme fishy.zsh-theme kolo.zsh-theme robbyrussell.zsh-themealanpeabody.zsh-theme flazz.zsh-theme kphoen.zsh-theme sammy.zsh-themeamuse.zsh-theme fletcherm.zsh-theme lambda.zsh-theme simonoff.zsh-themeapple.zsh-theme fox.zsh-theme linuxonly.zsh-theme simple.zsh-themearrow.zsh-theme frisk.zsh-theme lukerandall.zsh-theme skaro.zsh-theme.... 这么多的主题可以满足你的各种偏好了，我们只需在./zshrc文件中配置需要的主题即可，比如我们想用lambda.zsh-theme这个主题，我们只要这样配置 1ZSH_THEME=lambda 请注意好多教程上这边都有&quot;&quot;，但是请把双引号去掉，不然可能安装不成功，这也算是一个小坑。 然后保存这个文件文件，再打开一个新的命令行窗口即可看到效果了。那么这么多的主题如何快速找到哪些是我们喜欢的呢，我们还可以这样设置 1ZSH_THEME=&quot;random&quot; 我们将主题设置为随机，这样在我们每次打开命令行窗口的时候，都会随机在默认主题中选择一个。这样我们如果觉得当前的主题比较喜欢，可以直接使用 echo 命令输出当前主题的名称 1$ echo $ZSH_THEME 然后再将他设置到配置文件中即可。 我使用的ys这款主题，该有的信息都能展示出来，界面如下： 启用插件Oh My Zsh 默认自带了一些默认主题，存放在~/.oh-my-zsh/plugins目录中。我们可以查看这些插件 1plugins=(git) 如需启用更多插件，可加入需启用插件的名称。如下 1plugins=(git wd web-search history history-substring-search) 更新设置自动更新oh-my-zsh 默认情况下，当oh-my-zsh有更新时，都会给你提示。如果希望让oh-my-zsh自动更新，在~/.zshrc 中添加下面这句 1DISABLE_UPDATE_PROMPT=true 要手动更新，可以执行 1$ upgrade_oh_my_zsh 卸载直接在终端中，运行uninstall_oh_my_zsh既可以卸载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo在遇到“{{”符号时出现解析报错]]></title>
      <url>%2F2016%2F11%2F24%2Fhexo%20%E5%9C%A8%E9%81%87%E5%88%B0%20%E2%80%9C%7B%7B%E2%80%9D%20%E7%AC%A6%E5%8F%B7%E6%97%B6%E5%87%BA%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99%2F</url>
      <content type="text"><![CDATA[刚刚生成了一篇文章， hexo g 时会报错， 错误信息大致如下： 123FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 128, Column 48]unexpected token: . 估计是文章的原因，试了一下，把文章移除后一切又正常了，但是就是不知道文章中哪里出错了。 网上搜了好久，发现了这篇文章：hexo 在遇到 “}}” 符号时出现解析报错。 查找资料发现有人遇到和我类似的问题，但报的是 `unexpected token: }}的错误。搜索一下我那篇文章，果然有好几处带有 }} 符号。尝试着把几处符号删除，果然正常了。看来问题真的出在 }}上面。 直接说解决方案吧，参考别人的解决方法是在 }}中间加一个空格，但因为我的是有部分教程含义的文章，所以并不想这样误导人。于是去 github 上找解决方案。 github 上给出的方法是在需要显示 }}符号的地方加上 12&gt; &#123;% raw %&#125;&#123;% endraw %&#125;&gt; &gt; 标签，标记这部分不需要解析。例如文章中可能会出现 { { something } } 的片段，写成 12&gt; &#123;% raw %&#125;&#123;&#123; something &#125;&#125;&#123;% endraw %&#125;&gt; &gt; 就可以了。 虽然有点麻烦，但也算临时解决了这个问题，这是个已知 bug ，希望后续的版本能修复吧，毕竟使用太多 hexo 专属的标签对博客以后的迁移、改版什么的来说还是很麻烦的。 但是 1&#123;% raw %&#125;&#123;% endraw %&#125; 标签在代码块中会显示出来，前一篇文章的代码块中的}}符号我就用空格隔开了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《AngularJS实战》学习笔记]]></title>
      <url>%2F2016%2F11%2F24%2F%E3%80%8AAngularJS%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[快速上手Angular核心特征–MVCMVC:model,view,controller Model：数据模型层 view：视图层、负责展示 Controller：业务逻辑与控制逻辑 MVC是一种架构模式，是三种设计模式的合体，故没有把它当做一种设计模式。 GoF (Gang of Four，四人组， 《Design Patterns: Elements of Reusable Object-Oriented Software》/《设计模式》一书的作者：Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)并没有把MVC提及为一种设计模式，而是把它当做“一组用于构建用户界面的类集合”。在他们看来，它其实是其它三个经典的设计模式的演变：观察者模式(Observer)(Pub/Sub), 策略模式(Strategy)和组合模式(Composite)。根据MVC在框架中的实现不同可能还会用到工厂模式(Factory)和装饰器(Decorator)模式。我在另一本免费的书“JavaScript Design Patterns For Beginners”中讲述了这些模式，如果你有兴趣可以阅读更多信息。 正如我们所讨论的，models表示应用的数据，而views处理屏幕上展现给用户的内容。为此，MVC在核心通讯上基于推送/订阅模型(惊讶的是 在很多关于MVC的文章中并没有提及到)。当一个model变化时它对应用其它模块发出更新通知(“publishes”)，订阅者 (subscriber)——通常是一个Controller，然后更新对应的view。观察者——这种自然的观察关系促进了多个view关联到同一个 model。 对于感兴趣的开发人员想更多的了解解耦性的MVC(根据不同的实现)，这种模式的目标之一就是在一个主题和它的观察者之间建立一对多的关系。当这个 主题改变的时候，它的观察者也会得到更新。Views和controllers的关系稍微有点不同。Controllers帮助views对不同用户的输 入做不同的响应，是一个非常好的策略模式列子。 Angular核心2–模块化html代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html ng-app="HellloAngular"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="helloAngular"&gt; &lt;!--控制器--&gt; &lt;p&gt;&#123; &#123; greeting.text&#125; &#125;,Angular&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;script src="HelloAngular_MVC.js"&gt;&lt;/script&gt;&lt;/html&gt; JS代码： 123456789var myModule = angular.module("HellloAngular", []); //创建模块myModule.controller("helloAngular", ['$scope', //创建控制器，并注入$scope function HelloAngular($scope) &#123; $scope.greeting = &#123; text: 'Hello' &#125;; &#125;]); 只有把模块创建出来以后，才能调用模块下面的方法。 1&lt;html ng-app="moduleName"&gt; Angular核心特征3–指令系统指令系统可以自定义标签： 123456789var myMoudle=angular.module("MyMoudle",[]);myMoudle.directive("hello",function () &#123; return &#123; restrict: 'E', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', //模板，替换了&lt;hello&gt; replace: true &#125;&#125;); 123456789101112&lt;!DOCTYPE html&gt;&lt;html ng-app="MyMoudle"&gt; &lt;!--ng-app相当于java中的main方法，表示从ng-app开始下面所有内容归angularjs管理--&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hello&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;script src="Hello.js"&gt;&lt;/script&gt;&lt;/html&gt; Angular核心特征4–双向数据绑定 数据更新View自动更新，view更新数据也跟着更新。 只用一个html文件实现输入的文字立刻出现在下方。（第一次看到时第一反应是，这货是黑科技~） 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;input ng-model="greeting.text"/&gt; &lt;!--生成数据模型--&gt; &lt;p&gt;&#123; &#123; greeting.text&#125; &#125;,AngularJS&lt;/p&gt; &lt;!--双括号在Angular中表示取值--&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;/html&gt; 开发、调试、测试工具 代码编辑工具：sublime、webstorm 断点调试工具：chrome插件batarang 版本管理工具：git、git小乌龟 代码合并和混淆工具：grunt 依赖管理工具：bower 单元测试工具：karma、jasmine 集成测试工具：protractor（专为AngularJS定制的测试工具） app放源代码 test下面分集成测试e2e和单元测试unit两个目录 基本概念和用法MVC MVC只是手段，终极目标是模块化和复用 AngularJS中Controller的实现方式 不要试图去复用Controller，一个控制器一般只负责一小块视图 不要在Controller中操作DOM，这不是控制器的职责 不要在Controller里面做数据格式化，ng有很好用的表单控件 不要在Controller里面做数据过滤操作，ng有$filter服务 一般来说，Controller是不会互相调用的，控制器之间的交互会通过事件进行 利用Directive实现View的复用。 AngularJS的MVC是借助于$scope实现的: $scope是一个POJO（Plain Old JavaScript Object） $scope提供了一些工具方法$watch()/$apply() $scope是表达式的执行环境（或者叫作用域） $scope是一个树形结构，与DOM标签平行 子$scope对象会继承父$scope上的属性和方法 每一个angular应用只有一个根$scope对象（一般位于ng-app上） $scope可以传播事件，类似DOM事件，可以向上也可以向下 $scope不仅是MVC的基础，也是后面实现双向数据绑定的基础 可以用angular.element($0).scope()进行调试 路由、模块、依赖注入 使用ngRoute进行视图之间的路由： 1234567891011121314151617 //创建模块，并指定模块依赖var bookStoresApp = angular.module('bookStoreApp',[ 'ngRoute','ngAnimate','bookStoreCtrls','bookStoreFilters', 'bookStoreServices','bookStoreDirectives']);bookStoreApp.config(function($routePrivider)&#123; //根据url后缀的不同，加载不同的模板，并且用不同的控制器控制 $routePrivider.when('/hello',&#123; templateUrl: 'tpls/hello.html', controller: 'HelloCtrl' &#125;).when('/list',&#123; templateUrl: 'tpls/booklist.html', controller: 'BookListCtrl' &#125;).otherwise(&#123; redirectTo: '/hello' &#125;)&#125;); ng官方推荐的模块切分方式： 任何一个ng应用都是由控制器、指令、服务、路由、过滤器、等有限的模块类型构成 控制器、指令、服务、过滤器分别放在一个模块里面（可借助与Grunt合并） 用一个总的app模块作为入口点，它依赖其他所有模块 双向数据绑定举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="UserInfoModule"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="Form.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt;双向数据绑定&lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;form class="form-horizontal" role="form" ng-controller="UserInfoCtrl"&gt; &lt;!--controller--&gt; &lt;div class="form-group"&gt; &lt;label class="col-md-2 control-label"&gt; 邮箱： &lt;/label&gt; &lt;div class="col-md-10"&gt; &lt;input ng-model="userInfo.email" placeholder="推荐使用126邮箱" type="email" class="form-control"&gt;&lt;!--调用userInfo中的email值--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-md-2 control-label"&gt; 密码： &lt;/label&gt; &lt;div class="col-md-10"&gt; &lt;input ng-model="userInfo.password" type="password" class="form-control" placeholder="只能是数字、字母及下划线"&gt; &lt;!--调用userInfo中的password值--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-offset-2 col-md-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" ng-model="userInfo.autoLogin"&gt;自动登录 &lt;!--调用userInfo中的checkbox值--&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-offset-2 col-md-10"&gt; &lt;button class="btn btn-default" ng-click="getFormData()"&gt;获取form表单的值&lt;/button&gt; &lt;button class="btn btn-default" ng-click="setFormData()"&gt;设置form表单的值&lt;/button&gt; &lt;button class="btn btn-default" ng-click="restFormData()"&gt;重置form表单的值&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930var userInfoModule = angular.module('UserInfoModule', []);userInfoModule.controller('UserInfoCtrl', ['$scope', function ($scope) &#123; //初始化userInfo数据 $scope.userInfo = &#123; email: '111@126.com', password: '112231', autoLogin: true &#125;; //获取表单中的数据 $scope.getFormData = function () &#123; console.log($scope.userInfo); &#125;; //设置表单中的数据 $scope.setFormData = function () &#123; $scope.userInfo = &#123; email: 'dddd@126.com', password: '11111', autoLogin: false &#125; &#125;; //重置表单数据 $scope.restFormData = function () &#123; $scope.userInfo = &#123; email: '111@126.com', password: '112231', autoLogin: true &#125;; &#125;&#125;]); ng-class可以做一些样式控制，比如 &lt;div ng-class=&#39;{error:isError,warning:isWaring}&#39;&gt;{ { messageText} }&lt;/div&gt; ng-show=&#39;menuState.show&#39;可以通过$scope.menuState={show:false};控制显示或者隐藏，show的值为false时隐藏，true时显示。通过ng-hide=&quot;&quot;也可以达到同样的效果。 路由可以用UI-Router来代替Angular自带的router功能。 前端路由的基本原理： 哈希# 点击后不会跳转，相当于设置了锚点，只在页内跳转 HTML5中新的historyAPI 通过js代码修改浏览器地址栏中的地址，会在浏览器中留下历史记录，但是页面不会跳转 路由的核心是给应用定义“状态” 使用路由机制会影响到应用的整体编码方式（需要预先定义好状态） 考虑兼容性问题和“优雅降级” 指令123456789101112&lt;!DOCTYPE html&gt;&lt;html ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hello&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script src="../Demo4-TwowayDataBinding/angular.min.js"&gt;&lt;/script&gt;&lt;script src="Hello.js"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myMoudle=angular.module("MyMoudle",[]);myMoudle.directive("hello",function () &#123; return &#123; restrict: 'E', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', //模板，替换了&lt;hello&gt; replace: true &#125;&#125;); restrict表示匹配模式，共有AEMC四个选项: A表示属性,&lt;div hello&gt;，是默认的匹配模式 E表示元素,&lt;hello&gt;， M表示注释,&lt;!-- directive:hello --&gt; &lt;div&gt;&lt;/div&gt;，(注意注释中的空格) C表示CSS的样式类,&lt;div class=&#39;hello&#39;&gt; A和E两种匹配模式比较常用，当需要创建带有自己的模板的指令时，使用元素名称的方式创建指令；当需要为已有的HTML标签增加功能时，使用属性的方式创建指令。 template表示模板，这里可以用templateURL来实现（需要导入templateUrl.js），即templateUrl: &#39;hello.html&#39;把已有的模板写在单独的html文件中。templateCache可以让模板不仅在一个地方使用，还可以在其他地方使用，Angular会把模板缓存起来，以便后续使用。 12345678910111213var myModule=angular.module('MyModule',[]);//run方法表示注射器加载完所有的模块时，此方法执行一次myModule.run(function($templateCache)&#123; $templateCache.put("hello.html","&lt;div&gt;Hello everyone&lt;/div&gt;")&#125;);myModule.directive("hello",function($templateCache)&#123; return&#123; restrict: 'AECM', template: $templateCache.get("hello.html"), replace:true &#125;&#125;) replace表示标签里面嵌套的内容被模板全部替换 transclude表示保留标签里面的内容: 12345678var myModule=angular.module('MyModule',[]);myModule.directive("hello",function()&#123; return&#123; restrict: "AE", transclude: true, template: "&lt;div&gt;Hello everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;" &#125;&#125;) ng-transclude表示原来标签里面嵌套的内容放在此处。 指令执行的机制 compile函数用来对模板自身进行转换，而link函数负责在模型和视图之间进行动态关联； 作用域在链接阶段才会被绑定到编译之后的link函数上； compile函数仅仅在编译阶段运行一次，而对于指令的每一个实例，link函数都会执行一次； compile函数可以返回prelink和postlink函数，而link函数只会返回postlink函数； 如果需要修改DOM结构，应该在postlink中来做这件事情，而如果在prelink中做这件事情会导致错误； 大多数时候我们只要编写link函数即可 指令和控制器之间的交互1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="Myctrl"&gt; &lt;loader&gt;滑动加载&lt;/loader&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="Directive.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819var myModule=angular.module("MyModule",[]);myModule.controller("MyCtrl",["$scope",function ($scope) &#123; $scope.loadData=function () &#123; console.log("加载数据中"); &#125;&#125;]);myModule.directive("loader",function () &#123; return&#123; restrict: "AE", link: function (scope,element,attrs) &#123; //用link来实现监听事件 element.bind("mouseenter",function () &#123; // scope.loadData(); //第一种写法 scope.$apply('loadData()'); //第二种写法 &#125;) &#125; &#125;&#125;); 若需要根据不同的控制器调用不同的方法，需要用到指令上定义的属性。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="Myctrl"&gt; &lt;loader howToLoad="loadData()"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller="Myctrl2"&gt; &lt;loader howToLoad="loadData2()"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="Directive.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819202122232425var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.loadData=function () &#123; console.log("加载数据中"); &#125;&#125;]);myModule.controller("Myctrl2",["$scope",function ($scope) &#123; $scope.loadData2=function () &#123; console.log("加载数据中。。。"); &#125;&#125;]);myModule.directive("loader",function () &#123; return&#123; restrict: "AE", link: function (scope,element,attrs) &#123; element.bind("mouseenter",function (event) &#123; //前面howtoload是按驼峰法则写的，但这边需要写成小写，这是一个坑，要注意。还有howtoload不要写成函数调用形式。 scope.$apply(attrs.howtoload); &#125;); &#125; &#125;&#125;); 上述代码实现了指令的复用，指令load通过howtoload属性实现了与控制器的交互，通过不同的控制器控制不同的属性，实现load输出的不同，可以简单的理解为标签load通过自身的howtoload属性，调用不同的控制器，实现不同的输出。 指令之间的交互123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="superman.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman strength&gt;动感超人-力量&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman speed strength&gt;动感超人2-力量+敏捷&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman light speed strength&gt;动感超人3-力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var myMoudle = angular.module("MyMoudle", []);myMoudle.directive("superman", function () &#123; return &#123; scope: &#123;&#125;, //创建独立的作用域 restrict: "AE", controller: function ($scope) &#123; /*指令内部的controller，用来暴露一组public的方法给外面调用*/ $scope.abilities = []; this.addStrength = function () &#123; $scope.abilities.push("strength"); &#125;; this.addSpeed = function () &#123; $scope.abilities.push("speed"); &#125;; this.addLight = function () &#123; $scope.abilities.push("light"); &#125;; &#125;, //link是用来处理指令内部的事物（绑定事件等），controller是暴露方法给外面调用 link: function (scope, element, attrs) &#123; element.addClass('btn btn-primary'); element.bind("mouseenter", function () &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myMoudle.directive("strength", function () &#123; return &#123; //require表示指令依赖于Superman require: '^superman', //Angular处理的时候会把supermanCtrl注入link中，这样就可以调用superman的addStrength()函数 link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myMoudle.directive("speed", function () &#123; return &#123; require: '^superman', link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myMoudle.directive("light", function () &#123; return &#123; require: '^superman', link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); 指令之间的交互方式是通过指令内部controller暴露出来的方法，来给外部调用。 若没有独立scope，scope之间会相互影响。 scope的绑定策略： @:把当前属性作为字符串传递。你还可以绑定来自外层scope的值，在属性值中插入{ { } }即可 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; &lt;drink flavor="&#123; &#123; ctrlFlavor&#125; &#125;"&gt;&lt;/drink&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scopeAT.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.ctrlFlavor="bb";&#125;]);myModule.directive("drink",function () &#123; return&#123; restrict: 'AE', template: '&lt;div&gt;&#123; &#123; flavor&#125; &#125;&lt;/div&gt;', scope: &#123; //作用等价于下面的link,获取控制器中的flavor flavor: '@' &#125;/*, link: function (scope,element,attrs) &#123; scope.flavor=attrs.flavor; &#125;*/ &#125;&#125;); =：与父scope中的属性进行双向绑定 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; Ctrl: &lt;br&gt; &lt;input type="text" ng-model="ctrlFlavor"&gt; &lt;br&gt; Directive: &lt;br&gt; &lt;drink flavor="ctrlFlavor"&gt;&lt;/drink&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scope-equal.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.ctrlFlavor="bb";&#125;]);myModule.directive("drink",function () &#123; return&#123; restrict: 'AE', template: '&lt;input type="text" ng-model="flavor"/&gt;', //控制器和指令中的内容同步 scope: &#123; flavor: '=' &#125; &#125;&#125;); ​ &amp;：传递一个来自父scope的函数，稍后调用 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scope-and.js"&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112131415var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.sayHello=function (name) &#123; alert("Hello"+name); &#125;&#125;]);myModule.directive("greeting",function () &#123; return&#123; restrict: 'AE', template: '&lt;input type="text" ng-model="userName"/&gt;&lt;br&gt;'+'&lt;button class="btn btn-default" ng-click="greet(&#123;name:userName&#125;)"&gt;Greeting&lt;/button&gt;&lt;br&gt;',//这边的name绑定到上面的userName scope: &#123; greet: '&amp;' &#125; &#125;&#125;); AngularJS内置的指令 form指令 html原生form表单是不能嵌套的，而Angular封装之后的form可以嵌套； Angular为form扩展了自动校验、防止重复提交等功能； Angular对input元素的type进行了扩展，一共提供了以下10种类型：text、number、url、email、radio、checkbox、hidden、button、submit、reset； Angular为表单内置了4种CSS样式：ng-valid、ng-invalid、ng-pristine、ng-dirty； 内置校验器：require、minlength、maxlength。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="form.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name="myForm" ng-submit="save()" ng-controller="TestFormModule"&gt; &lt;input type="text" name="userName" ng-model="user.userName" required/&gt; &lt;!--required表示自动校验--&gt; &lt;input type="password" name="password" ng-model="user.password" required/&gt; &lt;input type="submit" ng-disabled="myForm.$invalid"/&gt; &lt;!--绑定到$invalid的属性上--&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910var appModule=angular.module('MyMoudle',[]);appModule.controller('TestFormModule',function ($scope) &#123; $scope.user=&#123; userName: 'aaaaa', password: '' &#125; ; $scope.save=function () &#123; alert("保存数据"); &#125;&#125;); expander指令 expander指令是自定义指令 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="expander.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="SomeController"&gt; &lt;expander class="expander" expander-title="title"&gt; &#123; &#123; text&#125; &#125; &lt;/expander&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425var appModule = angular.module('MyMoudle', []);appModule.directive('expander', function () &#123; return &#123; restrict: 'AE', replace: true, transclude: true, scope: &#123; title: '=expanderTitle' &#125;, template: '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123; &#123; title&#125; &#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', /*ng-show决定了是否显示*/ link: function (scope, element, attrs) &#123; scope.showMe = false; scope.toggle = function () &#123; scope.showMe = !scope.showMe; &#125; &#125; &#125;&#125;);appModule.controller('SomeController', function ($scope) &#123; $scope.title = '点击展开'; $scope.text = '这里是内部内容';&#125;); according指令 封装一个比较复杂的according指令 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="according.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller="SomeController"&gt;&lt;div&gt; &lt;according&gt; &lt;expander class="expander" expander-title="expander.title" ng-repeat="expander in expanders"&gt; &#123; &#123; expander.text&#125; &#125; &lt;/expander&gt; &lt;/according&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var appModule = angular.module('MyMoudle', []);appModule.directive('according',function () &#123; return&#123; restrict: 'AE', replace: true, transclude: true, template: '&lt;div ng-transclude&gt;&lt;/div&gt;', controller: function () &#123; var expanders=[]; this.gotOpened=function (selectedExpander) &#123; angular.forEach(expanders,function (expander) &#123; if (selectedExpander != expander)&#123; expander.showMe=false; &#125; &#125;) &#125;; this.addExpander=function (expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);appModule.directive('expander', function () &#123; return &#123; restrict: 'AE', replace: true, transclude: true, require: '^?according', scope: &#123; title: '=expanderTitle' &#125;, template: '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123; &#123; title&#125; &#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', /*ng-show决定了是否显示*/ link: function (scope, element, attrs,accordingController) &#123; scope.showMe = false; accordingController.addExpander(scope); scope.toggle = function () &#123; scope.showMe = !scope.showMe; accordingController.gotOpened(scope); &#125; &#125; &#125;&#125;);appModule.controller('SomeController', function ($scope) &#123; $scope.expanders=[&#123; title: 'Click me to expander', text: 'Hi' &#125;,&#123; title: 'Click this', text: 'Yes' &#125;,&#123; title: 'Test', text: 'test' &#125;];&#125;); angular-ui提供了现成的指令库，可直接使用。 以miniui为例子 Service与Provider使用$HTTP服务类似Ajax 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="http.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="LoadDataCtrl"&gt; &lt;ul&gt; &lt;li ng-repeat="user in users"&gt; &#123; &#123; user.name&#125; &#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314var myModule=angular.module('MyMoudle',[]);myModule.controller('LoadDataCtrl',['$scope','$http',function ($scope,$http) &#123; $http(&#123; method: 'GET', url: 'data.json' &#125;).success(function (data,status,header,config) &#123; console.log("success"); console.log(data); $scope.users=data; &#125;).error(function (data,status,header,config) &#123; console.log("error"); &#125;)&#125;]); Service的特性 Service都是单例的 Service由$injector负责实例化,不需要new Service在整个应用的生命周期中存在，可以用来共享数据 在需要使用的地方利用依赖注入机制注入Service 自定义的Service需要写在内置的Service后面 内置Service的命名以$符号开头，自定义的Service应该避免 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="MyService1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="LoadDataCtrl"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type="text" ng-model="username" placeholder="请输入用户名"/&gt; &lt;pre ng-show="username"&gt;&#123; &#123; users&#125; &#125;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132var myModule=angular.module('MyMoudle',[]);myModule.factory('userListService',['$http',function ($http) &#123; var doRequest=function (username,path) &#123; return $http(&#123; method: 'GET', url: 'users.jon' &#125;); &#125; return &#123; userList: function (username) &#123; return doRequest(username,'userList'); &#125; &#125;;&#125;]);//自定义的服务放在最后myModule.controller('serviceController',['$scope','$timeout','userListService',function ($scope,$timeout,userListService) &#123; var timeout; //防止频繁向后台请求，导致页面抖动，350ms不按键就传输数据 $scope.$watch('username',function (newUserName) &#123; if (newUserName)&#123; if(timeout)&#123; $timeout.cancel(timeout); &#125; timeout=$timeout(function () &#123; userListService.userList(newUserName).success(function (data,status) &#123; $scope.users=data; &#125;); &#125;,300); &#125; &#125;);&#125;]); Service、Provide、Factory本质都是Provider Provider模式是“策略模式”+“抽象工厂模式”的混合体 使用$filter服务 $filter是用来进行数据格式化的专用服务 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="filter.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--利用内置的filter把毫秒转化成日期--&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date &#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date:"MM/dd/yyyy@h:mma"&#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date:"yyyy-MM-dd hh:mm:ss"&#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 1var myModule=angular.module('MyMoudle',[]); AngularJS内置了9个filter：currency（用来格式化货币），date（用来格式化日期），json，limitTo，lowercase，number，oderBy（排序），uppercase filter可以嵌套使用（用管道符号|分隔） filter是可以传递参数的 用户可以定义自己的filter 其他常用的Service内置的共有24个 $compile：编译服务 $filter：数据格式化工具，内置8个 $interval $timeout $locale：用来做国际化 $location：监控浏览器地址栏中的变化 $log：提供日志 $parse $http：封装了Ajax]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小记]]></title>
      <url>%2F2016%2F11%2F14%2F%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[工作终于有了着落，也算半只脚跨入了心仪已久的行业。 因为行业跨度太大，一路走来承受了很多压力，也很庆幸自己真的走过来了。 这几个月经常为了一个问题弄到凌晨三四点，每天一成不变的白米饭加老干妈。自己也迷茫过、质疑过、崩溃过，但是既然自己选择了这条路，那就要走到底。 感谢女朋友的陪伴，在我迷茫、崩溃的时候依然愿意在我身边。 感谢汪汪和田野的帮助，给了我那么一大箱的书，耐心解答我的问题，把我这个门外汉一步步领进门。 很庆幸，在年轻的时候能尝试去做自己想做的事情，尽管前路漫漫，充满更多的未知。 希望多年后，自己依然对技术保持一颗火热的心，依然充满激情。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于有自己的域名啦]]></title>
      <url>%2F2016%2F11%2F12%2F%E7%BB%88%E4%BA%8E%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E5%95%A6%2F</url>
      <content type="text"><![CDATA[双十一大家都在买买买的时候，有一个小码农也不甘寂寞，默默地在Namecheap上买了一个域名，完成了双十一的剁手之旅。 剁手之旅参照了新版Namecheap注册域名详细教程，还是比较简单的。不过我的域名解析用的是DNSPOD，没有用Namecheap的域名解析，这样国内的用coding访问，国外用github访问，可以加快网站访问速度。 Github的设置比较简单，在/hexo/source中添加一个CNAME文件，注意不需要后缀名，里面内容就写tc9011.com，不要写www。然后去github page上绑定一下域名，DNS解析的话我是这样设置的： 下面说一下新版的coding绑定域名的问题，我发现这是一个大坑啊~~ 我直接访问tc9011.github.io地址会跳转到tc9011.com,我直接访问tc9011.coding.me发现不会跳转到tc9011.com这个域名，原因我搜了一下，答案如下： github只能绑定一个域名，所以访问tengj.github.io时，github的服务器知道要往tengj.top跳转。coding可以绑定多个域名，当绑定多个域名时，访问tengj.coding.me,coding的服务器不知道要往哪里跳转，所以干脆就不跳转了。但是当绑定一个时，为什么不跳转，可能是coding觉得麻烦，就不跳转了。这些都是coding定的，我们没办法改变。 你先想一个问题：那么多人都要在github上搞博客，还要自定义域名。github哪来这么多ip给你们用？所以办法就是仅仅提供一个ip，这样必然导致这个服务器上发着所有人的博客文件，那么如何区分特定的域名应该展示谁的博客呢？答案就是在仓库里面新建一个CNAME文件，里面写上你博客想用的域名，github的服务器会根据当前http请求的Host头部（即域名），查找对应的包含相同的CNAME内容的目录，从而显示其中的页面。这就是为什么要在仓库里面创建一个CNAME原因。 不过，事情还没完，一个ip的问题是世界各地不同地点的访问速度不同，有些地方可能很慢，所以需要一组ip来分担一下。最早github好像只有2个ip，后来ip变多了。再后来，github支持域名解析的时候，通过alias来。比如在域名商那边设置成www.tengj.com ---&gt; tengj.github.io，由于github无法控制你如何配置域名和ip的关系，但他可以控制tengj.github.io的最终ip解析，所以github推荐大家使用alias解析，可以为博主提供就近ip访问。这就是你在域名商那边配置CNAME或者alias的原理。这里的CNAME跟上面提到的CNAME作用不同，不是一个概念，不要混淆。 还有就是coding.me的现在是指向国外的，不像以前是指向国内的，我也是醉了~ 要把博客同步到coding，首先要在coding里面新建一个与你Global Key（也就是个性后缀）一样的项目，然后修改博客根目录下面的_config.yml文件中的deploy如下（注意缩进）： 和github一样配置ssh，过程就不详细说了，比较简单。比较重要的是，在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 12cd source/touch Staticfile #名字必须是Staticfile 接下来在coding pages服务中绑定域名，注意分支一定要写master。 最后去DNSPOD上设置一下域名解析： 然后检测一下域名解析是否正确，国内解析到coding，国外解析到github，后面国外的解析很多是解析到美国 Fastly公司CDN网络节点，这个就是github的解析，所以国内的解析估计就是coding了，虽然也是指向国外，ORZ。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[近期对HEXO博客的一些优化]]></title>
      <url>%2F2016%2F11%2F08%2F%E8%BF%91%E6%9C%9F%E5%AF%B9HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前几天参加了一场面试，面试时展示我的博客时，发生了一个比较尴尬的事情：博客打开页面空白，此时我内心是崩溃的，明明昨天晚上还好好的。。。 回来后我就开始着手对我的博客进行bug调试和优化。 CSS JS 404导致博客页面空白首先解决这个问题，，在上网简单搜索了一下，导致这个结果的原因应该是： GitHub Pages 过滤掉了 source/vendors 目录的访问，所以next主题下的source下的vendors目录不能够被访问到，所以就出现了本地hexo s能够正常访问，但是deploy到github就是一片空白，按f12，可以看到大量来自source/vendors的css和js提示404 参考回答 解决方案正如github里面说说的： 找到解决方案了。。 @BBBOND @monsterLin @SpadeRoy 根据作者的提示 @iissnan ，首先修改source/vendors为source/lib，然后修改_config.yml， 将 _internal: vendors修改为_internal:lib 然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。 然而我觉得这个太麻烦了，毕竟要改很多东西，既然新版本已经修复这个问题了，那我就重新安装吧。安装前先把文件先备份了一下，然后就按照Next官网的说明，使用git来clone最新版本（之前我是下载安装）。 在终端窗口下，用cd定位到Hexo站点目录，然后clone，具体代码如下： $ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next cd后面的“your-hexo-site”改成你自己的hexo路径。 安装完了把主题目录下的_config.yml文件替换成更新前的文件，其中的_internal: vendors修改为_internal:lib （大概在347行的地方），然后这个bug就可以解决了。 使用google字体影响网页加载效率对网页加载进行分析后，发现有三个东西影响网页加载效率： 首先是Swiftype 搜索，这个是因为墙的原因，但是我又不想替换成localsearch，所以这个问题就先略过； 第二个是不蒜子统计，本来想替换成腾讯分析，但是貌似需要先给博客买个域名，然后腾讯分析才能识别，不然光是tc9011.github.io是识别不到的，这个涉及到购买域名，域名解析等问题，所以我暂时忍一下（其实是没钱了T^T）； 最后一个就是google字体，其实国内可以通过360cdn来访问。具体方法如下： 找到\themes\next\layout_partials\head\external-fonts.swig文件，把里面的fonts.googleapis.com 改成fonts.useso.com 实践证明，改过后速度更慢了，于是我又改回了fonts.googleapis.com，ORZ 添加留言本页面之前添加了多说评论，无意中看到别人家的博客中有留言本功能，于是我也想整一个。其实方法也是蛮简单的。 1、添加留言本page先cd到博客根目录，然后运行： hexo new page guestbook 2、在留言本页面中添加多说代码进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件添加以下代码： &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 然后登陆自己多说站点，进入设置-&gt;自定义CSS，添加 123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置头像长宽*/ border-radius: 27px; /*设置头像圆角效果*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置头像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隐藏多说版权*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 3、菜单中设置留言本找到NexT主题设置的_config.yml文件里面的menu项 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 在menu_icons下为留言本设定图标： 1234567891011menu_icons: enable: true#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat search: search guestbook: book 我用的是 book 这个图标，如果想要设定为其他图标，请访问：Font Awesome Icons，找到喜欢的图标，记录下图标后的关键字再填写到 menu_icons 下。 4、添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言 SEO优化1、添加robots.txt可以参考我的robots.txt，代码如下 1234567891011121314# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://tc9011.github.io/sitemap.xmlSitemap: https://tc9011.github.io/baidusitemap.xml 把robots.txt放在你的hexo站点的source文件下即可。 2、添加sitemap网站地图之前学了SEO，尝试也给自己网站做一下SEO，具体方法如下： 安装hexo的sitemap网站地图生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码 123# hexo sitemap网站地图sitemap:path: sitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。​ 3、给非友情链接的出站链接添加“nofollow”标签以hexo的NexT主题为例，需要修改两处 找到footer.swig,路径在your-hexo-site\themes\next\layout\_partials，将下面代码 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 改成 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io" rel="external nofollow"&gt;Hexo&lt;/a&gt;') &#125;&#125; 将下面代码 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 改成 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout\_macro，将下面代码 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" rel="external nofollow"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank"&gt; 改成 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank" rel="external nofollow"&gt; 这是根据动动手指，不限于NexT主题的Hexo优化（SEO篇来进行优化的，优化过程中发现，还是需要有自己的域名，不然百度抓不到你的数据，哎~等工作了一定要买一个域名（奋斗脸）。 多说评论不稳定，加载速度慢优化加载多说的时候，因为对方服务器的原因，很不稳定，经常刷不出多说评论，所以决定优化一下，多说评论不稳定，加载速度慢优化方法，主要参考这篇文章进行了优化，具体方法： 在七牛镜像储存中，镜像源地址填写http://static.duoshuo.com，然后保存。 加速成功后，可以通过七牛提供的空间访问域名访问到多说镜像网站，例如我的默认域名是http://og9ocpmwk.bkt.clouddn.com/，直接可以链接到多说的镜像网站。 下载多说核心脚本embed.js，需要更改一处地方代码， 1function n(e)&#123;j.theme=e,"none"!=e&amp;&amp;o.injectStylesheet(j.STATIC_URL+"/styles/embed"+(e?"."+e+".css?"+R[e]:"."+short_name)+".css")&#125; 上面代码应该是调用多说样式embed.xxx.css，我们需要修改成我们七牛镜像的多说样式，只需把j.STATIC_URL更改成七牛空间访问域名，例如我修改成&quot;http://og9ocpmwk.bkt.clouddn.com&quot;。更改后另存为dsembed.js（重命名主要防止与七牛镜像中的embed.js冲突）。最后上传到七牛空间里。现在你可以通过地址/dsembed.js访问经过七牛CDN加速后的多说核心脚本。 把多说默认引入static.duoshuo.com域名下的embed.js更改成七牛空间更改后的dsembed.js即可。 这里以多说通用代码为例， 12345678910111213141516&lt;!-- 多说评论框 start --&gt; &lt;div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type="text/javascript"&gt;var duoshuoQuery = &#123;short_name:"araolin"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; embed.js引入的代码是 1ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; 这里需要更改成 1ds.src = '这里是你的七牛空间embed.js的地址'; 以我的为例，我更改成了 1ds.src = 'http://og9ocpmwk.bkt.clouddn.com/dsembed.js'; 如果你是hexo Next主题的话，需要更改的文件是duoshuo.swig，具体路径在your-hexo-site\themes\next\layout\_scripts\comments目录里。​ 最后值的注意的是，因为我的网站是https://tc9011.github.io，上面的链接若写成http的话，也会加载不了多说评论。所以下面是针对https的一些修改： 首先给七牛账户充值11块钱，不然这个功能木有办法用~ 进入存储资源列表，然后点击下图所示的https域名，七牛会自动生成一个域名； 在内容管理里面选择刚刚生成的域名作为默认外链域名，记得保存。 把内容管理里面的文件先全部删掉，把上面dsembed.js文件重命名一下，主要防止没有覆盖旧文件，比如我命名为dembed.js，再把文件中添加http://og9ocpmwk.bkt.clouddn.com的地方都改成新的外链地址，比如我的https://ogddl0byd.qnssl.com，然后保存，上传七牛。 把duoshuo.swig中的src替换成新的域名。 1ds.src = 'https://ogddl0byd.qnssl.com/dembed.js'; ​ 最后其实博客还有优化空间，比如有几个js加载速度简直是慢的令人发指，尝试了压缩代码，还是不行，感觉还是要把他们托管到其他地方，这个以后慢慢优化，可能以后买个域名，把博客同时托管到coding和github，国内访问coding，国外访问github，具体怎么操作，请听下回分解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEO与Yahoo军规]]></title>
      <url>%2F2016%2F11%2F01%2FSEO%E4%B8%8EYahoo%E5%86%9B%E8%A7%84%2F</url>
      <content type="text"><![CDATA[《SEO在网页制作中的应用》与《Yahoo军规》课程总结 SEO与搜索引擎首先SEO是什么： SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化（比如网站结构调整、网站内容建设、网站代码优化等）以及站外优化（比如网站站外推广、网站品牌建设等），使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。 根据课程内容我自己画了上面这张图，这里以百度搜索引擎为例子说明一下，百度搜索引擎数据库通过百度蜘蛛爬取互联网上数据，这些数据是搜索引擎数据库中没有的，且有用的数据，理想状态下，用户输入关键字搜索，百度通过搜素引擎数据库中与关键字最匹配的结果返回给用户。 百度蜘蛛怎么才能更好的爬取数据呢，这就要通过网站的SEO，让网站用百度蜘蛛听得懂的语言和它交流，让它能更了解你的网站。SEO分为白帽SEO和黑帽SEO。黑帽SEO通过伪装让搜索引擎以为网站和某个关键字有联系，但实际上并没有；白帽SEO则通过上图列出的方法，让网站用百度蜘蛛听得懂的语言更好的去与搜索引擎交流。 网站结构与代码优化 结构布局优化：用扁平化结构 网站结构层次越少越容易被蜘蛛获取，中小型网站，目录层次结构超过3层，蜘蛛就不愿意往下爬。 控制首页链接数量 首页链接数量不能太少也不能太多，中小型企业首页链接在100个以内，例如：页面导航、底部导航、锚文字链接等。 扁平化目录层次 网站的设计不要用纵线性的结构。 导航SEO优化 尽量用文字，如果是图片，alt和title必须要有，面包屑导航（一般页面左上角的XX&gt;&gt;XX&gt;&gt;XX就是，便于了解当前位置和返回）。 页码 页码尽量用 首页 1 2 3 下一页 或者 首页 1 2 3 4 下拉菜单 这样方便蜘蛛抓取内容。 页面布局 左边正文，右边放热门文章和相关文章。 网速 控制页面不要超过100k，不然加载太慢。 网页代码 &lt;title&gt;标题 &lt;meta keywords&gt;关键词 &lt;meta description&gt;网页描述 HTML标签语义化 &lt;a&gt;要有title，对于指向其他网站的链接要写rel=&quot;nofollow&quot; &lt;h1&gt;用于正文标题，副级标题用&lt;h2&gt; &lt;table&gt;标签要写&lt;caption&gt;表格标题&lt;/caption&gt; &lt;img&gt;标签应使用alt说明 &lt;strong&gt;的权重&gt;&lt;em&gt;的权重，如果只为加粗斜体效果建议用&lt;b&gt;和&lt;i&gt;标签 重要内容HTML代码放在最前面 重要内容不要用JS输出 尽少使用iframe框架 谨慎使用display:none，不想显示的内容可以用z-index或者显示在浏览器显示范围之外。蜘蛛会过滤掉display:none中的内容 Yahoo军规 尽量减少HTTP的请求数 可以将图片合并、JavaScript代码合并、css样式合并 使用CDN（内容分发网络） CDN:内容分发网络。意思是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 用简单的话说就是，在离你最近的地方，放置一台性能好链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 添加Expire/Cache-Control头 expire头的内容是一个时间值，值就是资源在本地的过期时间、存在本地。在本地缓存阶段，找到一个对应的资源值，当前时间还没超过资源的过期时间，就直接使用这一个资源，不会发送http请求。 Cache-Control是http协议中常用的头部之一，顾名思义，他是负责控制页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，也有更多的处理方式 启用Gzip压缩 将HTML、JavaScript、CSS、PHP等文件进行Gzip压缩，可以显著减小文件的体积。 将CSS放在页面最上方 避免页面出现空白或者闪烁，提高浏览器的渲染性能。 将Script放在页面最下面 先将内容呈现出来，不会让用户等太久。 避免在CSS中使用Expressions 在CSS中用了JavaScript的计算式，在页面显示和缩放、页面滚动、移动鼠标时CSS Expressions都会重新计算一次，严重影响性能。 把JS和CSS都放到外部文件中 JS和CSS单独提取出来，提高了JS和CSS的复用性，减少页面体积，提高了JS和CSS的可维护性；JS和CSS内置可以减少页面请求，提高页面渲染，若JS和CSS很少、只应用于一个页面或者不经常被访问到时可以这样使用。两者各有优势，灵活取用。 减少DNS查询 当缓存时间长时，减少DNS的重复查找，节省时间；当缓存时间短时，及时的检测网站服务器的变化，保证准确性。 压缩JavaScript和CSS 可以去除不必要的空白符、格式符、注释符，简写方法名、参数名压缩JS脚本。 避免重定向 重定向：用户的原始请求被重新转向到了其他请求 重定向状态码：301 Moved Permanently，表示用户请求的页面被移动到了另一个位置，客户端收到这个后会重新发起一次请求，是永久重定向；302 Found，表示用户请求的页面被找到了，但不在原始位置，服务器会返回一个地址，客户端会重新发起一次请求，是临时重定向。 用301重定向可以使搜索引擎识别，更新新的地址；用302总是会先找到旧地址再跳到新地址。 移除重复的脚本 配置实体标签（ETag） ETag属于HTTP协议，是使用特殊的字符串来标识某个请求资源版本，如果客户端缓存中的版本和服务器中的版本一致，服务器就不需要再传递。 使用AJAX缓存 post请求每次都执行，不被缓存；get请求时同一地址不重复执行，可以被缓存。 看完这两课觉得以前自己码的东西还有很多要修改的，前端之路，任重而道远。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Github和Hexo的个人博客搭建]]></title>
      <url>%2F2016%2F10%2F31%2F%E5%9F%BA%E4%BA%8EGithub%E5%92%8CHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[花了两天终于把基于Github和Hexo的个人博客搭建好了，期间踩了不少坑，在此作为第一篇正式博文记录一下。 Hexo这里还是要说一下Hexo，它是一款基于Node.js的静态博客框架，可以换不同主题，自定义各种样式，个人觉得还是蛮不错的（因为你只用过这一个，呵呵）。 Hexo特性： Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 支持GitHub Flavored Markdown和所有Octopress的插件。 Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。 Hexo官网 ，官网也是基于Github构件的网站。 配置环境及安装Git的安装就跳过了，比较简单。下面说一下Node.js安装。 可以去node.js Git和Node.js安装完了就可以用npm安装Hexo，在mac的终端内输入下面的命令： 1$ npm install -g hexo-cli 然后Hexo就安装完成啦。安装好后，需要对Hexo初始化，在终端中挨个执行下面的命令，其中用指定的文件夹路径代替，一定要cd，不要问我为什么，都是血的教训： 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 至此，所有的安装工作都完成，撒花~ 完成后，目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 建站及部署安装完成后就可以通过下面的命令生成静态页面 hexo g 然后启用本地服务 hexo s 进入浏览器输入http://localhost:4000 就可以看到网站的效果，当然刚开始是默认样式。 下面我们就把网站部署到Github（此处我当你已经弄好github的ssh了） 登陆Github后创建一个名字为your_name.github.io（your_name替换成你的用户名）的仓库； 然后打开hexo下面的_config.yml，翻到最后面， 将下面的信息补充完整（your_name都换成你自己的用户名），注意Hexo 5.0以后type应该写成git而不是github，这又是一处血的教训（姚明脸）。 123type: git repository: https://github.com/your_name/your_name.github.io branch: master 然后分别执行以下命令部署本地博客到github 12hexo ghexo d 然后在浏览器里面输入your_name.github.io就可以访问你自己的博客啦！ NexT主题安装Hexo有好多主题，经过筛选，我选择了NexT，点击链接可以去官网看看，安装教程写的蛮详细的，我就不多说了。这里说一下一些要注意的地方吧，毕竟我踩的坑还是蛮多的，呵呵。 swiftype按照教程生成key后，那个框是不能下拉的，但是你的key却在你看不见的最底下，用command+A，然后command+C复制出来就行，key就是那一串大写字母，不要单引号，swiftype_key:后面记得加空格。 用LeanCloud来统计文章阅读次数，我是参考了这篇文章——&gt;&gt;最简便的方法搭建Hexo+Github博客,基于Next主题，记的在修改主题配置文件_config.yml时候，一定要把下面enable设置为true。 1234leancloud_visitors: enable: true app_id: ytnok33cvEchgidigtb0WumC-gzGzoHsz #&lt;AppID&gt; app_key: SrcG8cy1VhONurWBoEBGGHML #&lt;AppKEY&gt; 设置网站图标Favicon，用比特虫把图制作好后，上传到云存储空间（我用的是七牛），获取图片的网址，然后打开主题配置文件_config.yml，找到favicon字段，将图片网址粘贴在后面，即可。 其他东西跟着教程做起来都还好。]]></content>
    </entry>

    
  
  
</search>
