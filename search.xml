<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[我心红蓝]]></title>
      <url>%2F2017%2F03%2F09%2F%E6%88%91%E5%BF%83%E7%BA%A2%E8%93%9D%2F</url>
      <content type="text"><![CDATA[new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: true, showlrc: 0, music: { title: "巴萨队歌", author: "巴萨", url: "http://og9ocpmwk.bkt.clouddn.com/%E5%B7%B4%E8%90%A8%E9%98%9F%E6%AD%8C.mp3", pic: "https://ooo.0o0.ooo/2017/03/09/58c165351ef44.jpg", } }); 今天凌晨看完球到现在久久不能平静，虽然加午休只睡了5个小时，但是到现在仍然竟然一点都不困，仍然处于亢奋状态，我想这就是足球的魅力吧。 看比赛前我觉得已巴萨这几场比赛的状态，我觉得打巴黎个4比0是不成问题的，毕竟大巴黎没了大奉先后，实力根本和巴萨不是一个档次的。 恩里克也排出了3-3-4阵型，我也是第一次在欧冠上看到一上来就是4前锋的阵型，巴萨全队看来是众志成城。 上半场理所当然的压着大巴黎，运气也在巴萨这边，小白造的乌龙球球真的是当时久攻不下的强心剂。当时我就想似乎按照这样下去巴萨有可能踢个4比0打加时，或者5比0直接晋级，当然这场被称为欧冠有史以来最伟大的逆转（没有之一）不可能这么简单就称为伟大。 下半场卡瓦尼的进球似乎想钉子一样把巴萨钉在了出局名单上，我承认当时我是绝望的。就好比巴黎的4比0捅了巴萨一刀，但是巴萨没死，挣扎着站起来的时候，大巴黎又捅了巴萨一刀。这放在哪个队都是直接放弃比赛，缴枪投降的。但是这是巴萨，苏亚雷斯没有放弃，他一次次冲击禁区，哪怕球出了底线也奋力追；梅西没有放弃，他一次次回撤组织进攻、不停跑位；内马尔也没有放弃，一次次不停突破、传中… 然而奇迹真的出现了，先是内马尔的任意球，划过美丽的弧线直奔死角；然后苏亚雷斯突破造点。此时已经是91分钟了，留给巴萨的时间真的不多了，要么被淘汰、要么再进一个逆转。 还是内马尔，一个轻盈的挑传，罗伯托像鬼魅般冒了出来，出现在正确的时间、正确的地点，用正确的方式把球捅进去。若不是怕影响舍友睡觉，此时我应该已经疯了吧，我狠狠地拍了拍枕头，“真TM牛逼！” 这样的球队你怎么能不爱，大巴黎连捅两刀，巴萨只要没死，就继续战斗，直到打败对手，这种逆转把足球乃至竞技体育的精神体现得淋漓尽致。 就像标题图片中球迷打出的标语：“Yes！We Can！”，是的，我们真的做到了，赛前连欧足联官方给出的比赛预测，巴萨晋级概率都是0，就这样，我萨还是做到了。 感谢巴萨，感谢这场世纪逆转， 让我们领略足球世界中的非凡魅力和无限可能性， 让我们重拾对生活的热爱，与对梦想的渴望追寻。 人生真是充满了阳光啊！ 最后以煤老板的霸气庆祝图结尾，我心红蓝！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之Angular模块]]></title>
      <url>%2F2017%2F03%2F07%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BAngular%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Angular模块化Angular 模块是一个由@NgModule装饰器提供元数据的类，元数据包括： 声明哪些组件、指令、管道属于该模块。 公开某些类，以便其它的组件模板可以使用它们。 导入其它模块，从其它模块中获得本模块所需的组件、指令和管道。 在应用程序级提供服务，以便应用中的任何组件都能使用它。 应用的根模块BrowserModule注册了一些关键的应用服务提供商。 它还包括了一些通用的指令，例如NgIf和NgFor，所以这些指令在该模块的任何组件模板中都是可用的。 @NgModule.bootstrap属性把这个AppComponent标记为引导 (bootstrap) 组件。 当 Angular 引导应用时，它会在 DOM 中渲染AppComponent，并把结果放进index.html的&lt;my-app&gt;元素标记内部。 引导根模块通过即时 (JiT) 编译器动态引导什么是Angular编译器？Angular编译器会把我们所写的应用代码转换成高性能的JavaScript代码。 在编译过程中，@NgModule的元数据扮演了很重要的角色。@NgModule元数据告诉Angular编译器要为当前模块编译哪些组件，以及如何把当前模块和其它模块链接起来。 Angular 编译器在浏览器中编译并引导该应用: 12345678// The browser platform with a compilerimport &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';// The app moduleimport &#123; AppModule &#125; from './app/app.module';// 编译并运行模块platformBrowserDynamic().bootstrapModule(AppModule); 使用预编译器 (AoT) 进行静态引导静态方案可以生成更小、启动更快的应用，建议优先使用它，特别是在移动设备或高延迟网络下。 使用静态选项，Angular 编译器作为构建流程的一部分提前运行，生成一组类工厂。它们的核心就是AppModuleNgFactory。 引导预编译的AppModuleNgFactory的语法和动态引导AppModule类的方式很相似。 12345678// The browser platform without a compilerimport &#123; platformBrowser &#125; from '@angular/platform-browser';// The app module factory produced by the static offline compilerimport &#123; AppModuleNgFactory &#125; from './app/app.module.ngfactory';// Launch with the app module factory.platformBrowser().bootstrapModuleFactory(AppModuleNgFactory); 由于整个应用都是预编译的，所以我们不用把 Angular 编译器一起发到浏览器中，也不用在浏览器中进行编译。 下载到浏览器中的应用代码比动态版本要小得多，并且能立即执行。引导的性能可以得到显著提升。 无论是 JiT 还是 AoT 编译器都会从同一份AppModule源码中生成一个AppModuleNgFactory类。 JiT 编译器动态地在浏览器的内存中创建这个工厂类。 AoT 编译器把工厂输出成一个物理文件，也就是我们在静态版本main.ts中导入的那个。 声明自定义的组件和指令声明在模块的declarations中。 导入BrowserModule导入了CommonModule并且重新导出了它。 最终的效果是：只要导入BrowserModule就自动获得了CommonModule中的指令。 模块可以重新导出其它模块，这会导致重新导出它们导出的所有类。 纯服务类的模块不会导出任何可供其它模块使用的可声明类，例如HttpModule 组件、指令和管道只能属于一个模块。永远不要再次声明属于其它模块的类。 如果有两个同名指令，只要在 import 时使用as关键字来为第二个指令创建个别名就可以了。 123import &#123; HighlightDirective as ContactHighlightDirective&#125; from './contact/highlight.directive'; 特性模块特性模块我们引导根模块来启动应用，但导入特性模块来扩展应用。特性模块可以对其它模块暴露或隐藏自己的实现。 几乎所有要在浏览器中使用的应用的根模块（AppModule）都应该从@angular/platform-browser中导入BrowserModule。 添加 ContactModuleBrowserModule还从@angular/common中重新导出了CommonModule，这意味着AppModule中的组件也同样可以访问那些每个应用都需要的Angular指令，如NgIf和NgFor。 在其它任何模块中都不要导入BrowserModule。 特性模块和惰性加载模块应该改成导入CommonModule。 它们需要通用的指令。它们不需要重新初始化全应用级的提供商。 通过路由器惰性加载模块应用路由惰性加载模块的位置是字符串而不是类型。 在本应用中，该字符串同时标记出了模块文件和模块类，两者用#分隔开。 12&#123; path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' &#125;,&#123; path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' &#125; 路由到特性模块当需要为根模块和特性模块分别提供不同的导入值时，forRoot和forChild是约定俗成的方法名。 共享模块通过让SharedModule重新导出CommonModule和FormsModule模块，可以消除CommonModule和FormsModule模块重复导入。 不要在共享模块中把应用级单例添加到providers中。 否则如果一个惰性加载模块导入了此共享模块，就会导致它自己也生成一份此服务的实例。 核心模块把这些一次性的类收集到CoreModule中，并且隐藏它们的实现细节。 简化之后的根模块AppModule导入CoreModule来获取其能力。 用forRoot配置核心服务模块的静态方法forRoot可以同时提供并配置服务。 它接收一个服务配置对象，并返回一个ModuleWithProviders。这个简单对象具有两个属性： ngModule - CoreModule类 providers - 配置好的服务提供商 根模块AppModule会导入CoreModule类并把它的providers添加到AppModule的服务提供商中。 一个可选的、被注入的UserServiceConfig服务扩展核心的UserService服务。 如果有UserServiceConfig，UserService就会据此设置用户名。 12345src/app/core/user.service.ts (constructor)constructor(@Optional() config: UserServiceConfig) &#123; if (config) &#123; this._userName = config.userName; &#125;&#125; CoreModule.forRoot接收UserServiceConfig对象： 12345678910src/app/core/core.module.ts (forRoot)static forRoot(config: UserServiceConfig): ModuleWithProviders &#123; return &#123; ngModule: CoreModule, providers: [ &#123;provide: UserServiceConfig, useValue: config &#125; ] &#125;;&#125; 在AppModule的imports列表中调用它: 123456imports: [ BrowserModule, ContactModule, CoreModule.forRoot(&#123;userName: 'Miss Marple'&#125;), AppRoutingModule], 只在应用的根模块AppModule中调用forRoot。 如果在其它模块（特别是惰性加载模块）中调用它则违反了设计意图，并会导致运行时错误。别忘了导入其返回结果，而且不要把它添加到@NgModule的其它任何列表中。 禁止重复导入CoreModule只有根模块AppModule才能导入CoreModule。 如果惰性加载模块导入了它，就会出问题。 如果我们错误的把CoreModule导入了一个惰性加载模块， @SkipSelf让 Angular 在其父注入器中查找CoreModule，这次，它的父注入器却是根注入器了。 当然，这次它找到了由根模块AppModule导入的实例。 该构造函数检测到存在parentModule，于是抛出一个错误。 123456constructor (@Optional() @SkipSelf() parentModule: CoreModule) &#123; if (parentModule) &#123; throw new Error( 'CoreModule is already loaded. Import it in the AppModule only'); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之CLI快速起步]]></title>
      <url>%2F2017%2F03%2F06%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BCLI%E5%BF%AB%E9%80%9F%E8%B5%B7%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[Angular-CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布。 设置开发环境node版本4.X.X以上，npm版本3.X.X以上。 全局安装Angular-CLI： 1npm install -g @angular/cli 创建新项目及应用骨架运行下面命名生成一个新项目以及应用的骨架代码： 1ng new my-app 启动开发服务器进入项目目录，并启动服务器。 12cd my-appng serve ng serve命令会启动开发服务器，监听文件变化，并在修改这些文件时重新构建此应用。 在浏览器中打开http://localhost:4200/，可以显示应用信息。 项目文件概览src文件夹你的应用代码位于src文件夹中。 所有的Angular组件、模板、样式、图片以及你的应用所需的任何东西都在那里。 这个文件夹之外的文件都是为构建应用提供支持用的。 12345678910111213141516171819src|--app| |-app.component.css| |-app.component.html| |-app.component.spec.ts| |-app.component.ts| |-app.module.ts|--assets| |-.gitkeep|--environments| |-environment.prod.ts| |-environment.ts|--favicon.ico|--index.html|--main.ts|--polyfills.ts|--styles.css|--test.ts|--tsconfig.json assets/*文件夹下放图片等任何东西，在构建应用时，它们全都会拷贝到发布包中。 environments/*文件夹中包括为各个目标环境准备的文件，它们导出了一些应用中要用到的配置变量。 这些文件会在构建应用时被替换。 比如你可能在产品环境中使用不同的API端点地址，或使用不同的统计Token参数。 甚至使用一些模拟服务。 index.html大多数情况下你都不用编辑它。 在构建应用时，CLI会自动把所有js和css文件添加进去，所以你不必在这里手动添加任何 或 标签。 polyfills.ts能帮我们把不同的浏览器对Web标准的支持程度进行标准化。 根目录src/文件夹是项目的根文件夹之一。 其它文件是用来帮助你构建、测试、维护、文档化和发布应用的。它们放在根目录下，和src/平级。 123456789101112131415my-app|--e2e| |-app.e2e-spec.ts| |-app.po.ts| |-tsconfig.json|--node_modules/...|--src/...|--.editorconfig|--.gitignore|--angular-cli.json|--karma.conf.js|--package.json|--protractor.conf.js|--README.md|--tslint.json protractor.conf.js给Protractor使用的端到端测试配置文件，当运行ng e2e的时候会用到它。 tslint.json给TSLint和Codelyzer用的配置信息，当运行ng lint时会用到。 Lint功能可以帮你保持代码风格的统一。 生成组件、指令、管道和服务12345678910ng generate component my-new-componentng g component my-new-component # 简写# 组件支持关联路径生成# 如果在src/app/feature/目录中，可以运行：ng g component new-cmp# 在src/app/feature/new-cmp中生成组件# 但是如果这样运行：ng g component ../newer-cmp# 组件将会在src/app/newer-cmp中生成 用下面的命令可以生成各种模板： 模板 用法 Directive ng g directive my-directive Component ng g component my-component Pipe ng g pipe my-pipe Service ng g service my-service Class ng g class my-class Interface ng g interface my-interface Enum ng g enum my-enum Module ng g module my-module]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现（三）]]></title>
      <url>%2F2017%2F03%2F03%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[之前在AngularJS2中一种button切换效果的实现和AngularJS2中一种button切换效果的实现（二）中实现了按钮的切换效果，但是方法比较low，这次我们使用Angular2的指令来实现。 指令实现hover效果123456789101112131415161718192021import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('mouseenter') onMouseEnter() &#123; this.highlight('red'); &#125; @HostListener('mouseleave') onMouseLeave() &#123; this.highlight(null); &#125; private highlight(color: string) &#123; this.el.nativeElement.style.backgroundColor = color; &#125;&#125; 123&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt; 123456789.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125; hover的效果直接参考Angular官网的代码。 指令实现click效果12345678910111213141516171819202122232425import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('click') onMouseClick() &#123; this.clickhighlight("black"); &#125; private clickhighlight(color: string) &#123; let obj = this.el.nativeElement; let btns = obj.parentNode.children; //背景色全部重置 for(let i=0; i&lt;btns.length; i++)&#123; btns[i].style.backgroundColor = "#3399ff"; &#125; //设置当前点击对象的背景色 obj.style.backgroundColor = color; &#125;&#125; 12345&lt;div&gt;&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 123456789.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125; click效果仍然用@HostListener装饰器引用属性型指令的宿主元素，首先把所有button的背景颜色重置，然后再设置当前点击对象的背景颜色，这样就达到了点击后背景颜色变化的效果。 指令实现click加hover效果12345678910111213141516171819202122232425import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('click') onMouseClick() &#123; this.clickhighlight("black"); &#125; private clickhighlight(color: string) &#123; let obj = this.el.nativeElement; let btns = obj.parentNode.children; //背景色全部重置 for(let i=0; i&lt;btns.length; i++)&#123; btns[i].style.backgroundColor = "#3399ff"; &#125; //设置当前点击对象的背景色 obj.style.backgroundColor = color; &#125;&#125; 12345&lt;div&gt;&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 12345678910111213.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125;.btn:hover&#123; background: black !important;&#125; 配合上文click效果，只要加上一行css代码就可以实现click和hover的组合效果，此处务必使用hover伪类，并用!important来提升样式的优先级，如果用@HostListener装饰器，mouseenter、mouseleave、click三者会打架：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript DOM编程艺术》学习笔记]]></title>
      <url>%2F2017%2F02%2F25%2F%E3%80%8AJavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[本书大部分demo参见DOM Scripting Demo，本人手敲，如有错误欢迎提交pr JavaScript语法准备工作12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="example.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 把&lt;script&gt;标签放在HTML文档最后，&lt;/body&gt;标签之前，这样即使加载脚本时，Windows对象的load事件依然可以执行对文档进行的各种操作。 因为位于&lt;head&gt;中的脚本会导致浏览器不能并行加载其他文件。一般来说，根据HTTP规范，浏览器每次从同一个域名中最多只能同时下载两个文件。 操作算术操作符字符串和数值拼接在一起结果是更长的字符串。 1alert("10"+20)； //输出1020 比较操作符JavaScript中，==并不表示严格相等，例如： 12345var a = false;var b = "";if (a == b)&#123; //true alert("a = b");&#125; 这个语句求值结果是ture，因为==认为空字符串与false的含义相同。要进行严格比较，就要使用另一种等号：===。这个全等操作符会执行严格的比较，不仅比较值，而且会比较变量的类型： 12345var a = false;var b = "";if (a === b)&#123; //flase alert("a = b");&#125; 函数如果在某个函数中使用var，那个变量就被看做局部变量，它只存在这个函数上下文中；如果没有使用var，这个变量就被看做是全局变量，如果脚本里面出现一个与之同名的全局变量，这个函数就会改变这个全局变量的值。 1234567891011121314151617function square(num)&#123; total = num * num; return total&#125;var total = 50;var number = square(20);alert(total); //输出400-------------我是分割线-------------function square(num)&#123; var total = num * num; return total&#125;var total = 50;var number = square(20);alert(total); //输出50 对象假设有个Person的对象，为了使用Person来描述人，需要创建一个Person对象的实例。实例是对象的具体个体。例如，你和我都是人，都可以用person对象来描述；但你和我是两个不同的个体，和可能有着不同的属性。因此对应着不同的Person对象–虽然都是Person对象，但是它们是两个不同的实例。 new关键字为对象创建一个新的实例： 1var tangcheng = new Person; 内建对象Array对象、Math对象、Date对象都是内建对象。 宿主对象有些已经预定义的对象是由运行环境提供，具体到web就是浏览器提供的，这些对象被称为宿主对象。不仅包括Form、Image、Element等，还包括document对象。 DOMwindow对象对应浏览器窗口本身，这个对象的属性和方法通常称为BOM（浏览器对象模型）。 DOM的节点树和家谱类似。 节点节点分为元素节点、文本节点、属性节点。 获取元素getElementByIdgetElementById返回的是一个对象。 getElementsByTagNamegetElementsByTagName返回的是一个对象数组，即使整个文档只有一个元素，getElementsByTagName返回的也是数组，数组长度为1。 getElementsByTagName允许把一个通配符作为参数，返回文档中所有元素，*必须放在引号中（为了与乘法操作符区别）。 1document.getElementsByTagName("*"); getElementsByTagName可以和getElementById结合起来使用： 123var shopping = document.getElementById("purchase");var items = shopping.getElementsByTagName("*");//返回shopping下面所有的标签 getElementsByClassNamegetElementsByClassName返回的是一个具有同类名元素的数组。 可以指定多个类名，只要在字符串参数中用空格分隔类名，匹配时类名顺序不重要，就算类名还带有其他类名也可以匹配： 1document.getElementsByClassName("tc zj"); getElementsByClassName兼容性可以使用下面的脚本实现： 123456789101112131415function getElementsByClassName(node, classname)&#123; if (node.getElementsByClassName)&#123; //使用现有方法 return node.getElementsByClassName(classname); &#125;else&#123; var results = new Array(); var elems = node.getElementsByTagName("*"); for (var i = 0; i&lt;elems.length; i++)&#123; if (elems[i].className.indexOf(classname)!=-1)&#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 获取和设置属性getAttributegetAttribute方法不属于document对象，只能通过元素节点对象调用。属性不存在时返回null。 如果something是null，if (something)和if (something != null)等价。 setAttributesetAttribute方法也只能通过元素节点对象调用。 1object.setAttribute(attribute,value); 通过setAttribute对文档做出的修改后，再通过浏览器的view source（查看源码）选项去查看文档的源码时看到的仍将是改变前的值，也就是说setAttribute做出的修改不会反映在文档本身的源码中。这是因为： DOM的工作模式是：先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力：对页面进行刷新不需要再浏览器里刷新页面。（tc：也是前端框架路由实现的基础） 案例研究：JavaScript图片库JavaScriptDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把从本书学到的DOM技巧运用在web浏览器以外的应用环境里，严格遵守”第1级DOM“能够让你避免与兼容性有关的任何问题。 应用这个JavaScript函数事件处理函数事件处理函数的工作机制：在给某个元素添加事件处理函数后，一旦事件发生，相应的JavaScript代码就会得到执行。被调用的JavaScript代码可以返回一个值，这个值将被传递给那个事件处理函数。 例如：给某个链接添加一个onclick事件处理函数，onclick事件处理函数所触发的JavaScript代码会返回false或者true。当这个链接被点击时，如果那段JavaScript代码返回的是true，onclick事件处理函数就认为”这个链接被点击了“；反之，如果返回值是false,onclick事件处理函数就认为”这个链接没有被点击“。 12&lt;!--当点击时，返回的是false，链接的默认行为没有被触发--&gt;&lt;a href="http://tc9011.com" onclick="return false"&gt;&lt;/a&gt; 对这个函数进行扩展childNodes属性在一颗节点树上，childNodes属性可以获取任何一个元素的所有子元素，它是一个包含这个元素全部子元素的数组。 nodeType属性每个节点都有nodeType属性，nodeType的值是一个数字： 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 nodeValue属性nodeValue属性用来获取或者设置一个节点的值。 &lt;p&gt;元素里的文本是另一种节点，&lt;p&gt;元素本身的nodeValue是一个空值： 1&lt;p id="description"&gt;Choose an image&lt;/p&gt; 1234var description = document.getElementById("description");alert(description.nodeValue);//输出nullalert(description.childNodes[0].nodeValue);//输出"Choose an image"alert(description.firstChild.nodeValue);//输出"Choose an image" 最佳实践平稳退化JavaScript使用window对象的open()方法来创建新的浏览器窗口。这个方法有三个参数： 1window.open(url,name,feature) 这三个参数都是可选的： 第一个参数是想在新窗口打开的URL地址。省略则弹出空白窗口。 第二个参数是新窗口的名字。可以在代码中通过这个名字与新窗口进行通信。 第三个参数是一个以逗号分隔的字符串，其内容是新窗口的各种属性。 ”javascript:“伪协议”javascript:“伪协议让我们通过一个链接来调用JavaScript函数。 1&lt;a href="javascript:popUp("http://tc9011.com");"&gt;tc9011.com&lt;/a&gt; 在HTML文档中通过”javascript:“伪协议调用JavaScript代码的做法非常不好。 分离JavaScript1&lt;a href="http://tc9011.com" onclick="popUp(this.href);return false"&gt;&lt;/a&gt; JavaScript语言不要求事件必须在HTML文档里处理（如上面的onclick事件可以分离到外部JavaScript文件中。），可以在外部的JavaScript文件里面把一个事件添加到HTML文档中某个元素上。 1getElementById(id).event = active 如果涉及多个元素，可以用getElementsByTagName和getAttribute把事件添加到有着特定属性的一组元素上： 123456789var links = document.getElementsByTagName("a");for (var i=0; i&lt;links.length; i++)&#123; if (links[i].getAttribute("class") == "popup")&#123; links[i].onclick = function()&#123; popUp(this.getAttribute("href")); return false; &#125; &#125;&#125; 以上代码把click操作从HTML文档中分离出来。 当HTML文档全部加载完毕将触发window.onload事件，这个事件触发时document对象已经存在，这样可以避免HTML没有加载完全时，JavaScript代码获取不到相应的id或者class。 性能考虑尽量减少访问DOM和尽量减少标记访问DOM对脚本性能会产生非常大的影响。多次访问相同的DOM，可以先把第一次搜索的结果保存在一个变量中。 12345678910111213if (document.getElementsByTagName("a").length &gt; 0)&#123; var links = document.getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++)&#123; //对每个链接节点做处理 &#125;&#125;------------优化后------------var links = document.getElementsByTagName("a");if (links.length &gt; 0)&#123; for (var i=0; i&lt;links.length; i++)&#123; //对每个链接节点做处理 &#125;&#125; 案例研究：图片库改进版它支持平稳退化吗href设置为真实值，在JavaScript被禁用的情况下，链接也能跳转。 1&lt;a href="images/1.jpg" title="A" onclick="showPic(this);return false"&gt;&lt;/a&gt; 它的JavaScript与HTML标记是分离的吗出现多个window.onload时，只会执行最后一个。可以使用自定义的addLoadEvent函数完成多个函数绑定到window.onload。 1234567891011121314function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != "function")&#123; window.onload = func; &#125;else &#123; window.onload = function () &#123; oldonload(); func(); &#125; &#125;&#125;------------使用------------addLoadEvent(firstFunction);addLoadEvent(secondFunction); 优化nodeName属性总是返回一个大写字母的值，即使元素在HTML文档里面是小写字母。 键盘访问用Tab键移动到某个链接然后按下回车键的动作也会出发onclick事件。 DOM Core和HTML-DOM getElementById getElementsByTagName getAttribute setAttribute 这些方法都是DOM Core的组成部分。它们并不专属于JavaScript，支持DOM和任何一种程序设计语言都可以使用它们。 onclick属性属于HTML-DOM，HTML-DOM只能用来处理web文档。HTML-DOM书写更简短： 1234567891011document.getElementsByTagName("form") --&gt;document.forms--------分割线--------element.getAttribute("src") --&gt;element.src--------分割线--------var source = whichpic.getAttribute("href") --&gt;var source = whichpic.href--------分割线--------placeholder.setAttribute("src",source) --&gt;placeholder.src = source 动态创建标记一些传统的方法document.writedocument.write最大的缺点是违背了“行为应该和表现分离”的原则，应该避免使用。 innerHTML属性innerHTML无法区分“插入一段HTML内容”和“替换一段HTML内容”，一旦使用这个属性，里面全部内容都将被替换。 DOM方法浏览器实际显示的是DOM节点树，不是物理文档的内容。 createElement方法createElement方法只能创建元素节点。 1document.createElement(nodeName); appendChild方法1parent.appendChild(child); createTextNode方法createTextNode方法用来创建文本节点。 重返图片库 如果元素存在只是为让DOM方法处理，用DOM方法来创建它们才是最合适的。 这样是不是太极端了，增加了对DOM的操作，会不会影响性能？ 在已有元素前插入一个新元素insertBefore()方法把一个新元素插入到现有元素的前面。 12parentElement.insertBefore(newElement,targetElement);parentElement 等于 targetElement.parentNode 在现有元素后插入一个新元素编写insertAfter函数DOM本身没有提供insertAfter函数，可以利用已有DOM方法和属性编写一个： 12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; AjaxXMLHttpRequest对象XMLHttpRequest对象充当浏览器中的脚本（客户端）与服务器之间的中间人的角色。 onreadystatechange是一个事件处理函数，它会在服务器给XMLHttpRequest对象送回响应的时候被触发执行。在这个处理函数中，可以根据服务器的具体响应做相应的处理。 服务器在向XMLHttpRequest对象发回响应时，浏览器会在不同阶段更新readyState属性的值： 0表示未初始化 1表示正在加载 2表示加载完毕 3表示正在交互 4表示完成 访问服务器发送回来的数据要通过两个属性完成。一个是responseText属性，这个属性用于保存文本字符串形式的数据。另一个属性是responseXML属性，用于保存content-Type头部中指定为text/xml的数据，其实是一个DocumentFragment对象。 充实文档的内容不应该做什么遵循下面两个原则：1、渐进增强。应该在最开始根据内容使用标记实现良好的结构，然后再逐步加强这些内容。这些增强工作可以是通过css改进呈现效果，也可以通过DOM添加各种行为。2、平稳退化。渐进增强的实现必然支持平稳退化。缺乏必要css和DOM支持的访问者仍然可以访问到核心内容。 CSS-DOM三位一体的网页结构层结构层由HTML或XHTML之类的标记语言负责创建。 表示层表示层由css负责完成。css描述页面内容应该如何呈现。 行为层行为层负责内容应该如何响应事件这一问题。这是JavaScript和DOM主宰的领域。 style属性每个元素的style属性是都是一个对象。 引用中间带减号的css属性时，DOM要求用驼峰命名法。例如：font-family变成element.style.fontFamily。 何时该用DOM脚本设置样式为有类似属性的多个元素声明样式： 123input[type*="text"] &#123; font-size: 1em;&#125; 根据元素位置声明样式： 123p:first-of-type &#123; font-of-size: 1em;&#125; 需要决定是采用纯粹的CSS来解决，还是利用DOM来设置样式，需要考虑以下因素： 这个问题最简单的解决方案是什么； 哪种解决方案会得到更多浏览器的支持。 className属性通过className属性直接赋值来设置某个元素的class属性将替换该元素的原有class属性。如要追加class属性，可以这样写： 1elem.className += " intro"; 用JavaScript实现动画效果动画基础知识位置position属性的合法值有static、fixed、relative和absolute四种。static是position属性的默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。relative含义和static相似，区别在于position属性等于relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 如果把某个元素的position属性设置为absolute，我们就可以把它摆放到容纳它的”容器“的任何位置。这个容器要么是文档本身，要么是一个有着fixed或者absolute属性的父元素。这个元素原始标记里出现的位置与它的显示位置无关，因为它的显示位置由top、left、right和bottom等属性决定。 时间递增量JavaScript函数parseInt可以把字符串里的数值信息提取出来。例如： 1parseInt("18 forbidden");//返回数值18 实用的动画W3C在web内容可访问性指南（Web Content Accessibility Guidelines）7.2节里给出这样的建议： 除非浏览器允许用户”冻结“移动着的内容，否则就应该避免让内容在页面中移动。（优先级2）。如果页面上有移动着的内容，就应该用脚本或插件的机制允许用户”冻结“这种移动或动态更新行为。 CSSCSS的overflow属性用来处理一个元素的尺寸超出其容器尺寸的情况。overflow属性有四个可取值： visible：不剪裁溢出的内容。浏览器将把溢出的内容呈现在其容器元素的显示区域以外，全部内容都可见。 hidden：隐藏溢出的内容。内容只显示在其容器元素的显示区域里，这意味着只有一部分内容可见。 scroll：类似于hidden，浏览器将对溢出的内容进行隐藏，但是显示一个滚动条以便让用户能够滚动看到内容的其他的地方。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条。如果内容没有溢出，就不显示滚动条。 父元素的position设置为relative，子元素的（0，0）坐标将固定在父元素的左上角。 变量作用域问题属性是只与某个特定元素有关的变量。JavaScript允许我们为元素创建属性： 1element.property = value; 这和创建变量很像，但是区别在于这是属于某个特定元素的变量。 下面是我自己改写的时候碰到的for循环中的闭包问题，按照错误的改写，由于闭包的存在，for循环中i的值始终为2，要使得for循环每次正常输出，需要先把i的值赋给每个links的i属性，调用时候用this表示当前links来调用i属性。参考资料浅谈JavaScript for循环 闭包 12345678910111213141516171819202122232425 //把下面改写成for循环。 links[0].onmousemove = function () &#123; moveElement("preview",-110,0,10); &#125;; links[1].onmousemove = function () &#123; moveElement("preview",-220,0,10); &#125;; links[2].onmousemove = function () &#123; moveElement("preview",-330,0,10); &#125;;--------------错误改写-------------- for (var i=0; i&lt;links.length; i++)&#123; links[i].onmousemove = function () &#123; var x = (i+1)*-110; moveElement("preview",x,0,10); &#125;; &#125;--------------正确改写-------------- for (var i=0; i&lt;links.length; i++)&#123; links[i].i = i; links[i].onmousemove = function () &#123; var x = (this.i+1)*-110; moveElement("preview",x,0,10); &#125;; &#125; HTML5XHTML语法比HTML严格，如：标签一定要闭合、标签一定要是小写、所有属性都要赋值等。 几个示例音频和视频为了保证HTML5的最大兼容性，至少要包含下列三个版本： 基于H.264和AAC的MP4 WebM（VP8+Vorbis） 基于Theora视频和Vorbis音频的Ogg文件 为了最大程度兼容不支持HTML5的浏览器，一般还要准备一个flash或者QuickTime插件版的视频。 不同视频格式排序的时候应该把MP4放在第一位，因为IOS4之前版本中的Mobile Safari只能解析一个&lt;video&gt;元素，故把针对IOS格式的放在最前面 自定义控件&lt;video&gt;元素自定义控件可以通过一些DOM属性来实现，主要包括： currentTime，返回当前播放的位置，以秒表示； duration，返回媒体的总时长，以秒表示，对流媒体返回无穷大； pause，表示媒体是否处于暂停状态； 此外，还有一些与特定媒体相关的事件，可以用来触发你的脚本。主要事件有： play，在媒体播放开始时发生； pause，在媒体暂停时发生； loadeddata，在媒体可以从当前播放位置开始播放时发生； ended，在媒体已播放完成而停止时发生。 不管创建什么控件，都不要忘了在&lt;video&gt;元素中添加control属性： 1&lt;video src="movie.ogv" controls&gt;&lt;/video&gt; 表单新的输入控件类型包括： email url date number range，用于生成滑动条 search tel color，用于选择颜色 新的属性： autocomplete，用于文本输入框添加一组建议的输入项； autofocus，用于让表单元素自动获得焦点； form，用于对&lt;form&gt;标签外部的表单元素分组； min、max和step，用在范围（range）和数值（number）输入框中； pattern，用于定义一个正则表达式，以便验证输入的值； placeholder required，表示必填 综合示例css把css可以拆成几个模块，然后用@import导入到一个基本的样式表basic.css中，如果要添加或者删除一个样式，只要编辑basic.css就可以。在html中也只要引入basic.css就行。 颜色不管哪个元素应用什么颜色，都要同时给它一个背景颜色。 JavaScript取到当前页面的URL可以使用window.location.href。 表单每一个form对象都有一个elements.length属性，这个属性返回表单中包含的表单元素的个数： 1form.elements.length 这个返回值与childNodes.length不一样，后者返回的是元素中包含的所有节点的个数。而form对象的elements.length属性只关注那些属于表单元素的元素，如：input、textarea等。 form.elements是包含了所有表单元素的数组。 elements数组中的每个表单元素都有自己的一组属性。 elements.value保存了表单元素的当前值。 onfocus事件会在用户通过按Tab键或者单击表单字段时被触发。 onblur事件会在用户把焦点移除表单字段时触发。 encodeURIComponent函数把有歧义的字符串转换成对应的ASCⅡ编码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[听说你的placeholder想换行？]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%90%AC%E8%AF%B4%E4%BD%A0%E7%9A%84placeholder%E6%83%B3%E6%8D%A2%E8%A1%8C%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[这是同事遇到的一个问题，在&lt;textarea&gt;标签里面不仅要加上placeholder属性，还要换行。在stackoverflow上有相关的讨论，主要有下面几种做法： 官方说明官方说明： The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format. The attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters. The placeholder attribute should not be used as a replacement for a label. For a longer hint or other advisory text, place the text next to the control. 翻译过来就是： placeholder属性是用来帮助用户输入的简短提示（一个字或者一个短语），这个提示应该是简单的数值或者简短的描述。placeholder属性不应该作为label的替代者。对于较长或者复杂的提示，将文本置于控件旁边。 解决办法使用&amp;#10;1&lt;textarea name="foo" placeholder"hello you&amp;#10;Second line&amp;#10;Third line"&gt;&lt;/textarea&gt; 这个不能跨浏览器，在ie、chrome下是可以的，但是在firefox和safari中不行。 css解决办法1234567891011::-webkit-input-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125;::-moz-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125;:-ms-input-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125; 只适用于webkit内核的浏览器（chrome、safari），对firefox和ie没有效果。 使用jQuery的watermark控件通过watermark可以全平台兼容。下载控件后，引入到项目，然后在&lt;textarea&gt;中定义jq_watermark的class。 1234&lt;script type="text/javascript" src="jquery.watermark.js"&gt;&lt;/script&gt;&lt;label for="comments"&gt;Comments:&lt;/label&gt;&lt;br /&gt;&lt;textarea id="comments" placeholder="Tell Us&lt;br/&gt;What do you think...&lt;br/&gt;We are here" class="jq_watermark" rows="3" cols="80"&gt;&lt;/textarea&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[翻译]angular2-webpack-starter]]></title>
      <url>%2F2017%2F02%2F16%2F%5B%E7%BF%BB%E8%AF%91%5D-angular2-webpack-starter%2F</url>
      <content type="text"><![CDATA[在github上看到了这个项目，感觉挺好的，就拿过来翻译一下，顺便提高一下看英文文档的水平 Angular2 Webpack Starter本仓库作为Angular2初始化工具为所有寻找更快启动和运行Angular2和TypeScript的人提供帮助。这个项目使用webpack2来构建我们的文件和协助模块化。同时使用Protractor进行e2e测试、Karma进行单元测试。 这是Angular2在文件和应用架构方面最好的练习； 准备用webpack构建基于TypeScript的应用； 当尝试使用Angular2时，Angular2的案例已经准备好了； 对于想启动自己项目的人来说，这是一个极好的Angular2种子库； 为你产品构建的页面快速加载提供AoT编译； Tree shaking会自动删除包中没有用的代码； Webpack DLLs可以大大加快开发构建； 用Jasmine和Karma来测试Angular2的代码； 用Istanbul和Karma来进行测试覆盖； 用Protractor来进行Angular2代码的e2e测试； 用@type进行类型管理； 用webpack、@angularclass/hmr和@angularclass/hmr-loader来做模块热替换(HMR)； 用angular/material2来做Material Design； 通过修改package.json实现对Angular4以及未来Angular任何版本的支持。 Quick start确保你的node版本大于5.0，npm版本大于3.0。 克隆或者下载这个仓库后，编辑在/src/app/app.component.ts里的app.component.ts。 123456789101112131415161718# 克隆仓库# --depth 1 表示克隆最近一次commit.git clone --depth 1 https://github.com/angularclass/angular2-webpack-starter.git# 切换目录cd angular2-webpack-starter# 用npm安装库npm install# 起一个服务npm start# 使用模块热替换npm run server:dev:hmr# 如果在中国，请使用cnpm# https://github.com/cnpm/cnpm 在浏览器中打开 http://0.0.0.0:3000 或者 http://localhost:3000 。 Table of Contents文件结构我们在项目中使用组件化的方法，这是开发Angular app的新标准，是一种通过封装行为逻辑来确保代码可维护性的极好的方法。一个组件基本上是一个完整的app，它通常在一个文件或者文件夹里面包含style, template, specs, e2e, and component class。下面是文件结构的样子： 1234567891011121314151617181920212223242526272829303132333435angular2-webpack-starter/ ├──config/ * 配置 | ├──helpers.js * 配置文件的helper functions | ├──spec-bundle.js * 忽略这个设置Angular2测试环境的魔法 | ├──karma.conf.js * 单元测试的karma配置 | ├──protractor.conf.js * e2e测试的protractor配置 │ ├──webpack.dev.js * webpack开发环境配置 │ ├──webpack.prod.js * webpack产品环境配置 │ └──webpack.test.js * webpack测试环境配置 │ ├──src/ * 将被编译成js的源代码 | ├──main.browser.ts * 浏览器的入口文件 │ │ | ├──index.html * Index.html: 用来生成index页面 │ │ | ├──polyfills.ts * polyfills文件 │ │ │ ├──app/ * WebApp: 文件夹 │ │ ├──app.component.spec.ts * 在app.component.ts中的一个简单测试 │ │ ├──app.e2e.ts * 一个简单e2e测试 │ │ └──app.component.ts * 一个简单的App component │ │ │ └──assets/ * 静态资源存放在这边 │ ├──icon/ * www.favicon-generator.org图标列表 │ ├──service-worker.js * 忽略这个.service worker还没完成 │ ├──robots.txt * 让搜索引擎爬取你的网站 │ └──humans.txt * 让别人知道谁是开发者 │ │ ├──tslint.json * typescript lint配置 ├──typedoc.json * typescript文件生成 ├──tsconfig.json * typescript使用外部webpack的配置 ├──tsconfig.webpack.json * webpack对typescript使用的配置 ├──package.json * npm管理的项目依赖 └──webpack.config.js * webpack主要的配置文件 开始依赖运行这个app你需要： node和npm（通过brew安装node） 确保你运行最新版本的Nodev4.X.X(或者v5.X.X)和NPM3.X.X+ 如果你已经安装nvm—特别推荐（可以通过brew安装nvm）—你可以通过nvm install --lts &amp;&amp; nvm use来运行最新版本的Node。你也可以用zsh来帮你自动完成。 一旦你完成这些，你应该用npm insatll --global安装这些全局包。 webpack (npm install --global webpack) webpack-dev-server (npm install --global webpack-dev-server) karma (npm install --global karma-cli) protractor (npm install --global protractor) typescript (npm install --global typescript) 安装 fork 这个仓库 clone 你fork的仓库 npm install webpack-dev-server rimraf webpack -g 安装需要的全局依赖 npm install 安装所有的依赖或者yarn npm run server 在另一个标签启动一个服务 运行app安装完所有的依赖以后，现在可以运行这个app。运行npm run server来启动一个本地服务，这个服务利用webpack-dev-server 来监听、构件（在内存中）和重新加载。通过这个端口http://0.0.0.0:3000可以访问页面（如果你是IPv6或者使用express服务，通过http://[::1]:3000/访问）。 服务12345# developmentnpm run server# productionnpm run build:prodnpm run server:prod 其他命令构件文件123456# developmentnpm run build:dev# production (jit)npm run build:prod# AoTnpm run build:aot 模块热替换1npm run server:dev:hmr 监听和构件文件1npm run watch 运行单元测试1npm run test 监听和运行测试1npm run watch:test 运行e2e测试1234# 升级Webdriver (可选, 通过postinstall script自动完成)npm run webdriver:update# 启动服务并且启用Protractornpm run e2e 集成测试（一起运行单元测试和e2e测试）12# 测试JIT和AoT buildsnpm run ci 运行Protractor的elementExplorer (为e2e测试)1npm run e2e:live 构件Docker1npm run build:docker 配置 配置文件在config/目录下，一般用 webpack, karma, and protractor 作为项目的脚手架。 AoT禁忌下面是一些会使AoT编译失败的做法： 不需要为模板和样式声明，使用styleUrls and templateUrls，angular2-template-loader插件会在构建时声明； 不要使用默认的exports； 不要用 form.controls.controlName, 使用 form.get(‘controlName’)； 不要用 control.errors?.someError, 使用 control.hasError(‘someError’)； 不要在providers, routes 或者declarations中使用函数, 应该暴露一个函数，然后引用这个函数的名字； @Inputs, @Outputs, View , Content Child(ren), Hostbindings或者任何从模板、注释中使用的字段对Angular都应该是public。 外部样式任何导入到项目中的样式或者在src/styles文件夹下的样式 (Sass 或者 CSS) 都将被编译成外部的 .css 并嵌入你的产品构建。 例如用Bootstrap作为外部样式: 1) 在src/styles文件夹下创建一个 styles.scss 文件 (名字不重要) ； 2) 用 npm install 安装你想要的Boostrap版本； 3) 在 styles.scss 加上 @import &#39;bootstrap/scss/bootstrap.scss&#39;; 4) 在 src/app/app.module.ts 其他声明下面加上: import &#39;../styles/styles.scss&#39;; 贡献你可以用组件的形式引进更多的案例，但是它们必须引入一些新的概念，比如 Home component (独立文件夹)和Todo (服务)。我将会很乐意接受，所以尽情Pull-Request。 TypeScript 全局安装TypeScript，并使用带有TypeScript插件的编辑器，利用自动补全来充分使用TypeScript。 使用最新的TypeScriptTypeScript 2.1.x 包含所有你需要的东西。 请确保升级到这个版本，即使你之前已经安装了TypeScript。 1npm install --global typescript 使用支持TypeScript的编辑器推荐使用下面的编辑器: Visual Studio Code Webstorm 10 带 TypeScript plugin的Atom 带 Typescript-Sublime-Plugin的Sublime Text Visual Studio Code + Debugger for Chrome 安装 Debugger for Chrome ，然后去看操作指南 项目中的 .vscode 会自动连接到webpack development server 的 3000端口。 Types 当你引入一个没有定义类型的模块，你可以用@types引入外部类型定义。 比如，为了让YouTube api运行，在终端中输入下面的命令： 1npm i @types/youtube @types/gapi @types/gapi.youtube 在一些案例中，你的代码编辑器不支持Typescript 2或者这些类型不在tsconfig.json列表内，这时候把这些类型增加到“src/custom-typings.d.ts” 中来帮助编译时检查： 123import '@types/gapi.youtube';import '@types/gapi';import '@types/youtube'; 类型定义习惯如果需要用到第三方模块，当它没有提供类型定义时，同样需要为模块引入类型定义。你可以试着用@types来完成： 12npm install @types/nodenpm install @types/lodash 如果你不能在库中找到对应的类型定义，可以暂时在文件中使用ambient definition ： 123declare module "my-module" &#123; export function doesSomething(value: string): string;&#125; 如果导入的模块是使用Node.js，你需要这样引入： 1import * as _ from 'lodash'; 常见问题 如何知道当前浏览器时候支持Angular2？ 答：请查看这个更新列表：browser support for Angular 2。 为什么服务没有正确注入参数？ 答：请使用 @Injectable() ，以便让TypeScript的服务正确的依附上元数据（这是TypeScript的问题）。 怎么才能用node 0.12.X运行protractor？ 答：请切换到这个仓库以便使用老版本的protractor，参见 #146 在哪里写测试？ 答：可以在组件文件下写你的测试。 例如 /src/app/home/home.component.spec.ts 当报 EACCES 和 EADDRINUSE 错误时，如何启动app？ 答： EADDRINUSE 错误是 3000 端口已经被使用了， EACCES 错误是webpack在./dist/目录下没有权限来构建文件。 如何在css中使用 sass ？ 答：使用loaders: [&#39;raw-loader&#39;,&#39;sass-loader&#39;] 和 @Component({ styleUrls: [&#39;./filename.scss&#39;] }) ，参见 Wiki How to include SCSS in components, 或者 #136 问题。 如何测试服务？ 答：参见 #130 如何增加 vscode-chrome-debug 支持？ 答：VS Code chrome debug 插件的支持可以通过 launch.json 来实现，参见 #144。 如何让这个仓库在虚拟机上运行？ 答：host使用 0.0.0.0 ，参见 #205。 Angular 2的命名约定是什么？ 答：参见 #185 和 196。 如何引入bootstrap或者jQuery？ 答：参见 #215 和#214。 组件如何异步加载？ 答：参见 How-do-I-async-load-a-component-with-AsyncRoute。 Error: Cannot find module ‘tapable’ 答：移除 node_modules/ ，然后运行 npm cache clean ，最后 npm install。 如何开启模块热替换？ 答：运行 npm run server:dev:hmr。 RangeError: Maximum call stack size exceeded 答：这是压缩Angular2和JIT模板时的错误，可以把mangle 设置为false。 为什么app比development大？ 答：因为使用了inline source-maps和模块热替换，这回导致包的大小增加。 如果你在中国，请使用https://github.com/cnpm/cnpm。 如果希望增加Angular 2 Material Design，切换到material2分支。 node-pre-gyp ERR in npm install (Windows) 答：安装Python x86，Windows版本在2.5 和 3.0之间 参见： #626。 Error:Error: Parse tsconfig error [{&quot;messageText&quot;:&quot;Unknown compiler option &#39;lib&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;strictNullChecks&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;baseUrl&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;paths&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;types&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023}] 答：移除 node_modules/typescript ，然后运行 npm install typescript@beta。当前仓库使用的是ts 2.0。 “There are multiple modules with names that only differ in casing” 答：修改 c:\[path to angular2-webpack-starter] 为 C:\[path to angular2-webpack-starter] （c变为大写）参见： 926#issuecomment-245223547。 支持、问题和反馈 对这个项目或者Angular2有任何问题欢迎随时联系我们 Chat: AngularClass.slack Twitter: @AngularClass Gitter: AngularClass/angular2-webpack-starter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之Webpack简介]]></title>
      <url>%2F2017%2F02%2F11%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BWebpack%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[什么是WebpackWebpack是一个强力的模块打包器。 所谓包(bundle)就是一个JavaScript文件，它把一堆资源(assets)合并在一起，以便它们可以在同一个文件请求中发回给客户端。 包中可以包含JavaScript、CSS样式、HTML以及很多其它类型的文件。 Webpack会遍历你应用中的所有源码，查找import语句，构建出依赖图谱，并产出一个(或多个)包。 通过“加载器(loaders)”插件，Webpack可以对各种非JavaScript文件进行预处理和最小化(Minify)，比如TypeScript、SASS和LESS文件等。 我们通过一个JavaScript配置文件webpack.config.js来决定Webpack做什么以及如何做。 入口与输出给webpack提供一个或多个入口文件，通过入口来让它查找与合并那些从这些入口点发散出去的依赖。 123entry: &#123; app: 'src/app.ts'&#125; app.js输出包是个单一的JavaScript文件，它包含程序的源码及其所有依赖。 123output: &#123; filename: 'app.js'&#125; 多重包Webpack会构造出两个独立的依赖图谱，并产出两个包文件：一个叫做app.js，它只包含我们的应用代码；另一个叫做vendor.js，它包含所有的提供商依赖。 123456789entry: &#123; app: 'src/app.ts', vendor: 'src/vendor.ts'&#125;,output: &#123; filename: '[name].js'&#125;//在输出文件名中出现的[name]是一个Webpack的占位符，它将被替换为入口点的名字，分别是app和vendor。 加载器我们要通过加载器来告诉它如何把JavaScript、TypeScript、CSS、SASS、LESS、图片、HTML以及字体文件等处理成JavaScript文件。 12import &#123; AppComponent &#125; from './app.component.ts';import 'uiframework/dist/uiframework.css'; 12345678910loaders: [ &#123; test: /\.ts$/ loaders: 'ts' &#125;, &#123; test: /\.css$/ loaders: 'style!css' &#125;] 第一个import文件匹配上了.ts模式，于是Webpack就用awesome-typescript-loader加载器处理它。 导入的文件没有匹配上第二个模式，于是它的加载器就被忽略了。 第二个import匹配上了第二个.css模式，它有两个用叹号字符(!)串联起来的加载器。 Webpack会从右到左逐个应用串联的加载器，于是它先应用了css加载器(用来平面化CSS的@import和url(...)语句)， 然后应用了style加载器(用来把css追加到页面上的&lt;style&gt;元素中)。 插件Webpack有一条构建流水线，它被划分成多个经过精心定义的阶段(phase)。 我们可以把插件(比如uglify代码最小化插件)挂到流水线上： 123plugins: [ new webpack.optimize.UglifyJsPlugin()] 配置Webpack公共配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566config/webpack.common.jsvar webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');var helpers = require('./helpers');module.exports = &#123; //把应用拆成三个包：1.polyfills：我们在大多数现代浏览器中运行Angular程序时需要的标准填充物；2.vendor：提供商文件；3.app：应用代码。 entry: &#123; 'polyfills': './src/polyfills.ts', 'vendor': './src/vendor.ts', 'app': './src/main.ts' &#125;, //告诉Webpack如何通过查找匹配的文件来解析模块文件的加载请求 resolve: &#123; //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['', '.ts', '.js'] &#125;, //指定指定加载器 module: &#123; loaders: [ &#123; test: /\.ts$/, //awesome-typescript-loader - 一个用于把TypeScript代码转译成ES5的加载器，它会由tsconfig.json文件提供指导;angular2-template-loader - 用于加载Angular组件的模板和样式 loaders: ['awesome-typescript-loader', 'angular2-template-loader']//多重加载器也能使用数组形式串联起来。 &#125;, &#123; test: /\.html$/, //html - 为组件模板准备的加载器 loader: 'html' &#125;, &#123; test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'file?name=assets/[name].[hash].[ext]' &#125;, &#123; test: /\.css$/, //匹配应用级样式,它只包含了那些位于/src及其上级目录的.css文件 exclude: helpers.root('src', 'app'), loader: ExtractTextPlugin.extract('style', 'css?sourceMap') &#125;, &#123; test: /\.css$/, //匹配组件局部样式(就是在组件元数据的styleUrls属性中指定的那些),通过raw加载器把组件局部样式加载成字符串 include: helpers.root('src', 'app'), loader: 'raw' &#125; ] &#125;, plugins: [ //这里标记出了三个块之间的等级体系：app -&gt; vendor -&gt; polyfills。 当Webpack发现app与vendor有共享依赖时，就把它们从app中移除。 在vendor和polyfills之间有共享依赖时也同样如此，把提供商代码排除在app.js包之外 new webpack.optimize.CommonsChunkPlugin(&#123; name: ['app', 'vendor', 'polyfills'] &#125;), //Webpack可以通过HtmlWebpackPlugin自动为我们注入js和css文件的script和link标签。 new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;) ]&#125;; 开发环境配置12345678910111213141516171819202122232425262728config/webpack.dev.jsvar webpackMerge = require('webpack-merge');var ExtractTextPlugin = require('extract-text-webpack-plugin');var commonConfig = require('./webpack.common.js');var helpers = require('./helpers');module.exports = webpackMerge(commonConfig, &#123; devtool: 'cheap-module-eval-source-map', //HtmlWebpackPlugin(由webpack.common.js引入)插件使用了publicPath和filename设置， 来向index.html中插入适当的&lt;script&gt;和&lt;link&gt;标签。 output: &#123; path: helpers.root('dist'), publicPath: 'http://localhost:8080/', filename: '[name].js', chunkFilename: '[id].chunk.js' &#125;, //ExtractTextPlugin会把CSS提取成外部.css文件， 这样HtmlWebpackPlugin插件就会转而把一个&lt;link&gt;标签写进index.html了 plugins: [ new ExtractTextPlugin('[name].css') ], devServer: &#123; historyApiFallback: true, stats: 'minimal' &#125;&#125;); 产品环境配置123456789101112131415161718192021222324252627282930313233343536373839404142434445config/webpack.prod.jsvar webpack = require('webpack');var webpackMerge = require('webpack-merge');var ExtractTextPlugin = require('extract-text-webpack-plugin');var commonConfig = require('./webpack.common.js');var helpers = require('./helpers');const ENV = process.env.NODE_ENV = process.env.ENV = 'production';module.exports = webpackMerge(commonConfig, &#123; devtool: 'source-map', output: &#123; path: helpers.root('dist'), publicPath: '/', filename: '[name].[hash].js', chunkFilename: '[id].[hash].chunk.js' &#125;, htmlLoader: &#123; minimize: false // workaround for ng2 &#125;, plugins: [ //NoErrorsPlugin - 如果出现任何错误，就终止构建。 new webpack.NoErrorsPlugin(), //DedupePlugin - 检测完全相同(以及几乎完全相同)的文件，并把它们从输出中移除。 new webpack.optimize.DedupePlugin(), //UglifyJsPlugin - 最小化(minify)生成的包。 new webpack.optimize.UglifyJsPlugin(&#123; // https://github.com/angular/angular/issues/10618 mangle: &#123; keep_fnames: true &#125; &#125;), //ExtractTextPlugin - 把内嵌的css抽取成外部文件，并为其文件名添加“缓存无效哈希”。当这些哈希值变化时，自动更新index.html。 new ExtractTextPlugin('[name].[hash].css'), //DefinePlugin - 用来定义环境变量，以便我们在自己的程序中引用它。 new webpack.DefinePlugin(&#123; 'process.env': &#123; 'ENV': JSON.stringify(ENV) &#125; &#125;) ]&#125;); 测试环境配置123456789101112131415161718192021222324252627282930313233343536373839config/webpack.test.jsvar helpers = require('./helpers');module.exports = &#123; devtool: 'inline-source-map', resolve: &#123; extensions: ['', '.ts', '.js'] &#125;, module: &#123; loaders: [ &#123; test: /\.ts$/, loaders: ['awesome-typescript-loader', 'angular2-template-loader'] &#125;, &#123; test: /\.html$/, loader: 'html' &#125;, &#123; test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'null' &#125;, &#123; test: /\.css$/, exclude: helpers.root('src', 'app'), loader: 'null' &#125;, &#123; test: /\.css$/, include: helpers.root('src', 'app'), loader: 'raw' &#125; ] &#125;&#125; 如果有可能拖慢执行速度，甚至都不需要在单元测试中加载和处理应用全局样式文件，所以我们用一个null加载器来处理所有CSS。 123456789101112131415161718192021222324252627282930313233343536373839config/karma.conf.jsvar webpackConfig = require('./webpack.test');module.exports = function (config) &#123; var _config = &#123; basePath: '', frameworks: ['jasmine'], files: [ &#123;pattern: './config/karma-test-shim.js', watched: false&#125; ], preprocessors: &#123; './config/karma-test-shim.js': ['webpack', 'sourcemap'] &#125;, webpack: webpackConfig, webpackMiddleware: &#123; stats: 'errors-only' &#125;, webpackServer: &#123; noInfo: true &#125;, reporters: ['progress'], port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: ['PhantomJS'], singleRun: true &#125;; config.set(_config);&#125;; 123456789101112131415161718192021222324config/karma-test-shim.js//karma-test-shim告诉Karma哪些文件需要预加载，首要的是：带有“测试版提供商”的Angular测试框架是每个应用都希望预加载的。Error.stackTraceLimit = Infinity;require('core-js/es6');require('core-js/es7/reflect');require('zone.js/dist/zone');require('zone.js/dist/long-stack-trace-zone');require('zone.js/dist/proxy');require('zone.js/dist/sync-test');require('zone.js/dist/jasmine-patch');require('zone.js/dist/async-test');require('zone.js/dist/fake-async-test');var appContext = require.context('../src', true, /\.spec\.ts/);appContext.keys().forEach(appContext);var testing = require('@angular/core/testing');var browser = require('@angular/platform-browser-dynamic/testing');testing.TestBed.initTestEnvironment(browser.BrowserDynamicTestingModule, browser.platformBrowserDynamicTesting());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[块级元素和行内元素]]></title>
      <url>%2F2017%2F02%2F07%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[知识点虽然小，但是有的时候突然会忘记，记录一下，好记性不如烂笔头，文章参考块级元素。 块级元素 address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 区别1. 块级元素会独占一行，其宽度自动填满其父元素宽度；行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化2. 块级元素可以设置 width, height属性，行内元素设置width, height无效 （注意：块级元素即使设置了宽度，仍然是独占一行的）3. 块级元素可以设置margin 和 padding. 行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）4. 块级元素可以容纳内联元素和其他块元素，内联元素只能容纳文本或者其他内联元素(内联元素中嵌套块级元素时，块级元素无法继承内联元素的属性。) 网上还看到一个知识点，display:inline-block时元素之间默认有一定的间隙，如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo本地搜索无法使用解决办法]]></title>
      <url>%2F2017%2F02%2F05%2Fhexo%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[突然发现博客的本地搜索不能用了，这样就不能搜索学习笔记里面的内容了，这可是大事，得解决。 查找了github上的issues，发现local search这个issue下面有人提到博客搜索无法使用，显示链接是javascript:;，这不就是我的问题吗，但是这个问题有点蛋疼，需要在文章里面一个个找。 最后在hexo文章添加版权声明及一些特效中第二节中找到了这句话，删除后，搜索就可以用啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm中的AngularJS2模板插件使用]]></title>
      <url>%2F2017%2F02%2F03%2FWebstorm%E4%B8%AD%E7%9A%84AngularJS2%E6%A8%A1%E6%9D%BF%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Angular官方文档的风格指南提到使用IDE的模板来实现统一的风格，里面的IDE没有提到WebStorm，于是网上搜了一下相关资料。 安装插件参照WebStorm 最新 2016 AngularJs 2 代码提示插件安装。 在webstorm的setting或者performance（macos）中选择左侧Plugin选项，然后点击Browse repositories。 在搜索框中搜索Angular 2 TypeScript Live Templates，然后点击Install，会提示重启webstorm，重启后就安装好了。 如果电脑上设置了代理，点击左下角的HTTP proxy settings，选择auto-detect proxy settings，然后再进行下载。 使用插件Angular 2 TypeScript Live Templates (Snippets) for WebStorm的github上有使用说明，我按照这个说明演示一下。 TypeScript Snippets插件对于TypeScript有以下指令： 12345678ng2-component-root // Angular 2 root App componentng2-bootstrap // Angular 2 bootstraping, for main.tsng2-component // Angular 2 componentng2-pipe // Angular 2 pipeng2-routes // Angular 2 @Routesng2-route-path // Angular 2 routing pathng2-service // Angular 2 serviceng2-subscribe // Angular 2 observable subscription 指令会有提示，选择相应的指令会生成预设的模板。 HTML Snippets插件对Angular中的以下指令也有提示： 1234567ng2-ngClassng2-ngForng2-ngIfng2-ngModelng2-routerLinkng2-ngStyleng2-ngSwitch]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo文章添加版权声明及一些特效]]></title>
      <url>%2F2017%2F02%2F02%2Fhexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[看到有的博客上有版权声明的标记，感觉有点逼格，就想自己弄一下。 添加版权声明在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。 在网上找到一篇为Hexo博客的每一篇文章自动追加版权信息，可惜我木有成功。有兴趣的可以试一下。 这时候我想起了Hexo+nexT主题搭建个人博客的5.3中有在文章末尾添加“本文结束”标记的介绍。于是我就仿照写了一个版权声明。 新建 passage-end-tag.swig 文件 在路径\themes\next\layout\_macro中添加passage-end-tag.swig文件，其内容为： 123456789101112131415&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束 ------&lt;/div&gt;&lt;br/&gt;&lt;div style="border: 1px solid black"&gt;&lt;div style="margin-left:10px"&gt;&lt;span style="font-weight:blod"&gt;版权声明&lt;/span&gt;&lt;img src="此处填自己版权声明图片地址" &gt;&lt;br/&gt;&lt;p style="font-size: 10px;line-height: 30px"&gt;&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt; by &lt;a href="http://tc9011.com" style="color:#258FC6"&gt;Cheng Tang&lt;/a&gt; is licensed under a &lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6"&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;由&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;汤诚&lt;/a&gt;创作并维护的&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt;博客采用&lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6"&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;本文首发于&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt; 博客（ &lt;a href="http://tc9011.com" style="color:#258FC6"&gt;http://tc9011.com&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 修改 post.swig 文件 在\themes\next\layout\_macro\post.swig中，post-body之后，post-footer之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件中添加字段 在主题配置文件 _config.yml中添加以下字段开启此功能： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。 添加背景动画背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout\_layout.swig的&lt;/body&gt;上面添加 123&#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在\themes\next\_config.yml中添加以下字段开启此功能： 1234# background settings# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css\_schemes\Pisces\_layout.styl中，把.content-wrap中的background修改为none。 这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。 附上我的.content-wrap配置： 1234567891011121314151617181920212223.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: none; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() &#123; width: 100%; padding: 20px; border-radius: initial; &#125; +mobile() &#123; width: 100%; padding: 20px; min-height: auto; border-radius: initial; background: white; &#125;&#125; 修改一些样式never_yu‘Blog中的文章添加许多样式，看了一下github上的源码，在 themes\next\source\css\_custom\custom.styl 中，添加如下css： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359//修改文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125;//修改不在文章内的链接文本样式.link-blue&#123; color: #f36; &amp;:hover &#123; color: #f00; &#125;&#125;//修改文章内code样式code &#123;color:#fff;background:#333;&#125;//修改文章中图片样式，改为居中.posts-expand .post-body img &#123; margin: 0 auto;&#125;// 下载样式a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125;&#125;//阅读全文样式.post-more-link .btn &#123; position:relative; border: 2px solid #000; border-radius: 2px; padding: 0 10px; font-weight: bold; background: transparent; transition: all .5s ease; &amp;:hover &#123; background: #000; color: #eee; &#125;&#125;//// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-黑span#inline-black &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: black;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125;// 颜色块-红span#inline-red &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #df3e3e;&#125;// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125;//动画模块//第一篇博客中-精于心，简于形-的动画（https://neveryu.github.io/page/2/）span#yu-1 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:110%; cursor:pointer; &amp;:hover &#123; background-color: #000; color: #fff; animation: animate-yu-1 3s ease-in; &#125;&#125;@keyframes animate-yu-1 &#123; 0% &#123; left:-10px; top:0px; &#125; 10% &#123; left:10px; top:0px; &#125; 20% &#123; left:-8px; top:0px; &#125; 30% &#123; left:8px; top:0px; &#125; 40% &#123; left:-5px; top:0px; &#125; 50% &#123; left:5px; top:0px; &#125; 60% &#123; left:-3px; top:0px; &#125; 70% &#123; left:3px; top:0px; &#125; 80% &#123; left:-1px; top:0px; &#125; 90% &#123; left:1px; top:0px; &#125; 100% &#123; left:0px; top:0px; &#125;&#125;//留言页面-[最近访客]-的样式span#yu-2 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:130%;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之风格指南]]></title>
      <url>%2F2017%2F02%2F01%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[单一职责单一法则坚持每个文件只定义一样东西（例如服务或组件）。 考虑把文件大小限制在 400 行代码以内。 简单函数坚持定义简单函数 考虑限制在 75 行之内。 命名总体命名指导原则坚持所有符号使用一致的命名规则。 坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为feature.type.ts。 使用点和横杠分隔文件名坚持 在描述性名字中，用横杠来分隔单词。 坚持使用点来分隔描述性名字和类型。 坚持遵循先描述组件特性，再描述它的类型的模式，对所有组件使用一致的类型命名规则。推荐的模式为feature.type.ts。 坚持使用惯用的后缀来描述类型，包括*.service、*.component、*.pipe、.module、.directive。 必要时可以创建更多类型名，但必须注意，不要创建太多。 符号名与文件名坚持为所有东西使用一致的命名约定，以它们所代表的东西命名。 坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。 坚持在符号名后面追加约定的类型后缀（例如Component、Directive、Module、Pipe、Service）。 坚持在文件名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。 服务名坚持使用一致的规则命名服务，以它们的特性来命名。 坚持使用大写驼峰命名法命名服务。 坚持添加Service后缀，当不清楚它们是什么时（例如当它们是名词时）。 引导坚持把应用的引导程序和平台相关的逻辑放到名为main.ts的文件里。 坚持在引导逻辑中包含错误处理代码。 避免把应用逻辑放在main.ts中，而应放在组件或服务里。 指令选择器坚持使用小驼峰命名法来命名指令的选择器。 为组件添加自定义前缀坚持使用带连字符的小写元素选择器值（例如admin-users）。 坚持为组件选择器添加自定义前缀。 例如，toh前缀表示 Tour of Heroes（英雄指南），而前缀`admin表示管理特性区。 坚持使用前缀来识别特性区或者应用程序本身。 为指令添加自定义前缀坚持为指令的选择器添加自定义前缀（例如前缀toh来自Tour of Heroes）。 坚持用小驼峰形式拼写非元素选择器，除非该选择器用于匹配原生 HTML 属性。 管道名坚持为所有管道使用一致的命名约定，用它们的特性来命名。 单元测试文件名坚持测试规格文件名与被测试组件文件名相同。 坚持测试规格文件名添加.spec后缀。 端到端测试文件名坚持端到端测试规格文件和它们所测试的特性同名，添加.e2e-spec后缀。 Angular NgModule 命名坚持为符号名添加Module后缀 坚持为文件名添加.module.ts扩展名。 坚持用特性名和所在目录命名模块。 坚持为 RoutingModule 类名添加RoutingModule后缀。 坚持为 RoutingModule 的文件名添加-routing.module.ts后缀。 代码约定类坚持使用大写驼峰命名法来命名类。 常量坚持用const声明变量，除非它们的值在应用的生命周期内会发生变化。 考虑 把常量名拼写为小驼峰格式。 坚持容许现存的const常量沿用大写蛇形命名法。 123export const mockHeroes = ['Sam', 'Jill']; // preferexport const heroesUrl = 'api/heroes'; // preferexport const VILLAINS_URL = 'api/villains'; // tolerate 接口坚持使用大写驼峰命名法来命名接口。 考虑不要在接口名字前面加I前缀。（TypeScript 指导原则不建议使用 “I” 前缀。） 考虑用类代替接口。（单独一个类的代码量小于类+接口；类可以作为接口使用，只是用implements代替extends而已；在 Angular 依赖注入系统中，接口类可以作为服务提供商的查找令牌。） 属性和方法坚持使用小写驼峰命名法来命名属性和方法。 避免为私有属性和方法添加下划线前缀。 导入语句中的空行坚持在第三方导入和应用导入之间留一个空行。 考虑按模块名字的字母顺排列导入行。 考虑在解构表达式中按字母顺序排列导入的东西。 应用结构与Angular模块所有应用程序的源代码都放到名叫app的目录里。 所有特性区都在自己的文件夹中，带有它们自己的 Angular 模块。 所有内容都遵循每个文件一个特性的原则。每个组件、服务和管道都在自己的文件里。 所有第三方程序包保存到其它目录里，不是app目录。 LIFT坚持组织应用的结构，达到这些目的：快速定位 (Locate) 代码、一眼识别 (Identify) 代码、 尽量保持扁平结构 (Flattest) 和尝试 (Try) 遵循DRY (Do Not Repeat Yourself, 不重复自己) 原则。 坚持四项基本原则定义文件结构，上面的原则是按重要顺序排列的。 定位坚持直观、简单和快速地定位代码。 识别坚持命名文件到这个程度：看到名字立刻知道它包含了什么，代表了什么。 坚持文件名要具有说明性，确保文件中只包含一个组件。 避免创建包含多个组件、服务或者混合体的文件。 扁平坚持尽可能保持扁平的目录结构。 考虑当同一目录下达到 7 个或更多个文件时创建子目录。 考虑配置 IDE，以隐藏无关的文件，例如生成出来的.js文件和.js.map文件等。 T-DRY （尝试不重复自己）坚持 DRY（Don’t Repeat Yourself，不重复自己）。 避免过度 DRY，以致牺牲了阅读性。 总体结构指导原则坚持从零开始，但要考虑应用程序接下来的路往哪儿走。 坚持有一个近期实施方案和一个长期的愿景。 坚持把所有源代码都放到名为app的目录里。 坚持如果组件具有多个伴隨文件 (.ts、.html、.css和.spec)，就为它创建一个文件夹。 下面是符合规范的目录和文件结构： 按特性组织的目录结构坚持根据特性区命名目录。 坚持为每个特性区创建一个 Angular 模块。 应用的根模块坚持在应用的根目录创建一个 Angular 模块（例如/app）。 考虑把根模块命名为app.module.ts。 特性模块坚持为应用中每个明显的特性创建一个 Angular 模块。 坚持把特性模块放在与特性区同名的目录中（例如app/heroes）。 坚持特性模块的文件名应该能反映出特性区的名字和目录（例如app/heroes/heroes.module.ts）。 坚持特性模块的符号名应该能反映出特性区、目录和文件名（例如在app/heroes/heroes.module.ts中定义HeroesModule）。 共享特性模块坚持在shared目录中创建名叫SharedModule的特性模块（例如在app/shared/shared.module.ts中定义SharedModule）。 坚持把可能被应用其它特性模块使用的公共组件、指令和管道放在SharedModule中，这些资产倾向于共享自己的新实例（而不是单例）。 坚持在SharedModule中导入所有模块都需要的资产（例如CommonModule和FormsModule）。 坚持在SharedModule中声明所有组件、指令和管道。 坚持从SharedModule中导出其它特性模块所需的全部符号。 避免在SharedModule中指定应用级的单例服务提供商。但如果是故意设计的单例也可以，不过还是要小心。 核心特性模块坚持把那些“只用一次”的类收集到CoreModule中，并对外隐藏它们的实现细节。简化的AppModule会导入CoreModule，并且把它作为整个应用的总指挥。 坚持在core目录下创建一个名叫CoreModule的特性模块（例如在app/core/core.module.ts中定义CoreModule）。 坚持把一个要共享给整个应用的单例服务放进CoreModule中（例如ExceptionService和LoggerService）。 坚持导入CoreModule中的资产所需要的全部模块（例如CommonModule和FormsModule）。 坚持把应用级、只用一次的组件收集到CoreModule中。 只在应用启动时从AppModule中导入它一次，以后再也不要导入它（例如NavComponent和SpinnerComponent）。 避免在AppModule之外的任何地方导入CoreModule。 坚持从CoreModule中导出AppModule需导入的所有符号，使它们在所有特性模块中可用。 防止多次导入CoreModule坚持防范多次导入CoreModule，并通过添加守卫逻辑来尽快失败。(守卫可以阻止对CoreModule的多次导入,守卫会禁止创建单例服务的多个实例。) 1234567app/core/module-import-guard.tsexport function throwIfAlreadyLoaded(parentModule: any, moduleName: string) &#123; if (parentModule) &#123; throw new Error(`$&#123;moduleName&#125; has already been loaded. Import Core modules in the AppModule only.`); &#125;&#125; 惰性加载的目录坚持把惰性加载特性下的内容放进惰性加载目录中。 典型的惰性加载目录包含路由组件及其子组件以及与它们有关的那些资产和模块。 永远不要直接导入惰性加载的目录避免让兄弟模块和父模块直接导入惰性加载特性中的模块。 组件组件选择器命名坚持使用中线 (dashed) 命名法或烤串 (kebab) 命名法来命名组件中的元素选择器。 把组件当做元素坚持通过选择器把组件定义为元素。 把模板和样式提取到它们自己的文件坚持当超过 3 行时，把模板和样式提取到一个单独的文件。 坚持把模板文件命名为[component-name].component.html，其中，[component-name] 是组件名。 坚持把样式文件命名为[component-name].component.css，其中，[component-name] 是组件名。 内联输入和输出属性装饰器坚持 使用@Input和@Output，而非@Directive和@Component装饰器的inputs和outputs属性: 坚持把@Input()或者@Output()放到所装饰的属性的同一行。 避免重命名输入和输出避免重命名输入和输出。 成员顺序坚持把属性成员放在前面，方法成员放在后面。 坚持先放公共成员，再放私有成员，并按照字母顺序排列。 12345678910111213141516171819202122232425262728293031export class ToastComponent implements OnInit &#123; // public properties message: string; title: string; // private fields private defaults = &#123; title: '', message: 'May the Force be with You' &#125;; private toastElement: any; // public methods activate(message = this.defaults.message, title = this.defaults.title) &#123; this.title = title; this.message = message; this.show(); &#125; ngOnInit() &#123; this.toastElement = document.getElementById('toh-toast'); &#125; // private methods private hide() &#123; this.toastElement.style.opacity = 0; window.setTimeout(() =&gt; this.toastElement.style.zIndex = 0, 400); &#125; private show() &#123; console.log(this.message); this.toastElement.style.opacity = 1; this.toastElement.style.zIndex = 9999; window.setTimeout(() =&gt; this.hide(), 2500); &#125;&#125; 把逻辑放到服务里坚持在组件中只包含与视图相关的逻辑。所有其它逻辑都应该放到服务中。 坚持把可重用的逻辑放到服务中，保持组件简单，聚焦于它们预期目的。 不要给输出属性加前缀坚持命名事件时，不要带前缀on。 坚持把事件处理器方法命名为on前缀之后紧跟着事件名。 12345export class HeroComponent &#123; @Output() savedTheDay = new EventEmitter&lt;boolean&gt;();&#125;&lt;toh-hero (savedTheDay)="onSavedTheDay($event)"&gt;&lt;/toh-hero&gt; 把表现层逻辑放到组件类里坚持把表现层逻辑放进组件类中，而不要放在模板里。 指令使用指令来加强已有元素坚持当你需要有表现层逻辑，但没有模板时，使用属性型指令。 使用 HostListener 和 HostBinding 类装饰器考虑优先使用@HostListener和@HostBinding，而不是@Directive和@Component装饰器的host属性。 坚持让你的选择保持一致。 12345678910import &#123; Directive, HostBinding, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[tohValidator]'&#125;)export class ValidatorDirective &#123; @HostBinding('attr.role') role = 'button'; @HostListener('mouseenter') onMouseEnter() &#123; // do work &#125;&#125; 服务注入器中，服务总是单例的坚持在同一个注入器内，把服务当做单例使用。用它们来共享数据和功能。 单一职责坚持创建单一职责的服务，用职责封装在它的上下文中。 坚持当服务成长到超出单一用途时，创建一个新服务。 提供一个服务坚持将服务提供到共享范围内的顶级组件的 Angular 注入器。 使用 @Injectable() 类装饰器坚持当使用类型作为令牌来注入服务的依赖时，使用@Injectable类装饰器，而非@Inject参数装饰器。 数据服务分离数据调用坚持把数据操作和互动重构到服务里。 坚持让数据服务来负责 XHR 调用、本地储存、内存储存或者其它数据操作。 生命周期钩子使用生命周期钩子来介入到 Angular 暴露的重要事件里。 实现生命周期钩子接口坚持实现生命周期钩子接口。 附录Codelyzer坚持使用 codelyzer 来实施本指南。 考虑调整 codelyzer 的规则来满足你的需求。 文档模板和代码片段坚持使用文件模板或代码片段来帮助实现一致的风格和模式。 考虑使用 Visual Studio Code的代码片段 来实施本风格指南。 考虑使用 Atom 的代码片断来实施本风格指南。 考虑使用 Sublime Text的代码片断 来实施本风格指南。 考虑使用 Vim 的代码片断来实施本风格指南。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之开发指南]]></title>
      <url>%2F2017%2F01%2F31%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[根模块import数组12345678910import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser'; //必须要有import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; imports: [ BrowserModule ], declarations: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; Angular 模块的imports数组与文件顶部的import语句功能是不同的。 JavaScript 的import声明允许你访问在其他文件中导出的符号，这样你可以在当前文件引用它们。 它们与 Angular 毫无关系，Angular 对它们也一无所知。 模块的imports数组声明的组件模板需要的类所在的其它模块（引入所需的其他模块的组件模板），告诉 Angular 特定 Angular 模块的信息 — 用@NgModule装饰的类 — 应用需要它们来正常工作。 declarations数组声明本模块中拥有的视图类（组件、指令和管道）。 bootstrap数组引导根模块来启动应用，数组中的组件是插入到浏览器的DOM中的。 每个被引导的组件都是它自己的组件树的根。 插入一个被引导的组件通常触发一系列组件的创建并形成组件树。 在main.ts中引导1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); 通过动态 (JiT) 编译创建浏览器平台来引导根模块。根模块调用组件，插入到组件选择器中。 显示数据使用插值表达式显示组件属性通过插值表达式 (interpolation) 来绑定属性名。要使用插值表达式，就把属性名包裹在双花括号里放进视图模板。 Angular 在index.html中查找一个&lt;my-app&gt;元素， 然后实例化一个AppComponent，并将其渲染到&lt;my-app&gt;标签中。不需要通过new来实例化AppComponent类。 通过构造函数来声明和初始化属性。 使用ngFor显示数组属性ngFor用于显示一个“数组”， 但ngFor可以为任何可迭代的 (iterable)对象重复渲染条目。 应用代码最好不要直接在组件内部直接定义数据。用一个 TypeScript 类来为我们的组件描述模型数据并显示模型的属性。 12345export class Hero &#123; constructor( public id: number, public name: string) &#123; &#125;&#125; 1234567heroes = [ new Hero(1, 'Windstorm'), new Hero(13, 'Bombasto'), new Hero(15, 'Magneta'), new Hero(20, 'Tornado')];myHero = this.heroes[0]; 通过 NgIf 进行条件显示NgIf中Angular 并不是在显示和隐藏这条消息，它是在从 DOM 中添加和移除这个段落元素。 用户输入绑定到用户输入事件使用Angular 事件绑定机制来响应任何 DOM 事件。要绑定 DOM 事件，只要把 DOM 事件的名字包裹在圆括号中，然后用放在引号中的模板语句对它赋值就可以了。 通过 $event 对象取得用户输入（不推荐）下面的代码监听keyup事件，并将整个事件载荷 ($event) 传递给组件的事件处理器。当用户按下并释放一个按键时，触发keyup事件，Angular 在$event变量提供一个相应的 DOM 事件对象，上面的代码将它作为参数传递给onKey()方法。 1234template: ` &lt;input (keyup)="onKey($event)"&gt; &lt;p&gt;&#123; &#123;values&#125; &#125;&lt;/p&gt;` 1234567export class KeyUpComponent_v1 &#123; values = ''; onKey(event:any) &#123; // without type info this.values += event.target.value + ' | '; &#125;&#125; $event对象的属性取决于 DOM 事件的类型。所有标准 DOM 事件对象都有一个target属性， 引用触发该事件的元素。 在本例中，target是&lt;input&gt;元素， value.target.value返回该元素的当前内容。 event.key可以用来记录每次按键本身。 $event的类型是KeyboardEvent。 不是所有的元素都有value属性，所以它将target转换为输入元素。 OnKey方法更加清晰的表达了它期望从模板得到什么，以及它是如何解析事件的。 1234567export class KeyUpComponent_v1 &#123; values = ''; onKey(event: KeyboardEvent) &#123; // with type info this.values += (&lt;HTMLInputElement&gt;event.target).value + ' | '; &#125;&#125; 传入 $event 是靠不住的做法，反对把整个 DOM 事件传到方法中，因为这样组件会知道太多模板的信息。 只有当它知道更多它本不应了解的 HTML 实现细节时，它才能提取信息。 这就违反了模板（用户看到的）和组件（应用如何处理用户数据）之间的分离关注原则。(事件一定要定义类型)。 从一个模板引用变量中获得用户输入使用 Angular 的模板引用变量。 这些变量提供了从模块中直接访问元素的能力。 在标识符前加上井号 (#) 就能声明一个模板引用变量。 12345678@Component(&#123; selector: 'loop-back', template: ` &lt;input #box (keyup)="0"&gt; //(keyup)="0"可以当成将keyup事件初始化 &lt;p&gt;&#123; &#123;box.value&#125; &#125;&lt;/p&gt; `&#125;)export class LoopbackComponent &#123; &#125; 这个模板引用变量名叫box，在&lt;input&gt;元素声明，它引用&lt;input&gt;元素本身。 代码使用box获得输入元素的value值，并通过插值表达式把它显示在&lt;p&gt;标签中。 这个模板完全是完全自包含的。它没有绑定到组件，组件也没做任何事情。 只有在应用做了些异步事件（如击键），Angular 才更新绑定（并最终影响到屏幕）。 本例代码将keyup事件绑定到了数字0，这是可能是最短的模板语句。 虽然这个语句不做什么，但它满足 Angular 的要求，所以 Angular 将更新屏幕。 12345678910111213@Component(&#123; selector: 'key-up2', template: ` &lt;input #box (keyup)="onKey(box.value)"&gt; &lt;p&gt;&#123; &#123;values&#125; &#125;&lt;/p&gt; `&#125;)export class KeyUpComponent_v2 &#123; values = ''; onKey(value: string) &#123; this.values += value + ' | '; &#125;&#125; 组件代码从视图中获得了干净的数据值。再也不用了解$event变量及其结构了。 按键事件过滤（通过key.enter）(keyup)事件处理器监听每一次按键。 有时只在意回车键，因为它标志着用户结束输入。 解决这个问题的一种方法是检查每个$event.keyCode，只有键值是回车键时才采取行动。 更简单的方法是：绑定到 Angular 的keyup.enter 模拟事件。 然后，只有当用户敲回车键时，Angular 才会调用事件处理器。 1234567891011@Component(&#123; selector: 'key-up3', template: ` &lt;input #box (keyup.enter)="onEnter(box.value)"&gt; &lt;p&gt;&#123; &#123;value&#125; &#125;&lt;/p&gt; `&#125;)export class KeyUpComponent_v3 &#123; value = ''; onEnter(value: string) &#123; this.value = value; &#125;&#125; 失去焦点事件 (blur)1234567891011121314@Component(&#123; selector: 'key-up4', template: ` &lt;input #box (keyup.enter)="update(box.value)" (blur)="update(box.value)"&gt; //监听失去焦点事件 &lt;p&gt;&#123; &#123;value&#125; &#125;&lt;/p&gt; `&#125;)export class KeyUpComponent_v4 &#123; value = ''; update(value: string) &#123; this.value = value; &#125;&#125; 小结1234567891011121314151617181920@Component(&#123; selector: 'little-tour', template: ` &lt;input #newHero (keyup.enter)="addHero(newHero.value)" (blur)="addHero(newHero.value); newHero.value='' "&gt; &lt;button (click)=addHero(newHero.value)&gt;Add&lt;/button&gt; &lt;ul&gt;&lt;li *ngFor="let hero of heroes"&gt;&#123; &#123;hero&#125; &#125;&lt;/li&gt;&lt;/ul&gt; `&#125;)export class LittleTourComponent &#123; heroes = ['Windstorm', 'Bombasto', 'Magneta', 'Tornado']; addHero(newHero: string) &#123; if (newHero) &#123; this.heroes.push(newHero); &#125; &#125;&#125; 使用模板变量来引用元素 — newHero模板变量引用了&lt;input&gt;元素。 你可以在&lt;input&gt;的任何兄弟或子级元素中引用newHero。 传递数值，而非元素 — 获取输入框的值并将它传递给组件的addHero，而不要传递newHero。 保持模板语句简单 — (blur)事件被绑定到两个 JavaScript 语句。 第一句调用addHero。第二句newHero.value=&#39;&#39;在添加新英雄到列表中后清除输入框。 表单创建 Hero 模型类12345678export class Hero &#123; constructor( public id: number, public name: string, public power: string, public alterEgo?: string //?表示alterEgo是可选的，调用构造函数时可省略 ) &#123; &#125;&#125; 创建表单组件12345678910111213141516import &#123; Component &#125; from '@angular/core';import &#123; Hero &#125; from './hero';@Component(&#123; moduleId: module.id, selector: 'hero-form', templateUrl: 'hero-form.component.html'&#125;)export class HeroFormComponent &#123; powers = ['Really Smart', 'Super Flexible', 'Super Hot', 'Weather Changer']; model = new Hero(18, 'Dr IQ', this.powers[0], 'Chuck Overstreet'); submitted = false; onSubmit() &#123; this.submitted = true; &#125; // TODO: Remove this when we're done get diagnostic() &#123; return JSON.stringify(this.model); &#125;&#125; 创建初始 HTML 表单模板1234567891011121314&lt;div class="container"&gt; &lt;h1&gt;Hero Form&lt;/h1&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control" id="name" required&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt; &lt;input type="text" class="form-control" id="alterEgo"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; Name &lt;input&gt;控件具有 HTML5 的required属性。container、form-group、form-control和btn类来自 Twitter Bootstrap。 添加样式表。 在应用的根目录下打开终端窗口，输入如下命令： 1npm install bootstrap --save 打开index.html文件并且把下列链接添加到&lt;head&gt;中。 1&lt;link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css"&gt; 使用 ngModel 进行双向数据绑定1234&lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name"&gt; TODO: remove this: &#123; &#123;model.name&#125; &#125; &lt;input&gt;标签还添加了name属性 (attribute)，并设置为 “name”，表示英雄的名字。 使用任何唯一的值都可以，但使用具有描述性的名字会更有帮助。 当在表单中使用[(ngModel)]时，必须要定义name属性。 1234567891011121314151617181920&#123; &#123;diagnostic&#125; &#125; &lt;!--反映出诊断信息--&gt;&lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt; &lt;input type="text" class="form-control" id="alterEgo" [(ngModel)]="model.alterEgo" name="alterEgo"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="power"&gt;Hero Power&lt;/label&gt; &lt;select class="form-control" id="power" required [(ngModel)]="model.power" name="power"&gt; &lt;option *ngFor="let pow of powers" [value]="pow"&gt;&#123; &#123;pow&#125; &#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 每个 input 元素都有id属性，label元素的for属性用它来匹配到对应的输入控件。 每个 input 元素都有name属性，Angular 表单用它注册控件。 在属性绑定中，值从模型中流动到屏幕上的目标属性 (property)。 通过把属性名括在方括号中来标记出目标属性，[]。 这是从模型到视图的单向数据绑定。 在事件绑定中，值从屏幕上的目标属性流动到模型。 通过把属性名括在圆括号中来标记出目标属性，()。 这是从视图到模型的反向单向数据绑定。 Angular 选择了组合标点 [()] 来标记出双向数据绑定和双向数据流。 123[(ngModel)] = 'model.name' 等同于[ngModel]="model.name" name="name" +(ngModelChange)="model.name = $event" ngModelChange并不是&lt;input&gt;元素的事件。 它实际上是来自NgModel指令的事件属性。 当 Angular 在表单中看到[(x)]的绑定目标时， 它会期待这个x指令有一个名为x的输入属性，和一个名为xChange的输出属性。 通过 ngModel 跟踪修改状态与有效性验证在表单中使用ngModel可以获得比仅使用双向数据绑定更多的控制权。 NgModel 指令不仅仅跟踪状态。它还使用特定的 Angular CSS 类来更新控件，以反映当前状态。 可以利用这些 CSS 类来修改控件的外观，显示或隐藏消息。 12345&lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name" #spy &gt;&lt;br&gt;TODO: remove this: &#123; &#123;spy.className&#125; &#125; spy.className输出当前状态下的class。在表单中不同状态下，Angular会赋予特定的css类。 添加用于视觉反馈的自定义 CSS1234567.ng-valid[required], .ng-valid.required &#123; border-left: 5px solid #42A948; /* green */&#125;.ng-invalid:not(form) &#123; border-left: 5px solid #a94442; /* red */&#125; 这些样式的作用于两个 Angular 有效性类和 HTML 5 的 “required” 属性。 显示和隐藏验证错误信息123456789&lt;label for="name"&gt;Name&lt;/label&gt;&lt;input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name" #name="ngModel" &gt;&lt;div [hidden]="name.valid || name.pristine" class="alert alert-danger"&gt; Name is required&lt;/div&gt; 模板引用变量可以访问模板中输入框的 Angular 控件。 这里，创建了名叫name的变量，并且赋值为 “ngModel”。把name设置为ngModel是因为ngModel指令的exportAs属性设置成了 “ngModel”。 [hidden]把属性hidden绑定到模板变量为name的属性。当控件是有效的 (valid) 或全新的 (pristine) 时，隐藏消息。 “全新的”意味着从它被显示在表单中开始，用户还从未修改过它的值（即页面一打开时，就隐藏提示信息）。 添加英雄及重置表单更换了英雄并不会重置控件的“全新”状态，在调用newHero()方法后调用表单的reset()方法即可清除所有标记。 1&lt;button type="button" class="btn btn-default" (click)="newHero(); heroForm.reset()"&gt;New Hero&lt;/button&gt; 使用 ngSubmit 提交表单1&lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt; 定义了模板变量heroForm，并初始化为ngForm。heroForm变量引用的是NgForm指令，它代表的是表单的整体。 NgForm指令为form元素扩充了额外的特性。 它持有通过ngModel指令和name属性为各个元素创建的那些控件，并且监视它们的属性变化，包括有效性。 它还有自己的valid属性，只有当其中所有控件都有效时，它才有效。 1&lt;button type="submit" class="btn btn-default" [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt; 通过heroForm变量把按钮的disabled属性绑定到表单的整体有效性。 切换两个表单区域12345678&lt;div [hidden]="submitted"&gt; &lt;h1&gt;Hero Form&lt;/h1&gt; &lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt; &lt;!-- ... all of the form ... --&gt; &lt;/form&gt;&lt;/div&gt; 把div的hidden属性绑定到HeroFormComponent.submitted属性。主表单从一开始就是可见的，因为submitted属性是 false，直到提交了这个表单。 1234567891011121314151617&lt;div [hidden]="!submitted"&gt; &lt;h2&gt;You submitted the following:&lt;/h2&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;Name&lt;/div&gt; &lt;div class="col-xs-9 pull-left"&gt;&#123; &#123; model.name &#125; &#125;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;Alter Ego&lt;/div&gt; &lt;div class="col-xs-9 pull-left"&gt;&#123; &#123; model.alterEgo &#125; &#125;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;Power&lt;/div&gt; &lt;div class="col-xs-9 pull-left"&gt;&#123; &#123; model.power &#125; &#125;&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;button class="btn btn-default" (click)="submitted=false"&gt;Edit&lt;/button&gt;&lt;/div&gt; 当表单处于已提交状态时，submitted属性是true，hidden属性为false，通过差值表达式把已填内容显示为只读内容。 依赖注入为什么需要依赖注入？依赖注入是一种编程模式，可以让类从外部源中获得它的依赖，而不必亲自创建它们。 一个对象不需要知道如何创建另外的对象，只需简单地请求想要什么，注入器就会交付给它们。 Angular 依赖注入在服务中暴露获取数据的方法，通过注册provider来配置注入器。provider为应用创建所需服务。 NgModule 中的provider是被注册到根注入器。这意味着在 NgModule 中注册的provider可以被整个应用访问。 在应用组件中注册的provider只在该组件及其子组件中可用。 构造函数参数类型中引入所需的服务。 构造函数参数类型、@Component装饰器和父级的providers信息合起来告诉 Angular 的注入器， 任何新建HeroListComponent的时候，注入一个HeroService的实例。 Angular DI 是一个分层的依赖注入系统，这意味着嵌套的注入器可以创建它们自己的服务实例。 设计一个适合依赖注入的类，可以让这个类更容易测试。 要有效的测试应用中的一部分，只需要在构造函数的参数中列出依赖。 1234567let expectedHeroes = [&#123;name: 'A'&#125;, &#123;name: 'B'&#125;]let mockService = &lt;HeroService&gt; &#123;getHeroes: () =&gt; expectedHeroes &#125;it('should have heroes when HeroListComponent created', () =&gt; &#123; let hlc = new HeroListComponent(mockService); expect(hlc.heroes.length).toEqual(expectedHeroes.length);&#125;); 当服务需要别的服务时，同样用构造函数注入模式添加所需服务。 @Injectable() 标识一个类可以被注入器实例化。 通常，在试图实例化没有被标识为@Injectable()的类时，注入器会报错。 每个服务类都添加@Injectable()，包括那些没有依赖严格来说并不需要它的。 @Component（和随后将会学到的@Directive和@Pipe一样）是 Injectable的子类型。 在运行时，注入器可以从编译后的 JavaScript 代码中读取类的元数据， 并使用构造函数的参数类型信息来决定注入什么。 总是使用@Injectable()的形式，不能只用@Injectable。 如果忘了括号，应用就会神不知鬼不觉的失败！ 注入器的提供商们提供商提供依赖值的一个具体的、运行时的版本。 注入器依靠提供商创建服务的实例，注入器再将服务的实例注入组件或其它服务。 必须为注入器注册一个服务的提供商，否则它不知道该如何创建该服务。 Provider类和 provide对象常量providers: [Logger]这其实是用于注册提供商的简写表达式。 使用的是一个带有两个属性的提供商对象字面量：[{ provide: Logger, useClass: Logger }]。 第一个是令牌 (token)，它作为键值 (key) 使用，用于定位依赖值和注册提供商。 第二个是供应商定义对象。 可以把它看做是指导如何创建依赖值的配方。 备选的类提供商某些时候，我们会请求一个不同的类来提供服务。 下列代码告诉注入器，当有人请求Logger时，返回BetterLogger。 1[&#123; provide: Logger, useClass: BetterLogger &#125;] 别名类提供商123[ NewLogger, // Alias OldLogger w/ reference to NewLogger &#123; provide: OldLogger, useExisting: NewLogger&#125;] 使用useExisting选项指定别名，实现在同时存在新老类的情况下，使用老类名称的时候也能调用新类的功能。 值提供商有时，提供一个预先做好的对象会比请求注入器从类中创建它更容易。 12345// An object in the shape of the logger servicelet silentLogger = &#123; logs: ['Silent logger says "Shhhhh!". Provided via "useValue"'], log: () =&gt; &#123;&#125;&#125;; 可以通过useValue选项来注册提供商，它会让这个对象直接扮演 logger 的角色。 1[&#123; provide: Logger, useValue: silentLogger &#125;] 工厂提供商有时，我们需要动态创建这个依赖值，因为它所需要的信息直到最后一刻才能确定。 也许这个信息会在浏览器的会话中不停地变化。还假设这个可注入的服务没法通过独立的源访问此信息。这种情况下使用工厂提供商。 构造函数带上一个布尔型的标志，来控制是否显示隐藏的英雄。 123456789constructor( //服务中的构造函数 private logger: Logger, private isAuthorized: boolean) &#123; &#125;getHeroes() &#123; let auth = this.isAuthorized ? 'authorized ' : 'unauthorized'; this.logger.log(`Getting heroes for $&#123;auth&#125; user.`); return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);&#125; 我们可以注入Logger，但是不能注入逻辑型的isAuthorized。 我们不得不通过通过工厂提供商创建这个HeroService的新实例。工厂提供商需要一个工厂方法： 123let heroServiceFactory = (logger: Logger, userService: UserService) =&gt; &#123; return new HeroService(logger, userService.user.isAuthorized);&#125;; 虽然HeroService不能访问UserService，但是工厂方法可以。同时把Logger和UserService注入到工厂提供商中，并且让注入器把它们传给工厂方法： 12345export let heroServiceProvider = &#123; provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService] &#125;; useFactory字段告诉 Angular：这个提供商是一个工厂方法，它的实现是heroServiceFactory。 deps属性是提供商令牌数组。 Logger和UserService类作为它们自身类提供商的令牌。 注入器解析这些令牌，把相应的服务注入到工厂函数中相应的参数中去。 注意，我们在一个导出的变量中捕获了这个工厂提供商：heroServiceProvider。 这个额外的步骤让工厂提供商可被复用。 无论哪里需要，都可以使用这个变量注册HeroService。 依赖注入令牌当向注入器注册提供商时，实际上是把这个提供商和一个 DI 令牌关联起来了。 注入器维护一个内部的令牌-提供商映射表，这个映射表会在请求依赖时被引用到。 令牌就是这个映射表中的键值。 在前面的所有例子中，依赖值都是一个类实例，并且类的类型作为它自己的查找键值。 在下面的代码中，HeroService类型作为令牌，直接从注入器中获取HeroService 实例： 1heroService: HeroService = this.injector.get(HeroService); 编写需要基于类的依赖注入的构造函数对我们来说是很幸运的。 只要定义一个HeroService类型的构造函数参数， Angular 就会知道把跟HeroService类令牌关联的服务注入进来： 1constructor(heroService: HeroService) 非依赖类注入的东西是一个字符串，函数或者对象时，需要定义和使用 OpaqueToken（不透明的令牌）。 123import &#123; OpaqueToken &#125; from '@angular/core';export let APP_CONFIG = new OpaqueToken('app.config'); 使用这个OpaqueToken对象注册依赖的提供商： 1providers: [&#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;] 在@Inject装饰器的帮助下，这个配置对象可以注入到任何需要它的构造函数中： 123constructor(@Inject(APP_CONFIG) config: AppConfig) &#123; this.title = config.title;&#125; 或者在 ngModule 中提供并注入这个配置对象，如AppModule。 1234providers: [ UserService, &#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;], 可选依赖HeroService需要一个Logger，但是如果想不提供 Logger 也能得到它，该怎么办呢？ 可以把构造函数的参数标记为@Optional()，告诉 Angular 该依赖是可选的： 1234567import &#123; Optional &#125; from '@angular/core';constructor(@Optional() private logger: Logger) &#123; if (this.logger) &#123; this.logger.log(some_message); &#125;&#125; 当使用@Optional()时，代码必须准备好如何处理空值。 如果其它的代码没有注册一个 logger，注入器会设置该logger的值为空 null。 模板语法插值表达式1&lt;p&gt;My current hero is &#123; &#123;currentHero.firstName&#125; &#125;&lt;/p&gt; 插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值。 一般来说，括号间的素材是一个模板表达式，Angular 先对它求值，再把它转换成字符串。 模板表达式模板表达式产生一个值。 Angular 执行这个表达式，并把它赋值给绑定目标的属性，这个绑定目标可能是 HTML 元素、组件或指令。 当我们写{ {1 + 1} }时，是往插值表达式的括号中放进了一个模板表达式。 在属性绑定中会再次看到模板表达式，它出现在=右侧的引号中，看起来像这样：[property]=&quot;expression&quot;。 JavaScript中在Angular模板表达式中禁止的运算符： 赋值 (=, +=, -=, …) new运算符 使用;或,的链式表达式 自增或自减操作符 (++和--) 不支持位运算|和&amp; 具有新的模板表达式运算符，比如|和?. 模板表达式不能引用全局命名空间中的任何东西。 它们被局限于只能访问来自表达式上下文中的成员。 典型的表达式上下文就是这个组件实例，它是各种绑定值的来源。 通常，组件本身就是表达式的上下文，这种情况下，模板表达式会引用那个组件。 表达式的上下文可以包括组件之外的对象。 模板引用变量就是备选的上下文对象之一。 模板表达式要遵循： 没有可见的副作用。模板表达式除了目标属性的值以外，不应该改变应用的任何状态。 执行迅速。表达式应该快速结束，否则用户就会感到拖沓，特别是在较慢的设备上。 非常简单。常规是属性名或方法调用。偶尔的逻辑取反 (!) 也还凑合。 幂等性。幂等的表达式应该总是返回完全相同的东西，直到某个依赖值发生改变。 模板语句模板语句用来响应由绑定目标（如 HTML 元素、组件或指令）触发的事件。它出现在=号右侧的引号中，就像这样：(event)=&quot;statement&quot;。它支持基本赋值 (=) 和表达式链 (;和,)。 然而，某些 JavaScript 语法仍然是不允许的： new运算符 自增和自减运算符：++和-- 操作并赋值，例如+=和-= 位操作符|和&amp; 模板表达式运算符 语句只能引用语句上下文中 —— 通常是正在绑定事件的那个组件实例。 在事件绑定语句中，经常会看到被保留的$event符号，它代表触发事件的“消息”或“有效载荷”。 绑定语法 1&lt;button [disabled]="isUnchanged"&gt;Save&lt;/button&gt; 一旦开始数据绑定，就不再跟 HTML attribute 打交道了。 这里不是设置 attribute，而是设置 DOM 元素、组件和指令的 property。 attribute 是由 HTML 定义的。property 是由 DOM (Document Object Model) 定义的。 少量 HTML attribute 和 property 之间有着 1:1 的映射，如id。 有些 HTML attribute 没有对应的 property，如colspan。 有些 DOM property 没有对应的 attribute，如textContent。 大量 HTML attribute看起来映射到了property…… 但却不像我们想的那样！ attribute 初始化 DOM property，然后它们的任务就完成了。property 的值可以改变；attribute 的值不能改变。 例如，当浏览器渲染`时，它将创建相应 DOM 节点， 其value` property 被初始化为 “Bob”。 当用户在输入框中输入 “Sally” 时，DOM 元素的value property 变成了 “Sally”。 但是这个 HTML value attribute 保持不变。如果我们读取 input 元素的 attribute，就会发现确实没变： input.getAttribute(&#39;value&#39;) // 返回 &quot;Bob&quot;。 HTML attribute value指定了初始值；DOM value property 是当前值。 模板绑定是通过 property 和事件来工作的，而不是 attribute。 在 Angular 的世界中，attribute 唯一的作用是用来初始化元素和指令的状态。 当进行数据绑定时，只是在与元素和指令的 property 和事件打交道，而 attribute 就完全靠边站了。 属性绑定当要把视图元素的属性 (property) 设置为模板表达式时，就要写模板的属性 (property) 绑定。 属性绑定是单向数据绑定，因为值的流动是单向的，从组件的数据属性流动到目标元素的属性。 不能使用属性绑定来从目标元素拉取值，也不能绑定到目标元素的属性来读取它。只能设置它。 也不能使用属性绑定来调用目标元素上的方法。 如果这个元素触发了事件，可以通过事件绑定来监听它们。 如果必须读取目标元素上的属性或调用它的某个方法，得用ViewChild 和 ContentChild。 包裹在方括号中的元素属性名标记着目标属性，比如： 1&lt;img [src]="heroImageUrl"&gt; 严格来说，Angular 正在匹配指令的输入属性的名字。 这个名字是指令的inputs数组中所列的名字，或者是带有@Input()装饰器的属性。 这些输入属性被映射为指令自己的属性。 表达式可能会调用具有副作用的属性或方法。但 Angular 没法知道这一点，也没法阻止我们。 一般建议是，只绑定数据属性和那些只返回值而不做其它事情的方法。 模板表达式应该返回目标属性所需类型的值。 当下列条件满足时，应该省略括号： 目标属性接受字符串值。 字符串是个固定值，可以直接合并到模块中。 这个初始值永不改变。 下列这几对绑定做的事情完全相同： 12345&lt;p&gt;&lt;img src="&#123; &#123;heroImageUrl&#125; &#125;"&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;img [src]="heroImageUrl"&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;span&gt;"&#123; &#123;title&#125; &#125;" is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="title"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt; 实际上，在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定。 没有技术上的理由能决定哪种形式更好。 我们倾向于可读性，所以倾向于插值表达式。 建议建立代码风格规则，选择一种形式， 这样，既遵循了规则，又能让手头的任务做起来更自然。 不管是插值表达式还是属性绑定，都不会允许带有 script 标签的 HTML 泄漏到浏览器中。 12345evilTitle = 'Template &lt;script&gt;alert("evil never sleeps")&lt;/script&gt;Syntax';&lt;p&gt;&lt;span&gt;"&#123; &#123;evilTitle&#125; &#125;" is the &lt;i&gt;interpolated&lt;/i&gt; evil title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="evilTitle"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; evil title.&lt;/p&gt; &lt;!--属性绑定把script中的内容忽略--&gt; 插值表达式处理 script 标签与属性绑定有所不同，但是二者都只渲染没有危害的内容。 attribute、class 和 style 绑定可以通过attribute 绑定来直接设置 attribute 的值。 当元素没有属性可绑的时候，就必须使用 attribute 绑定。 ARIA， SVG 和 table 中的 colspan/rowspan 等 attribute， 它们是纯粹的 attribute，没有对应的property可供绑定。（table合并单元格colspan和rowspan）。 attribute 绑定的语法与property绑定类似。 但方括号中的部分不是元素的属性名，而是由attr前缀，一个点 (.) 和 attribute 的名字组成。 可以通过值为字符串的表达式来设置 attribute 的值。 12345678910&lt;table border=1&gt; &lt;!-- expression calculates colspan=2 --&gt; &lt;tr&gt;&lt;td [attr.colspan]="1 + 1"&gt;One-Two&lt;/td&gt;&lt;/tr&gt; &lt;!-- ERROR: There is no `colspan` property to set! &lt;tr&gt;&lt;td colspan="&#123; &#123;1 + 1&#125; &#125;"&gt;Three-Four&lt;/td&gt;&lt;/tr&gt; --&gt; &lt;tr&gt;&lt;td&gt;Five&lt;/td&gt;&lt;td&gt;Six&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; CSS 类绑定绑定的语法与属性绑定类似。 但方括号中的部分不是元素的属性名，而是由class前缀，一个点 (.)和 CSS 类的名字组成， 其中后两部分是可选的。形如：[class.class-name]。 通过css类添加和移除类名的方法： 1 变量赋值 123&lt;!-- reset/override all class names with a binding --&gt;&lt;div class="bad curly special" [class]="badCurly"&gt;Bad curly&lt;/div&gt; 2 绑定到特定的类名 123456&lt;!-- toggle the "special" class on/off with a property --&gt;&lt;div [class.special]="isSpecial"&gt;The class binding is special&lt;/div&gt;&lt;!-- binding to `class.special` trumps the class attribute --&gt;&lt;div class="special" [class.special]="!isSpecial"&gt;This one is not so special&lt;/div&gt; 最好使用ngClass来管理多个类名。 通过样式绑定，可以设置内联样式。 样式绑定的语法与属性绑定类似。 但方括号中的部分不是元素的属性名，而由style前缀，一个点 (.)和 CSS 样式的属性名组成。 形如：[style.style-property]。 12&lt;button [style.color] = "isSpecial ? 'red': 'green'"&gt;Red&lt;/button&gt;&lt;button [style.background-color]="canSave ? 'cyan': 'grey'" &gt;Save&lt;/button&gt; 有些样式绑定中的样式带有单位。 12&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt; 最好用NgStyle来设置多个内联样式。 事件绑定事件绑定语法由等号左侧带圆括号的目标事件和右侧引号中的模板语句组成。 在事件绑定中，Angular 会为目标事件设置事件处理器。当事件发生时，这个处理器会执行模板语句。 典型的模板语句通常涉及到响应事件执行动作的接收器，例如从 HTML 控件中取得值，并存入模型。 绑定会通过名叫$event的事件对象传递关于此事件的信息（包括数据值）。 事件对象的形态取决于目标事件。如果目标事件是原生 DOM 元素事件， $event就是 DOM事件对象，它有像target和target.value这样的属性。 123&lt;input [value]="currentHero.firstName" (input)="currentHero.firstName=$event.target.value" &gt;&lt;!--通过路径$event.target.value来获取更改后的值。--&gt; 通常，指令使用 Angular EventEmitter来触发自定义事件。 指令创建一个EventEmitter实例，并且把它作为属性暴露出来。 指令调用EventEmitter.emit(payload)来触发事件，可以传入任何东西作为消息载荷。 父指令通过绑定到这个属性来监听事件，并通过$event对象来访问载荷。 12345678template: `&lt;div&gt; &lt;img src="&#123; &#123;heroImageUrl&#125; &#125;"&gt; &lt;span [style.text-decoration]="lineThrough"&gt; &#123; &#123;prefix&#125; &#125; &#123; &#123;hero?.fullName&#125; &#125; &lt;/span&gt; &lt;button (click)="delete()"&gt;Delete&lt;/button&gt;&lt;/div&gt;` 1234567// This component make a request but it can't actually delete a hero.deleteRequest = new EventEmitter&lt;Hero&gt;();delete() &#123; this.deleteRequest.emit(this.hero);&#125;//当用户点击删除时，组件会调用delete()方法，让EventEmitter发出一个Hero对象。 123&lt;!--假设宿主的父组件绑定了HeroDetailComponent的deleteRequest事件。--&gt;&lt;hero-detail (deleteRequest)="deleteHero($event)" [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;!--当deleteRequest事件触发时，Angular 调用父组件的deleteHero方法， 在$event变量中传入要删除的英雄（来自HeroDetail）。--&gt; 双向数据绑定Angular 提供一种特殊的双向数据绑定语法：[(x)]。 [(x)]语法结合了属性绑定的方括号[x]和事件绑定的圆括号(x)。双向绑定语法实际上是属性绑定和事件绑定的语法糖。 要理解双向绑定，先要理解元素设置的属性x和对应的事件xChange： 1234567891011121314151617181920import &#123; Component, EventEmitter, Input, Output &#125; from '@angular/core';@Component(&#123; selector: 'my-sizer', template: ` &lt;div&gt; &lt;button (click)="dec()" title="smaller"&gt;-&lt;/button&gt; &lt;button (click)="inc()" title="bigger"&gt;+&lt;/button&gt; &lt;label [style.font-size.px]="size"&gt;FontSize: &#123; &#123;size&#125; &#125;px&lt;/label&gt; &lt;/div&gt;`//属性绑定初始值&#125;)export class SizerComponent &#123; @Input() size: number | string; @Output() sizeChange = new EventEmitter&lt;number&gt;(); dec() &#123; this.resize(-1); &#125; inc() &#123; this.resize(+1); &#125; resize(delta: number) &#123; this.size = Math.min(40, Math.max(8, +this.size + delta)); this.sizeChange.emit(this.size); &#125;&#125; 下面是双向绑定： 12&lt;my-sizer [(size)]="fontSizePx"&gt;&lt;/my-sizer&gt;&lt;div [style.font-size.px]="fontSizePx"&gt;Resizable Text&lt;/div&gt; 可以分解为： 1&lt;my-sizer [size]="fontSizePx" (sizeChange)="fontSizePx=$event"&gt;&lt;/my-sizer&gt; $event变量包含了SizerComponent.sizeChange事件的荷载。 当用户点击按钮时，Angular 将$event赋值给AppComponent.fontSizePx。 原生 &lt;input&gt;和&lt;select&gt;这样的 HTML 元素不遵循x值和xChange事件的模式。Angular 以 NgModel指令为桥梁，允许在表单元素上使用双向数据绑定。 使用 NgModel 进行双向数据绑定在使用ngModel做双向数据绑定之前，得先导入FormsModule， 把它加入 Angular 模块的imports列表。 NgModel指令进行双向数据绑定让用户做出变更时更新显示变得更加容易。 12345678910111213141516171819&lt;input [value]="currentHero.firstName" (input)="currentHero.firstName=$event.target.value" &gt;&lt;!--升级--&gt;&lt;!--ngModel指令通过它自己的ngModel输入属性和ngModelChange输出属性隐藏了直接绑定元素的原生属性。ngModel数据属性设置元素的 value 属性，ngModelChange事件属性监听元素 value 的变化。除非写一个合适的值访问器，否则不能把[(ngModel)]用在自定义组件上。--&gt;&lt;input [ngModel]="currentHero.firstName" (ngModelChange)="currentHero.firstName=$event"&gt;&lt;input [ngModel]="currentHero.firstName" (ngModelChange)="setUpperCaseFirstName($event)"&gt;&lt;!--[(ngModel)]展开形式实现让输入值变成大写形式--&gt;&lt;!--升级--&gt;&lt;!--[(ngModel)]语法只能设置一个数据绑定属性。 如果需要做更多或不同的事情，就得自己用它的展开形式（上面代码）。--&gt;&lt;input [(ngModel)]="currentHero.firstName"&gt; 内置指令NgClass通过绑定到NgClass，可以同时添加或移除多个类。CSS 类绑定 是添加或删除单个类的最佳途径。当想要同时添加或移除多个 CSS 类时，NgClass指令可能是更好的选择。 12345678910&lt;div [ngClass]="setClasses()"&gt;This div is saveable and special&lt;/div&gt;setClasses() &#123; let classes = &#123; saveable: this.canSave, // true modified: !this.isUnchanged, // false special: this.isSpecial, // true &#125;; return classes;&#125; NgStyleNgStyle绑定可以同时设置多个内联样式。样式绑定是设置单一样式值的简单方式。如果要同时设置多个内联样式，NgStyle指令可能是更好的选择。 12345678910111213&lt;div [ngStyle]="setStyles()"&gt; This div is italic, normal weight, and extra large (24px).&lt;/div&gt;setStyles() &#123; let styles = &#123; // CSS property names 'font-style': this.canSave ? 'italic' : 'normal', // italic 'font-weight': !this.isUnchanged ? 'bold' : 'normal', // normal 'font-size': this.isSpecial ? '24px' : '8px', // 24px &#125;; return styles;&#125; NgIf通过绑定NgIf指令到真值表达式，可以把元素子树（元素及其子元素）添加到 DOM 上。绑定到假值表达式将从 DOM 中移除元素子树。 可以通过类绑定或样式绑定来显示和隐藏元素子树（元素及其子元素）。 123456789&lt;!-- isSpecial is true --&gt;&lt;div [class.hidden]="!isSpecial"&gt;Show with class&lt;/div&gt;&lt;div [class.hidden]="isSpecial"&gt;Hide with class&lt;/div&gt;&lt;!-- HeroDetail is in the DOM but hidden --&gt;&lt;hero-detail [class.hidden]="isSpecial"&gt;&lt;/hero-detail&gt;&lt;div [style.display]="isSpecial ? 'block' : 'none'"&gt;Show with style&lt;/div&gt;&lt;div [style.display]="isSpecial ? 'none' : 'block'"&gt;Hide with style&lt;/div&gt; 当NgIf为false时，Angular 从 DOM 中物理地移除了这个元素子树。 它销毁了子树中的组件及其状态，也潜在释放了可观的资源，最终让用户体验到更好的性能。 NgSwitch当需要从一组可能的元素树中根据条件显示一个时，我们就把它绑定到NgSwitch。 Angular 将只把选中的元素树放进 DOM 中。 1234567&lt;span [ngSwitch]="toeChoice"&gt; &lt;span *ngSwitchCase="'Eenie'"&gt;Eenie&lt;/span&gt; &lt;span *ngSwitchCase="'Meanie'"&gt;Meanie&lt;/span&gt; &lt;span *ngSwitchCase="'Miney'"&gt;Miney&lt;/span&gt; &lt;span *ngSwitchCase="'Moe'"&gt;Moe&lt;/span&gt; &lt;span *ngSwitchDefault&gt;other&lt;/span&gt;&lt;/span&gt; 把作为父指令的NgSwitch绑定到能返回开关值的表达式。 任何时候，这些 span 中最多只有一个会出现在 DOM 中。 这里有三个相互合作的指令： ngSwitch：绑定到返回开关值的表达式 ngSwitchCase：绑定到返回匹配值的表达式 ngSwitchDefault：用于标记出默认元素的 attribute 不要在ngSwitch的前面加星号 (*)，而应该用属性绑定。 要把星号 (*) 放在ngSwitchCase和ngSwitchDefault的前面。 NgForNgFor是一个重复器指令 —— 自定义数据显示的一种方式。 赋值给*ngFor的字符串不是模板表达式。 它是一个微语法 —— 由 Angular 自己解释的小型语言。 1&lt;hero-detail *ngFor="let hero of heroes" [hero]="hero"&gt;&lt;/hero-detail&gt; hero前面的let关键字创建了名叫hero的模板输入变量。 ngFor指令支持可选的index，它在迭代过程中会从 0 增长到“数组的长度”。 可以通过模板输入变量来捕获这个 index，并在模板中使用。 1&lt;div *ngFor="let hero of heroes; let i=index"&gt;&#123; &#123;i + 1&#125; &#125; - &#123; &#123;hero.fullName&#125; &#125;&lt;/div&gt; 追踪函数告诉 Angular：我们知道两个具有相同hero.id的对象其实是同一个英雄。 下面就是这样一个函数： 123trackByHeroes(index: number, hero: Hero) &#123; return hero.id; &#125;&lt;div *ngFor="let hero of heroes; trackBy:trackByHeroes"&gt;(&#123; &#123;hero.id&#125; &#125;) &#123; &#123;hero.fullName&#125; &#125;&lt;/div&gt; 追踪函数不会阻止所有 DOM 更改。 如果同一个英雄的属性变化了，Angular 就可能不得不更新DOM元素。 但是如果这个属性没有变化 —— 而且大多数时候它们不会变化 —— Angular 就能留下这些 DOM 元素。列表界面就会更加平滑，提供更好的响应。 * 与 &lt;template&gt;*是一种语法糖，它让那些需要借助模板来修改 HTML 布局的指令更易于读写。 NgFor、NgIf和NgSwitch都会添加或移除元素子树，这些元素子树被包裹在`标签中。 没有看到标签，那是因为这种*`前缀语法让我们忽略了这个标签， 而把注意力直接聚焦在所要包含、排除或重复的那些 HTML 元素上。 展开*ngIf12345678910&lt;hero-detail *ngIf="currentHero" [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;!--展开第一步--&gt;&lt;hero-detail template="ngIf:currentHero" [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;!--展开第二步--&gt;&lt;template [ngIf]="currentHero"&gt; &lt;hero-detail [hero]="currentHero"&gt;&lt;/hero-detail&gt;&lt;/template&gt;&lt;!--不要误写为ngIf="currentHero"！ 这种语法会把一个字符串"currentHero"赋值给ngIf。 在 JavaScript 中，非空的字符串是真值，所以ngIf总会是true，而 Angular 将永远显示hero-detail, 即使根本没有currentHero--&gt; 展开*ngSwitch1234567891011121314151617&lt;span [ngSwitch]="toeChoice"&gt; &lt;!-- with *NgSwitch --&gt; &lt;span *ngSwitchCase="'Eenie'"&gt;Eenie&lt;/span&gt; &lt;span *ngSwitchCase="'Meanie'"&gt;Meanie&lt;/span&gt; &lt;span *ngSwitchCase="'Miney'"&gt;Miney&lt;/span&gt; &lt;span *ngSwitchCase="'Moe'"&gt;Moe&lt;/span&gt; &lt;span *ngSwitchDefault&gt;other&lt;/span&gt; &lt;!-- with &lt;template&gt; --&gt; &lt;template [ngSwitchCase]="'Eenie'"&gt;&lt;span&gt;Eenie&lt;/span&gt;&lt;/template&gt; &lt;template [ngSwitchCase]="'Meanie'"&gt;&lt;span&gt;Meanie&lt;/span&gt;&lt;/template&gt; &lt;template [ngSwitchCase]="'Miney'"&gt;&lt;span&gt;Miney&lt;/span&gt;&lt;/template&gt; &lt;template [ngSwitchCase]="'Moe'"&gt;&lt;span&gt;Moe&lt;/span&gt;&lt;/template&gt; &lt;template ngSwitchDefault&gt;&lt;span&gt;other&lt;/span&gt;&lt;/template&gt;&lt;/span&gt; *ngSwitchWhen和*ngSwitchDefault用和*ngIf完全相同的方式展开。 ngSwitch本身没有定义内容，它的工作是控制一组模板，所以不能用星号 (*) 前缀。 展开*ngFor123456789&lt;hero-detail *ngFor="let hero of heroes; trackBy:trackByHeroes" [hero]="hero"&gt;&lt;/hero-detail&gt;&lt;!--展开第一步--&gt;&lt;hero-detail template="ngFor let hero of heroes; trackBy:trackByHeroes" [hero]="hero"&gt;&lt;/hero-detail&gt;&lt;!--展开第二步--&gt;&lt;template ngFor let-hero [ngForOf]="heroes" [ngForTrackBy]="trackByHeroes"&gt; &lt;hero-detail [hero]="hero"&gt;&lt;/hero-detail&gt;&lt;/template&gt; 模板引用变量模板引用变量是模板中对 DOM 元素或指令的引用。 它能在原生 DOM 元素中使用，也能用于 Angular 组件。 1234567&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;&lt;input #phone placeholder="phone number"&gt;&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt;&lt;!-- fax refers to the input element; pass its `value` to an event handler --&gt;&lt;input ref-fax placeholder="fax number"&gt;&lt;button (click)="callFax(fax.value)"&gt;Fax&lt;/button&gt; 1234567&lt;form (ngSubmit)="onSubmit(theForm)" #theForm="ngForm"&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input class="form-control" name="name" required [(ngModel)]="currentHero.firstName"&gt; &lt;/div&gt; &lt;button type="submit" [disabled]="!theForm.form.valid"&gt;Submit&lt;/button&gt;&lt;/form&gt; theForm变量的值是个ngForm，对 Angular 内置指令NgForm的引用。 它包装了原生的HTMLFormElement并赋予它更多超能力，比如跟踪用户输入的有效性。 输入与输出属性绑定到的目标位于绑定声明中的左侧。 这些指令的属性必须被声明成输入或输出。 绑定的目标是在=左侧的部分， 源则是在=右侧的部分。 绑定的目标是绑定符：[]、()或[()]中的属性或事件名， 源则是引号 (&quot; &quot;) 中的部分或插值符号 ({ {} }) 中的部分。 源指令中的每个成员都会自动在绑定中可用。 不需要特别做什么，就能在模板表达式或语句中访问指令的成员。 访问目标指令中的成员则受到限制。 只能绑定到那些显式标记为输入或输出的属性。 123&lt;img [src]="iconUrl"/&gt;&lt;button (click)="onSave()"&gt;Save&lt;/button&gt;&lt;!--iconUrl和onSave是组件的成员，它们在=右侧引号语法中被引用了。它们既不是组件的输入也不是输出。它们是绑定的数据源。--&gt; 123&lt;hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)"&gt;&lt;/hero-detail&gt;&lt;!--HeroDetailComponent.hero和HeroDetailComponent.deleteRequest都在绑定声明的左侧。 HeroDetailComponent.hero在方括号中，它是属性绑定的目标。 HeroDetailComponent.deleteRequest在圆括号中，它是事件绑定的目标。--&gt; 目标属性必须被显式的标记为输入或输出。 12@Input() hero: Hero;@Output() deleteRequest = new EventEmitter&lt;Hero&gt;(); 另外，还可以在指令元数据的inputs或outputs数组中标记出这些成员。比如这个例子： 1234@Component(&#123; inputs: ['hero'], outputs: ['deleteRequest'],&#125;) 输入属性通常接收数据值。 输出属性暴露事件生产者，如EventEmitter对象。 输入和输出这两个词是从目标指令的角度来说的。 从HeroDetailComponent角度来看，HeroDetailComponent.hero是个输入属性， 因为数据流从模板绑定表达式流入那个属性。 从HeroDetailComponent角度来看，HeroDetailComponent.deleteRequest是个输出属性， 因为事件从那个属性流出，流向模板绑定语句中的处理器。 在指令类中，直接用指令名作为自己的属性名通常都不是好的选择。把别名传进@Input/@Output装饰器，就可以为属性指定别名，就像这样： 1@Output('myClick') clicks = new EventEmitter&lt;string&gt;(); 或者： 123@Directive(&#123; outputs: ['clicks:myClick'] // propertyName:alias&#125;) 模板表达式操作符管道操作符 ( | )管道是一个简单的函数，它接受一个输入值，并返回转换结果。 它们很容易用于模板表达式中，只要使用管道操作符 (|) 就行了。 1234567891011121314151617&lt;div&gt;Title through uppercase pipe: &#123; &#123;title | uppercase&#125; &#125;&lt;/div&gt;&lt;!-- Pipe chaining: convert title to uppercase, then to lowercase --&gt;&lt;div&gt; Title through a pipe chain: &#123; &#123;title | uppercase | lowercase&#125; &#125;&lt;/div&gt;&lt;!--使用参数, pipe with configuration argument =&gt; "February 25, 1970" --&gt;&lt;div&gt;Birthdate: &#123; &#123;currentHero?.birthdate | date:'longDate'&#125; &#125;&lt;/div&gt;&lt;!--json管道对调试绑定特别有用,它生成的输出是类似于这样的：&#123; "firstName": "Hercules", "lastName": "Son of Zeus", "birthdate": "1970-02-25T08:00:00.000Z", "url": "http://www.imdb.com/title/tt0065832/", "rate": 325, "id": 1 &#125;--&gt;&lt;div&gt;&#123; &#123;currentHero | json&#125; &#125;&lt;/div&gt; 安全导航操作符 ( ?. ) 和空属性路径Angular 的安全导航操作符 (?.) 是一种流畅而便利的方式，用来保护出现在属性路径中 null 和 undefined 值。 下例中，当currentHero为空时，保护视图渲染器，让它免于失败。 1The current hero's name is &#123; &#123;currentHero?.firstName&#125; &#125; 表达式会在它遇到第一个空值的时候跳出。 显示是空的，但应用正常工作，而没有发生错误。 数据绑定中属性为空，会显示不出或者抛出空引用错误： 1TypeError: Cannot read property 'firstName' of null in [null].]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts改造之动态显示]]></title>
      <url>%2F2017%2F01%2F23%2FEcharts%E6%94%B9%E9%80%A0%E4%B9%8B%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[官网动态数据实例中展示了数据动态变化的案例，这个如何移植到Angular2中去呢？首先要读懂官网的这个例子，不然会有坑。 官网案例分析首先，数据处理和图表生成最好放在一起，根据官网的例子，在设置定时器之前，对应的配置项中已经设定好10个数据，而定时器，只是向对应的配置项中不断删除第一个数据，然后push新的数据。官网原话如下： 设置图表实例的配置项以及数据，万能接口，所有参数和数据的修改都可以通过setOption完成，ECharts 会合并新的参数和数据，然后刷新图表。如果开启动画的话，ECharts 找到两组数据之间的差异然后通过合适的动画去表现数据的变化。 其次，myChart这个变量要设置为全局变量，不然每次echarts会重新复制图表，而不是像官网例子一样，呈现出向左推送的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html style="height: 100%"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body style="height: 100%; margin: 0"&gt; &lt;div id="container" style="height: 100%"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts-all-3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ZUONbpqGBsYGXNIYHicvbAbM"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;var dom = document.getElementById("container");var myChart = echarts.init(dom);var app = &#123;&#125;;option = null;option = &#123; title: &#123; text: '动态数据', subtext: '纯属虚构' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data:['最新成交价', '预购队列'] &#125;, toolbox: &#123; show: true, feature: &#123; dataView: &#123;readOnly: false&#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, dataZoom: &#123; show: false, start: 0, end: 100 &#125;, xAxis: [ &#123; type: 'category', boundaryGap: true, data: (function ()&#123; var now = new Date(); var res = []; //预先设置好初始值 var len = 10; //定义x轴数据个数 while (len--) &#123; res.unshift(now.toLocaleTimeString().replace(/^\D*/,'')); now = new Date(now - 2000); &#125; return res; &#125;)() &#125;, &#123; type: 'category', boundaryGap: true, data: (function ()&#123; var res = []; var len = 10; while (len--) &#123; res.push(len + 1); &#125; return res; &#125;)() &#125; ], yAxis: [ &#123; type: 'value', scale: true, name: '价格', max: 30, min: 0, boundaryGap: [0.2, 0.2] &#125;, &#123; type: 'value', scale: true, name: '预购量', max: 1200, min: 0, boundaryGap: [0.2, 0.2] &#125; ], series: [ &#123; name:'预购队列', type:'bar', xAxisIndex: 1, yAxisIndex: 1, data:(function ()&#123; var res = []; var len = 10; while (len--) &#123; res.push(Math.round(Math.random() * 1000)); &#125; return res; &#125;)() &#125;, &#123; name:'最新成交价', type:'line', data:(function ()&#123; var res = []; var len = 0; while (len &lt; 10) &#123; res.push((Math.random()*10 + 5).toFixed(1) - 0); len++; &#125; return res; &#125;)() &#125; ]&#125;;app.count = 11;setInterval(function ()&#123; axisData = (new Date()).toLocaleTimeString().replace(/^\D*/,''); var data0 = option.series[0].data; var data1 = option.series[1].data; data0.shift(); //数组去头 data0.push(Math.round(Math.random() * 1000));//推送新的数据 data1.shift(); data1.push((Math.random() * 10 + 5).toFixed(1) - 0); option.xAxis[0].data.shift(); option.xAxis[0].data.push(axisData); option.xAxis[1].data.shift(); option.xAxis[1].data.push(app.count++); myChart.setOption(option);&#125;, 2100);;if (option &amp;&amp; typeof option === "object") &#123; myChart.setOption(option, true);&#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 移植到ANgular2首先创建一个dynamic-line.component.ts文件，@Component装饰器和import按照自己需求配置好。在class中先定义一些全局变量，并配置好echarts的option： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950url:any;id:string;userdata:any;dom:any;myoption:any;myChart:any;option:any = &#123; tooltip: &#123; show: true, trigger: 'axis' &#125;, toolbox: &#123; show: true, feature: &#123; dataZoom: &#123;show: true&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125; &#125; &#125;, legend: &#123; selectedMode: true, selected: &#123;&#125;, right: '0px', top: '80px', orient: 'vertical', textStyle: &#123; fontSize: 12, &#125;, show: true, data: [] &#125;, xAxis: &#123; data: [], axisLabel: &#123; interval: 0, &#125; &#125;, grid: &#123; left: '9%', x2: 150, &#125;, yAxis: [ &#123; type: 'value', name: '', &#125; ], series: []&#125;; 然后从外部传入url，以供echarts读取数据和刷新： 1@Input() url:any; 设置从后端获取数据的函数（获取数据后，因为后端数据有点乱，为了方便，我把数据重新处理了一下，定义了一个setMyoption()的函数，把处理后的数据，用json对象的形式存放在myoption这个变量中）： 123456789101112 getUrlData() &#123; let that = this; //从接口获取数据(省略) that.userdata = ...... &#125; setMyoption() &#123; let that = this; that.myoption = &#123; "data": [] &#125;;//处理数据后，存放在data中(省略) &#125; 根据数据配置legend，因为legend不需要刷新，所以独立成单独的函数： 1234567setLegend() &#123; let legend = []; //把数据处理后push到legend数组中（省略）； that.option.legend.data = legend; &#125; 设置配置option中x轴数据和series数据： 123setDataToOption() &#123; //把数据处理后push到xaxis的data数组和series数组中（省略）&#125; 设置生成echarts的函数： 123456createCharts() &#123; let that = this; that.dom = document.getElementById(that.id); that.myChart = echarts.init(that.dom, 'macarons'); that.myChart.setOption(that.option); &#125; 接下来在ngAfterViewInit中调用相关函数，让页面加载完后显示echarts： 123456789101112131415161718192021222324252627ngAfterViewInit() &#123; let that = this; that.myUrl = that.url; //把导入的url赋值给myUrl that.getUrlData(); that.setMyoption(); //清空原始数组 that.option.legend.data = []; that.option.series.data = []; that.option.xAxis.data = []; that.option.series = []; //配置Legend that.setLegend(); //配置option that.setDataToOption(); //调用echarts画图 that.createCharts(); //走到这步就已经把echarts初始化好了，下面要对特定的数据进行动态推送 //动态推送 setInterval(function () &#123; that.setDynamicData(); &#125;, 6000) &#125; 下面就设置动态推送数据的函数： 123456789101112131415161718setDynamicData() &#123; let that = this; let xaxisData = that.option.xAxis.data; that.getUrlData(); //读取的数据中不包含之前的数据 that.setMyoption(); for (let i = 0; i &lt; that.userdata.length; i++) &#123; //多个数据一个个推送 let time = that.myoption.data[0].systime[i]; xaxisData.shift(); xaxisData.push(time); for (let n = 0; n &lt; that.option.series.length; n++) &#123; let pushData = that.myoption.data[n].value[i]; that.option.series[n].data.shift(); that.option.series[n].data.push(pushData); &#125; that.myChart.setOption(that.option); //mychart必须是全局变量 &#125; &#125; 最后的效果就是这样：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown--你值得拥有]]></title>
      <url>%2F2017%2F01%2F18%2FMarkdown-%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%2F</url>
      <content type="text"><![CDATA[什么是Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 官方文档创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown工具一般写文章大家会用word，那写makdown用什么呢？ mac平台收费的有： Ulysses Ⅲ， Mou ，Bear 免费的有：Typora Windows平台免费的有：Typora，MarkdownPad，MarkPad 这里推荐使用Typora，通吃Windows、mac和Linux三大平台。Typora 在 Markdown 的基础上，保持了应有的简洁和优雅，又一定程度地改良了 Markdown 本身较为不合理和烦琐的地方，适度地引入一些高级的编辑功能，使得一切都觉得如此顺手。 Markdown语法标题在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3.符号要和文字之间加上一个字符的空格。 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可显示引用格式。 图片与连接插入链接与插入图片的语法很像，区别在一个 !号 插入图片的地址需要图床，这里推荐 u图床 （mac）和MPic （Windows）的服务，生成URL地址即可。 在Typora中支持把图片拖拽进去，自动生成Markdown格式。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 代码框用两个 ` 把中间的代码包裹起来。 代码块输入三个```，选择语言，然后输入代码，你会发现代码块中的代码自动高亮。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可。 表格Markdown 写表格比较累人。 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 生成的表格如下： 但是Typora中提供了比较方便的写表格的方法。通过菜单栏或快捷键 Command+T 可以插入表格，Typora 会弹出一个表格插入设置，你可以预先设定好行数和列数，确定后表格就出现了。每一列上面还有三个按钮，可以控制本列的文字向左、居中、向右对齐。甚至，你可以点击左上角改变表格的行数和列数。 删除线用~~包围住文字： Markdown还支持直接写HTML，例如#标题等价于&lt;h1&gt;标题&lt;/h1&gt;。 格式转化在Typora的file—&gt;Export中可以把md格式文件转化成pdf、word、html等格式文件。转word需要安装插件： Download Page。 md格式： 转化成word格式：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm那些事儿]]></title>
      <url>%2F2017%2F01%2F16%2FWebStorm%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
      <content type="text"><![CDATA[关于webstorm WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 快捷键代码注释注释一行代码：ctrl+/(windows) ​ command+/(mac) 注释大段代码： 1 ctrl+/(windows) command+/(mac) ​ 2 ctrl+shif+/(windows) shift+command+/(mac) 格式化代码格式化代码：ctrl+alt+L(windows) ​ option+command+L(mac) shift+F6shift+F6（windows） shift+fn+F6（mac） 1 替换局部变量 ​ 2 重构函数名 快速跳转​ 快速跳转：ctrl+单击(windows) ​ command+单击（mac） 删除代码删除代码:ctrl+Y(windows) ​ Command+delete(mac) 多行编辑多行编辑：1 鼠标选择时按住alt(windows) ​ 鼠标按住时按住option（mac） ​ 2 长按alt+J，自动选择相同的元素（windows） ​ 选中元素后，按ctrl+g（mac） zencoding按tab键自动展开为完整html标签 后代：&gt; 兄弟：+ 上级：^ 分组：() 乘法：* 自增符号：$想显示几位数就使用几个$,$@-倒序，$@3从3开始计数 ​ ID和类属性:#和. 自定义属性:[] 文本:{} zencoding更多资料参见：zen coding 教程zen coding使用方法，大量实例 自定义模板在setting&gt;Editor&gt;Live Templates中可以自定义模板，方便自己调用。 使用效果： 代码对比不同文件代码对比先把需要对比的代码复制到剪切板，然后右击有个compare with Clipboard，就会有个对话框弹出，里面标记了两个代码不同的地方。 相同文件历史代码对比右击有个Local History，选择Show History]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现（二）]]></title>
      <url>%2F2017%2F01%2F11%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[之前用三目表达式和ng-class实现了按钮切换效果，似乎达到了我的预期，但是我觉得还有改进空间，网上找了一些资料，大概还有以下几种实现方式： 路由12&lt;button class="btn1" routerLink="component1" routerLinkActive="active" type="submit"&gt;btn1&lt;/button&gt;&lt;button class="btn2" routerLink="component2" routerLinkActive="active" type="submit"&gt;btn2&lt;/button&gt; 123.active &#123; background-color: white;&#125; 将button切换的页面写成一个component，通过routerLink链接到对应的component并显示出来，routerLinkActive来控制路由链接激活后button的样式应用的class。 但是这个有局限性，适合button按下去后，整个页面会有大幅变化的应用场景，那么还有其他方法吗？答案是肯定的。 [class]与(click)还是通过ngclass和ngclick配合，不过方法和之前写的略有不同。 字符串数组形式12&lt;button [class]="&#123;true:'btn1',false:'btn2'&#125;[isChange]" (click)="isChange=true"&gt;btn1&lt;/button&gt;&lt;button [class]="&#123;false:'btn1',true:'btn2'&#125;[isChange]" (click)="isChange=false" &gt;btn2&lt;/button&gt; 123456789101112131415161718.btn1&#123; width: 120px; height: 43px; border: 1px solid #EEEEEE; background: white; border-bottom: none; text-align: center;&#125;.btn2&#123; border: 1px solid #EEEEEE; border-top: 2px solid #238FF9; width: 120px; height: 42px; background: white; border-bottom: none; text-align: center;&#125; 字符串数组形式是针对class简单变化，具有排斥性的变化，true是什么class，false是什么class。若要设置初识状态的class，可以在component中的构造函数中预先赋值。 对象key/value处理1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 这种方法可以对多个对象赋不同的class。或者可以实现多个button互斥性变化： 1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn1','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn1','four':'btn2'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn2','four':'btn1'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 参考资料： angularJs的ng-class切换class]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts改造之数据分离]]></title>
      <url>%2F2017%2F01%2F08%2FEcharts%E6%94%B9%E9%80%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
      <content type="text"><![CDATA[Echarts官网中的数据都是写死的，如何让Echarts根据后台传过来的数据进行变化呢？下面介绍一下Angular2中嵌入Echarts，并实现数据分离。 先创建一个line.component.ts文件，component装饰器中这样写： 123456@Component(&#123; moduleId: module.id, selector: 'line', templateUrl: 'line.html', styleUrls: ['line.component.css'],&#125;) class中实现AfterViewInit接口，用于初始化组件视图后调用： 12345export class LineComponent implements AfterViewInit &#123; ngAfterViewInit()&#123; &#125;&#125; 在class中首先定义一些变量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546lineData:Line; id:string; option:any = &#123; tooltip: &#123; show: true, trigger: 'axis' &#125;, toolbox: &#123; show: true, feature: &#123; magicType: &#123;show: true, type: ['bar']&#125;, dataZoom: &#123;show: true&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125; &#125; &#125;, legend: &#123; selectedMode: true, selected: &#123;&#125;, right: '0px', top: '80px', orient: 'vertical', textStyle: &#123; fontSize: 12, &#125;, show: true, data: [] &#125;, xAxis: &#123; data: [], axisLabel: &#123; interval: 0, &#125; &#125;, grid: &#123; left: '9%', x2: 150, &#125;, yAxis: [ &#123; type: 'value', name: '', &#125; ], series: [] &#125;; 在需要调用line.component.ts的父组件html中添加下面代码，把父组件中的myOption中的数据传递给data属性： 1&lt;line [data]='myOption'&gt;&lt;/line&gt; 在父组件的ts文件中，从后端读取数据，并把数据写入myOption（这里其实对原始数据进行了一次处理，让传给line.component.ts的数据更加容易处理）： 12345678910111213141516171819myOption:any; constructor()&#123; this.myOption = &#123; "data": [] &#125;;&#125;setMyOption()&#123; let that = this; let obj = &#123; "name": fieldkey, "value": [], "systime": [] &#125;; that.myOption.data = []; //先往obj中写入数据，再往data数组中写入对象&#125;getUrlData()&#123; //从后端读取数据&#125; 再回到line.component.ts中，引入myOption中的数据： 1@Input() data:any; 实现AfterViewInit接口： 12345678910111213141516ngAfterViewInit() &#123; let that = this; that.lineData = that.data; //data赋值给linedata //清空原始数组 that.option.legend.data = []; that.option.series.data = []; that.option.xAxis.data = []; that.option.series = []; //配置option that.setDataToOption(); //调用echarts画图 that.createCharts(); &#125; 往echarts中写入从后端读取的数据： 1234567891011121314151617181920212223242526272829303132333435setDataToOption() &#123; let that = this; let dataLength = this.lineData.data.length; let xAxisData = that.option.xAxis.data; let legend = that.option.legend; for (let n = 0; n &lt; dataLength; n++) &#123; let item = that.lineData.data[n]; legend.selected[item.name] = false; //往legend的selected中推送数据 let seriesData = &#123; name: item.name, type: 'line', showAllSymbol: true, data: [] &#125;; let legendData = &#123; name: item.name, icon: 'square' &#125;; let arr = Object.keys(item.value); for (let t = 0; t &lt; arr.length; t++) &#123; seriesData.data.push(item.value[t]); if (n === 0) &#123; xAxisData.push(item.systime[t]); //往x轴推送数据 &#125; &#125; legend.data.push(legendData); //往legend的data中推送数据 that.option.series.push(seriesData); //往series中推送数据 &#125; //设置x轴间隔 if (xAxisData.length &gt; 10) &#123; that.option.xAxis.axisLabel.interval = Math.ceil(xAxisData.length/10); &#125;&#125; 创建echarts： 123456createCharts() &#123; let that = this; let dom:any = document.getElementById(that.id); let myChart:any = echarts.init(dom, 'macarons'); myChart.setOption(that.option); &#125; 这样就实现了从后端读取数据，然后echarts显示在界面上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之架构概览]]></title>
      <url>%2F2017%2F01%2F02%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[模块NgModuleNgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是： declarations - 声明本模块中拥有的视图类。 Angular 有三种视图类：组件、指令和管道。 exports - declarations 的子集，可用于其它模块的组件模板（暴露出来供外部使用）。 imports - 本模块声明的组件模板需要的类所在的其它模块（引入所需的其他模块的组件模板）。 providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。 bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。 通过main.ts引导AppModule: 1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); JavaScript模块 JavaScript 也有自己的模块系统，用来管理一组 JavaScript 对象。 它与 Angular 的模块系统完全不同且完全无关。 JavaScript 中，每个文件是一个模块，文件中定义的所有对象都从属于那个模块。 通过export关键字，模块可以把它的某些对象声明为公共的。 其它 JavaScript 模块可以使用import 语句来访问这些公共对象。 12import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component'; 1export class AppModule &#123; &#125; Angular模块库Angular模块库是一组JavaScript模块，名字带有@angular前缀。用 JavaScript 的import语句导入。 组件组件控制视图。在类中定义组件的应用逻辑。 应用可以通过生命周期钩子在组件生命周期的各个时间点上插入自己的操作，例如ngOnInit()`。 模板模板定义组件的视图，以HTML形式存在。 模板除了可以使用典型的HTML元素，还可以使用Angular的模板语法，例如：*ngFor、、(click)、[hero]和&lt;hero-detail&gt;等。 &lt;hero-detail&gt;是HeroDetailComponent组件自定义的HTML标签，HeroDetailComponent是HeroListComponent的子组件。 元数据用装饰器来附加元数据: 123456@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;) @Component的配置项包括： moduleId: 为与模块相关的 URL（例如templateUrl）提供基地址。（简单的理解为给url分配一个当前module的Id，便于区分） selector： CSS 选择器，它告诉 Angular 在父级 HTML 中查找&lt;hero-list&gt;标签，创建并插入该组件。 例如，如果应用的 HTML 包含&lt;hero-list&gt;&lt;/hero-list&gt;， Angular 就会把HeroListComponent的一个实例插入到这个标签中。 templateUrl：组件 HTML 模板的模块相对地址。 providers - 组件所需服务的依赖注入提供商数组。 这是在告诉 Angular：该组件的构造函数需要一个HeroService服务，这样组件就可以从服务中获得英雄数据。 数据绑定数据绑定的语法有以下四种形式。每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。 123&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;&lt;hero-detail [hero]="selectedHero"&gt;&lt;/hero-detail&gt;&lt;li (click)="selectHero(hero)"&gt;&lt;/li&gt; 插值表达式在&lt;li&gt;标签中显示组件的hero.name属性的值。 [hero]属性绑定把父组件HeroListComponent的selectedHero的值传到子组件HeroDetailComponent的hero属性中。 (click) 事件绑定在用户点击英雄的名字时调用组件的selectHero方法。 双向数据绑定是重要的第四种绑定形式，它使用ngModel指令组合了属性绑定和事件绑定的功能。 1&lt;input [(ngModel)]="hero.name"&gt; 在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。 Angular 在每个 JavaScript 事件循环中处理所有的数据绑定，它会从组件树的根部开始，递归处理全部子组件。 双向绑定的应用： 模板与对应组件的交互 父组件与子组件的通讯 指令 指令是一个带有“指令元数据”的类。在 TypeScript 中，要通过@Directive装饰器把元数据附加到类上。Angular根据指令提供的操作对DOM进行转换。（严格来说组件就是一个指令）。 结构型指令结构型指令通过在 DOM 中添加、移除和替换元素来修改布局。 12&lt;li *ngFor="let hero of heroes"&gt;&lt;/li&gt;&lt;hero-detail *ngIf="selectedHero"&gt;&lt;/hero-detail&gt; *ngFor告诉 Angular 为heroes列表中的每个英雄生成一个&lt;li&gt;标签。 *ngIf表示只有在选择的英雄存在时，才会包含HeroDetail组件。 属性型指令属性型指令修改一个现有元素的外观或行为。在模板中，它们看起来就像是标准的 HTML 属性。例如：ngModule。 服务服务是一个广义范畴，包括：值、函数，或应用所需的特性。 组件类应保持精简。组件本身不从服务器获得数据、不进行验证输入，也不直接往控制台写日志。 它们把这些任务委托给服务。 组件的任务就是提供用户体验，仅此而已。它介于视图（由模板渲染）和应用逻辑（通常包括模型的某些概念）之间。 设计良好的组件为数据绑定提供属性和方法，把其它琐事都委托给服务。 依赖注入 Angular 使用依赖注入来提供新组件以及组件所需的服务。Angular 通过查看构造函数的参数类型得知组件需要哪些服务。 1constructor(private service: HeroService) &#123; &#125; 当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。 注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。 当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。 这就是依赖注入 。(注入器将服务作为参数，注入到构造函数中) 当注入器没有服务时，通过provide创建并返回一个服务。 provide可以在根模块上添加provide以便任何地方使用服务的同一个实例，或者在@component元数据中添加provide以便在组件层中使用，把它注册在组件级表示该组件的每一个新实例都会有一个服务的新实例。 需要记住的关于依赖注入的要点是： 依赖注入渗透在整个 Angular 框架中，被到处使用。 注入器 (injector) 是本机制的核心。 注入器负责维护一个容器，用于存放它创建过的服务实例。 注入器能使用提供商创建一个新的服务实例。 提供商是一个用于创建服务的配方。 把提供商注册到注入器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2中的base标签]]></title>
      <url>%2F2016%2F12%2F31%2FAngular2%E4%B8%AD%E7%9A%84base%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[Angular2官方hero教程中，提到了&lt;base href=&quot;/&quot;&gt;，写的很简单，当时我也没有留意，今天写自己的开源项目的时候，突然遇到这个问题，正好讲一下。 我的路由是这样的： 12345const routes: Routes = [ &#123; path: '', redirectTo: '/line', pathMatch: 'full' &#125;, &#123; path: 'line', component: LineComponent &#125;, &#123; path: 'bar', component: BarComponent &#125;,]; 第一次加载页面的时候，url是：http://localhost:3000/line， 如果在&lt;head&gt;里没写&lt;base href=&quot;/&quot;&gt;，那么当你浏览器自动刷新的时候，url会变成：http://localhost:3000/line/line，也就是说，浏览器的前缀没有清空，这样会导致加载时出现404错误。这时候只要在&lt;head&gt;里加上&lt;base href=&quot;/&quot;&gt;，就可以了，或者加上： 1&lt;script&gt;document.write('&lt;base href="' + document.location + '" /&gt;');&lt;/script&gt; 来保护当前的URL，保证当我们导航到深层次的url时候，资源可以被正确加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[愿17可期]]></title>
      <url>%2F2016%2F12%2F27%2F%E6%84%BF17%E5%8F%AF%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[[ti:5.野子-苏运莹] [ar: 是] [al:] [by:] [offset:0] [00:00.10]野子 - 苏运莹 [00:00.20]词：苏运莹 [00:00.30]曲：苏运莹 [00:00.40] [00:25.72]怎么大风越狠 [00:28.82]我心越荡 [00:30.91] [00:31.96]幻如一丝尘土 [00:33.79]随风自由的在狂舞 [00:37.62] [00:38.32]我要握紧手中坚定 [00:41.40]却又飘散的勇气 [00:44.78]我会变成巨人 [00:46.73]踏着力气 踩着梦 [00:49.22] [00:51.22]怎么大风越狠 [00:54.29]我心越荡 [00:57.53]又如一丝消沙 [00:59.38]随风轻飘的在狂舞 [01:03.91]我要深埋心头上秉持 [01:07.10]却又重小的勇气 [01:10.21]一直往大风吹的方向走过去 [01:16.20]吹啊吹啊 我的骄傲放纵 [01:19.58]吹啊吹不毁我纯净花园 [01:22.27]任风吹 任它乱 [01:24.02]毁不灭是我 尽头的展望 [01:29.15]吹啊吹啊 我赤脚不害怕 [01:32.34]吹啊吹啊 无所谓 扰乱我 [01:35.52]你看我在勇敢地微笑 [01:37.98] [01:38.50]你看我在勇敢地去挥手啊 [01:42.88] [01:55.14]是你吗 会给我一扇心房 [01:57.60]让我勇敢前行 [02:00.48] [02:01.47]是你呀 会给我一扇灯窗 [02:04.39]让我让我无所畏惧 [02:07.56]吹啊吹啊 我的骄傲放纵 [02:10.76]吹啊吹不毁我纯净花园 [02:13.54]任风吹 任它乱 [02:15.23]毁不灭是我 尽头的展望 [02:19.72] [02:20.46]吹啊吹啊 我赤脚不害怕 [02:23.53]吹啊吹啊 无所谓 扰乱我 [02:26.62]你看我在勇敢地微笑 [02:29.72]你看我在勇敢地去挥手啊 [02:33.97] [02:40.03]怎么大风越狠 我心越荡 [02:46.28] [02:46.93]我会变成巨人 [02:49.75]踏着力气 踩着梦 new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: true, showlrc: 2, music: { title: "野子", author: "苏运莹", url: "http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a", pic: "http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg", } }); 即将过去的一年对我来说太重要，以至于像我这样害怕写总结的人也拿起键盘，敲下了这一段文字。 记得在15年11月吧，在深圳青旅认识的蔡浩凯大哥来上海出差，正好抽空一起吃了一顿饭，交流了一下工作心得，在诺基亚和IBM就职过的浩凯大哥给了我很多职业规划方面的意见，也给我种下一颗转行的种子。 大概是16年3月，我开始在网上看java，每天上班回来，看一小时一建和一小时java，到后来工作太忙，以至于我下决心彻底放弃一建，专心看java，期间汪汪和田野还给我寄了一大箱java的书，虽然我最后去做前端了，哈哈哈。IT上的版本管理工具、IDE、各种开源论坛、各种资料的分享让我看到了一种自己想要的工作模式。 于是16年8月底辞职，去了趟成都和九寨沟散散心，顺便找昭哥和玉玺小聚了一下。回来后便安心的开始看前端。 辞职后，遇到很多朋友都没有透露我转行的消息。其实，当时自己真的挺迷茫的，要填的坑太多，甚至都不确定自己是否会成功，只晓得沿着自己计划的方向走，至于失败还是成功就留给老天吧。 自学期间顺手搭了这个博客，作为程序猿，有自己搭的博客，赶脚逼格max，哈哈哈。11月，在汪汪童鞋的建议下，我开始投简历，可能运气比较好，第二个面试就被录用了。就这样，我也算跨入了程序猿的行列。 工作一个多月，发现自己的选择是正确的，这种Geek的工作模式让我感到充满动力，每次调完bug，那种如沐春风的感觉，真的很棒。 很庆幸，能做自己想做的事情，不管未来是怎么样，至少自己努力了。 感谢蔡浩凯大哥、汪汪、田野，把我领进了IT的大门。 感谢郑部、王博、超哥在面试后决定录用我，虽然我至今都觉得自己技术漏洞太多，被录用简直是奇迹。 感谢中兴通讯虚拟化上海一部DG2的所有同事，面对我的很多问题都能耐心解答，让我成功避开了很多坑。 感谢家人、女友在这一年的支持，在我迷茫的时候给我继续前进的动力。 最后，愿17可期。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo添加音乐、high一下及一些坑]]></title>
      <url>%2F2016%2F12%2F24%2Fhexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
      <content type="text"><![CDATA[hexo添加音乐需要几个步骤？添加音乐当然可以用其他网站的外链，但是一般外链是&lt;iframe&gt;，这个影响网站的SEO，逼格也不够高。 下面我就隆重介绍一款html5音乐播放器：Aplayer。把Aplayer加入hexo需要用到hexo-tag-aplayer插件。 切换到hexo目录，运行： 1npm install hexo-tag-aplayer@2.0.1 这里直接运行npm install hexo-tag-aplayer只会安装2.0.0，这个版本会出现以下错误： 12FATAL Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;Error: Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos; 作者给出来解决方案是用2.0.1版本，FATAL Cannot find module解决办法。 安装完成后，在需要添加音乐的地方加上： 1&#123;% aplayer "平凡之路" "朴树" "https://ogd99kckh.qnssl.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3" "https://ogd99kckh.qnssl.com/1.jpg" "autoplay" %&#125; 就会出现你想要的音乐啦，这里我把音乐和专辑封面添加到七牛上，加载速度嗖嗖的。 如果你想加入歌单，把上面的代码换成下面代码就行，参数的用法可以参照插件的使用说明。 1&#123;% aplayerlist %&#125;&#123;"narrow": false,"autoplay": true,"showlrc": 3,"mode": "random","music": [&#123;"title": "平凡之路","author": "朴树","url": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic": "https://ogd99kckh.qnssl.com/1.jpg","lrc": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"&#125;,&#123;"title": "野子","author": "苏运莹","url": "http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a","pic": "http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt"&#125;]&#125;&#123;% endaplayerlist %&#125; 当然，Aplayer的作者还有一款html5的视频播放器，叫Dplayer，对应有一款hexo的插件，叫hexo-tag-dplayer，有需求的可以去看看，用法都差不多。 一起high一下这个功能是我在Hexo high一下小功能上看到的，觉得很有意思，于是就引进来，改造了一下。 首先是重新封装了一个high.js文件，代码中注释的地方可下载下来放到七牛，加快国内访问速度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150function shake() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake.mp3"; //可下载下来放到七牛，加快国内访问速度 var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake-style.css";//可下载下来放到七牛，加快国内访问速度 var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125; 把这个文件保存在七牛上，在themes—&gt;next—&gt;layout—&gt;_partials—&gt;head.swig中加入这样一段代码，引入high.js文件(src里的内容请替换成自己的外链)： 1&lt;script type="text/javascript" src="https://ogd99kckh.qnssl.com/high.js"&gt;&lt;/script&gt; 然后在themes—&gt;next—&gt;layout—&gt;_macro—&gt;sidebar.swig中加入注释包围中的代码： 1234567891011121314151617&lt;div class="links-of-author motion-element"&gt; &#123;% if theme.social %&#125; &#123;% for name, link in theme.social %&#125; &lt;span class="links-of-author-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; &#123;% if theme.social_icons.enable %&#125; &lt;i class="fa fa-fw fa-&#123;&#123; theme.social_icons[name] | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;% endif %&#125; &#123;&#123; name &#125;&#125; &lt;/a&gt; &lt;/span&gt; &#123;% endfor %&#125; &lt;!--以下是加入关于high一下的代码--&gt; &lt;span class="links-of-author-item"&gt;&lt;a title="小high一下~" style="underline: none;color:red" rel="alternate" class="mw-harlem_shake_slow wobble shake" href="javascript:shake()"&gt;&lt;i class="fa fa-music"&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;High&lt;/a&gt;&lt;/span&gt; &lt;!--以上是加入关于high一下的代码--&gt; &#123;% endif %&#125; &lt;/div&gt; style中我用了红色，这样显眼一点，不喜欢的话可以改掉。 接下来点击high这个按钮，会出现一下效果： 大坑当我吭哧吭哧的弄完后，突然发现我运行hexo g命令后，出现下面两行提示后就不动了~ 12INFO Start processingINFO Files loaded in 3.9 s 我用了各种方法，包括版本回退，好像都没用。于是我就尝试切换到hexo默认主题，结果又可以hexo g，估计是next主题出问题了，于是我重新下了next主题，把我的配置都重新弄了一遍，结果好了~~，不过页脚的地方与之前博客不同，少了”power by hexo”这几个字眼。 更新next后遇到的第一个问题是，不显示文章发表时间了，github上的解答是这样的,文章标题下的发表时间不见了,在主题配置文件里面加上下面的配置，然后就出来了。 12345# Post meta display settingspost_meta: created_at: true updated_at: false categories: true 第二个问题，我hexo s成功后，登陆localhost:4000，发现出现下面的提示： 原因是，我开了shadowsocks的全局模式，切换到自动代理模式，就可以显示网页了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2官方文档学习笔记之hero教程]]></title>
      <url>%2F2016%2F12%2F21%2FAngular2%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bhero%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[ES6工具链 systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载 es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块 traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码。systemjs会自动加载 这个模块。 Hello World 根据官方文档的快速起步，按照自己的理解画了上面的流程图（有不对的地方还请指正）。 包括Angular在内的Angular应用通过NgModules分成不同的代码块，需要哪个块，就import，这样可以减少文件体积。 每一个Angular应用都至少有一个模块和组件，组件通过与它相关的模板来控制屏幕上的一小块（视图View），main.ts负责初始化应用平台，进行应用引导。 为了方便测试组件，应用的引导应与组件或者模块分开，这样实现了MVM（model-view-whatever） Hero教程官网的Hero教程是建立在quickstart上的，所以可以把quickstart直接拿过来用。 英雄编辑器class中可以定义一些变量、方法甚至是构造函数（用于初始化），export出来的class可以被外部使用。 在Angular中{{}}用来取值。 一个ts文件中可以定义多个export class，但是官方不提倡。 id:number和hero:Hero = {}都是指定了变量的类型。 template中双引号改成反引号，可以写成多行形式。 表单输入双向绑定需要导入FormsModule模块，@NgModule中的import数组是应用中用到的外部模块列表。 用到Angular自带的模块，在import数组中声明；用到自定义的组件在declarations数组中声明。 主从结构123456789101112const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; 这段代码中的const是ES6中定义变量的关键字，在ES6中， const 代表一个值的常量索引，变量名字在内存中的指针不能够改变，但是指向这个变量的值 可能 改变。例如： 1234567const names = [ ] ;names . push ( “Jordan” ) ;console . log ( names ) ;const names = [ ] ;names = [ ] ; // Error! *ngFor=&quot;let hero of heroes&quot;中ngFor的*前缀表示``及其子元素组成了一个主控模板。 ngFor指令在AppComponent.heroes属性返回的heroes数组上迭代，并输出此模板的实例。 引号中赋值给ngFor的那段文本表示“从heroes数组中取出每个英雄，存入一个局部的hero变量，并让它在相应的模板实例中可用”。 为一个组件指定样式时，它们的作用域将仅限于该组件。 ngIf指令为false则从 DOM 中移除整段 HTML。 [class.selected]=&quot;hero === selectedHero&quot; 这个写法很有意思，.可以理解为css类选择器，在class上为selected类添加一个属性绑定（绑定了style中的.selected这个样式），当后面的表达式为true时，绑定这个样式，false时不绑定。而[]实现了从数据源(hero === selectedHero表达式)到class属性的单向数据流动。 多个组件可以将需要多次引用的类单独写入一个ts文件中。 &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;通过标签中的[hero]=&quot;selectedHero&quot;可以在不同组件之间传递数据。在需要引用hero的地方，用@Input() hero: Hero;来引入hero。 服务当 TypeScript 看到@Injectable()装饰器时，就会记下本服务的元数据。 如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。 HeroService从mock-heroes.ts获取数据，并提供给其他组件使用。其他组件使用HeroService时，用构造函数定义一个私有属性，作为注入HeroService的靶点。 providers数组告诉 Angular，当它创建新的AppComponent组件时，也要创建一个HeroService的新实例。 可以把HeroService看做中转站，而providers数组告诉 Angular，这是中转站。中转站中记录着哪里的有元数据，并随时准备注入所需要的组件中。 OnInit 接口会在组件刚创建时、每次变化时，以及最终被销毁时被Angular调用。OnInit 接口中会有一个带有初始化逻辑的ngOnInit方法，可以用来初始化。 承诺，在有了结果时，它承诺会回调我们。 我们请求一个异步服务去做点什么，并且给它一个回调函数。 它会去做（在某个地方），一旦完成，它就会调用我们的回调函数，并通过参数把工作结果或者错误信息传给我们。 123getHeroes(): void &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);&#125; 这个方法基于承诺的，并在承诺的事情被解决时再行动。 一旦承诺的事情被成功解决，就会显示英雄数据。then方法把回调函数作为参数传给承诺对象。 路由路由告诉路由器，当用户点击链接或者把 URL 粘贴到浏览器地址栏时，应该显示哪个视图。 路由定义包括以下部分： path: 路由器会用它来匹配浏览器地址栏中的地址，如heroes。 component: 导航到此路由时，路由器需要创建的组件（HeroesComponent）。 路由有两种实现方式： 第一种是通过RouterLink指令，绑定到heroes的路由路径，在app.module.ts中指定了&#39;/heroes&#39;就是指向HeroesComponent的那个路由的路径，并且需要告诉路由把激活的组件显示在&lt;router-outlet&gt;里面。 12345template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a routerLink="/heroes"&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; ` 1234567891011121314151617181920212223@NgModule(&#123; imports: [ BrowserModule, FormsModule, RouterModule.forRoot([ &#123; path: 'heroes', component: HeroesComponent &#125; ]) ], declarations: [ AppComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123;&#125; 第二种是通过函数来实现，触发click事件后，调用gotoDetail函数，该函数将路由导航到detail的组件上。 123gotoDetail(): void &#123; this.router.navigate(['/detail', this.selectedHero.id]);&#125; 1&lt;button (click)="gotoDetail()"&gt;View Details&lt;/button&gt; 浏览器启动时，在地址栏中使用的路径是/。如果要在应用启动的时候就显示仪表盘，而且希望在浏览器的地址栏看到一个好看的 URL，比如/dashboard，这就需要用到重定向： 12345&#123; path: '', redirectTo: '/dashboard', pathMatch: 'full'&#125;, 设置moduleId属性到module.id后，才能使用templateUrl。 路径中的冒号 (:) 表示:id是一个占位符: 1234&#123; path: 'detail/:id', component: HeroDetailComponent&#125;, 通过[routerLink]绑定了一个包含链接参数数组的表达式。 该数组有两个元素，目标路由和一个用来设置当前英雄的 id 值的路由参数。这两个元素与上面定义中的 path 和 :id 对应。 1&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt; 典型路由模块值得注意的有： 将路由抽出到一个变量中。你将来可能会导出它，而且它让路由模块模式更加明确。 添加RouterModule.forRoot(routes)到imports。 添加RouterModule到exports，这样关联模块的组件可以访问路由的声明，比如RouterLink和RouterOutlet。 无declarations！声明是关联模块的任务。 如果你有守卫服务，添加模块providers。 Angular路由器提供了routerLinkActive指令，我们可以用它来为匹配了活动路由的 HTML 导航元素自动添加一个 CSS 类。 12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink="/dashboard" routerLinkActive="active"&gt;Dashboard&lt;/a&gt; &lt;a routerLink="/heroes" routerLinkActive="active"&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 123nav a.active &#123; color: #039be5;&#125; 好不容易走到路由这步，我按照我的理解画了一个脑图： HTTP准备HTTP服务@angular/http库中的HttpModule保存着这些 HTTP 相关服务提供商的全集。 模拟web API123// Imports for loading &amp; configuring the in-memory web apiimport &#123; InMemoryWebApiModule &#125; from 'angular-in-memory-web-api';import &#123; InMemoryDataService &#125; from './in-memory-data.service'; InMemoryWebApiModule将Http客户端默认的后端服务替换成了内存 Web API服务。 1InMemoryWebApiModule.forRoot(InMemoryDataService), forRoot配置方法需要InMemoryDataService类实例，用来向内存数据库填充数据。 英雄与HTTP12345678910private heroesUrl = 'app/heroes'; // URL to web apiconstructor(private http: Http) &#123; &#125;getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data as Hero[]) .catch(this.handleError);&#125; HTTP承诺Angular 的http.get返回一个RxJS的Observable对象。 Observable（可观察对象）是一个管理异步数据流的强力方式。 1.toPromise() 利用toPromise操作符把Observable直接转换成Promise对象。Angular 的Observable并没有一个toPromise操作符，需要从 RxJS 库中导入它们。 1import 'rxjs/add/operator/toPromise'; 在then 回调中提取出数据1.then(response =&gt; response.json().data as Hero[]) 在 promise 的then回调中，调用 HTTP 的Reponse对象的json方法，以提取出其中的数据。 错误处理1.catch(this.handleError); 1234private handleError(error: any): Promise&lt;any&gt; &#123; console.error('An error occurred', error); // for demo purposes only return Promise.reject(error.message || error);&#125; catch了服务器的失败信息，并把它们传给了错误处理器 更新英雄详情hero服务的update方法12345678910private headers = new Headers(&#123;'Content-Type': 'application/json'&#125;);update(hero: Hero): Promise&lt;Hero&gt; &#123; const url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError);&#125; 通过一个编码在 URL 中的英雄 id 来告诉服务器应该更新哪个英雄。put 的 body 是该英雄的 JSON 字符串，它是通过调用JSON.stringify得到的。 并且在请求头中标记出的 body 的内容类型（application/json）。 添加英雄12345678910111213141516&lt;div&gt; &lt;label&gt;Hero name:&lt;/label&gt; &lt;input #heroName /&gt; &lt;button (click)="add(heroName.value); heroName.value=''"&gt; Add &lt;/button&gt;&lt;/div&gt; add(name: string): void &#123; name = name.trim(); if (!name) &#123; return; &#125; this.heroService.create(name) .then(hero =&gt; &#123; this.heroes.push(hero); this.selectedHero = null; &#125;);&#125; 当指定的名字不为空的时候，点击处理器就会委托 hero 服务来创建一个具有此名字的英雄， 并把这个新的英雄添加到数组中。 删除一个英雄1234567&lt;li *ngFor="let hero of heroes" (click)="onSelect(hero)" [class.selected]="hero === selectedHero"&gt; &lt;span class="badge"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;hero.name&#125;&#125;&lt;/span&gt; &lt;button class="delete" (click)="delete(hero); $event.stopPropagation()"&gt;x&lt;/button&gt;&lt;/li&gt; delete按钮的点击处理器应该阻止点击事件向上冒泡 ，否则它会选中我们要删除的这位英雄。 可观察对象 (Observable)一个可观察对象是一个事件流，我们可以用数组型操作符来处理它。 把Observable转换成了Promise通常是更好地选择，我们通常会要求http.get获取单块数据。只要接收到数据，就算完成。 使用承诺这种形式的结果是让调用方更容易写，并且承诺已经在 JavaScript 程序员中被广泛接受了。 按名搜索12345678910111213import &#123; Injectable &#125; from '@angular/core';import &#123; Http, Response &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs';import &#123; Hero &#125; from './hero';@Injectable()export class HeroSearchService &#123; constructor(private http: Http) &#123;&#125; search(term: string): Observable&lt;Hero[]&gt; &#123; return this.http .get(`app/heroes/?name=$&#123;term&#125;`) .map((r: Response) =&gt; r.json().data as Hero[]); &#125;&#125; 不再调用toPromise，而是直接返回可观察对象。 HeroSearchComponent12345678910&lt;div id="search-component"&gt; &lt;h4&gt;Hero Search&lt;/h4&gt; &lt;input #searchBox id="search-box" (keyup)="search(searchBox.value)" /&gt; &lt;div&gt; &lt;div *ngFor="let hero of heroes | async" (click)="gotoDetail(hero)" class="search-result" &gt; &#123;&#123;hero.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; heroes属性现在是英雄列表的Observable对象，而不再只是英雄数组。 *ngFor不能用可观察对象做任何事，除非我们在它后面跟一个async pipe (AsyncPipe)。 这个async管道会订阅到这个可观察对象，并且为*ngFor生成一个英雄数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Router &#125; from '@angular/router';import &#123; Observable &#125; from 'rxjs/Observable';import &#123; Subject &#125; from 'rxjs/Subject';import &#123; HeroSearchService &#125; from './hero-search.service';import &#123; Hero &#125; from './hero';@Component(&#123; moduleId: module.id, selector: 'hero-search', templateUrl: 'hero-search.component.html', styleUrls: [ 'hero-search.component.css' ], providers: [HeroSearchService]&#125;)export class HeroSearchComponent implements OnInit &#123; heroes: Observable&lt;Hero[]&gt;; private searchTerms = new Subject&lt;string&gt;(); constructor( private heroSearchService: HeroSearchService, private router: Router) &#123;&#125; // Push a search term into the observable stream. search(term: string): void &#123; this.searchTerms.next(term); &#125; ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) // wait for 300ms pause in events .distinctUntilChanged() // ignore if next search term is same as previous .switchMap(term =&gt; term // switch to new observable each time // return the http search observable ? this.heroSearchService.search(term) // or the observable of empty heroes if no search term : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; // TODO: real error handling console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;); &#125; gotoDetail(hero: Hero): void &#123; let link = ['/detail', hero.id]; this.router.navigate(link); &#125;&#125; 搜索词123456private searchTerms = new Subject&lt;string&gt;();// Push a search term into the observable stream.search(term: string): void &#123; this.searchTerms.next(term);&#125; Subject（主题）是一个可观察的事件流中的生产者。 searchTerms生成一个产生字符串的Observable，用作按名称搜索时的过滤条件。 每当调用search时都会调用next来把新的字符串放进该主题的可观察流中。 初始化 HEROES 属性(NGONINIT)1234567891011121314151617heroes: Observable&lt;Hero[]&gt;;ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) // wait for 300ms pause in events .distinctUntilChanged() // ignore if next search term is same as previous .switchMap(term =&gt; term // switch to new observable each time // return the http search observable ? this.heroSearchService.search(term) // or the observable of empty heroes if no search term : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; // TODO: real error handling console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);&#125; Subject也是一个Observable对象。 要把搜索词的流转换成Hero数组的流，并把结果赋值给heroes属性。 如果我们直接把每一次用户按键都直接传给HeroSearchService，就会发起一场 HTTP 请求风暴。我们不希望占用服务器资源，也不想耗光蜂窝移动网络的流量。 幸运的是，我们可以在字符串的Observable后面串联一些Observable操作符，来归并这些请求。 我们将对HeroSearchService发起更少的调用，并且仍然获得足够及时的响应。做法如下： 在传出最终字符串之前，debounceTime(300)将会等待，直到新增字符串的事件暂停了 300 毫秒。 我们实际发起请求的间隔永远不会小于 300ms。 distinctUntilChanged确保只在过滤条件变化时才发送请求， 这样就不会重复请求同一个搜索词了。 switchMap会为每个从debounce和distinctUntilChanged中通过的搜索词调用搜索服务。 它会取消并丢弃以前的搜索可观察对象，只保留最近的。 switchMap操作符 (以前叫”flatMapLatest”)是非常智能的。每次符合条件的按键事件都会触发一次对http方法的调用。即使在发送每个请求前都有 300 毫秒的延迟， 我们仍然可能同时拥有多个在途的 HTTP 请求，并且它们返回的顺序未必就是发送时的顺序。switchMap保留了原始的请求顺序，并且只返回最近一次 http 调用返回的可观察对象。 这是因为以前的调用都被取消或丢弃了。如果搜索框为空，我们还可以短路掉这次http方法调用，并且直接返回一个包含空数组的可观察对象。注意，取消HeroSearchService的可观察对象并不会实际中止 (abort) 一个未完成的 HTTP 请求， 除非服务支持这个特性，这个问题我们以后再讨论。 目前我们的做法只是丢弃不希望的结果。 导入RxJS操作符123456789101112// Observable class extensionsimport 'rxjs/add/observable/of';import 'rxjs/add/observable/throw';// Observable operatorsimport 'rxjs/add/operator/catch';import 'rxjs/add/operator/debounceTime';import 'rxjs/add/operator/distinctUntilChanged';import 'rxjs/add/operator/do';import 'rxjs/add/operator/filter';import 'rxjs/add/operator/map';import 'rxjs/add/operator/switchMap'; 把整个应用中要用的那些 RxJS Observable扩展组合在一起，放在一个单独的 RxJS 导入文件中。我们在顶级的AppModule中导入rxjs-extensions就可以一次性加载它们。 1import './rxjs-extensions';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON那些事]]></title>
      <url>%2F2016%2F12%2F18%2FJSON%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[最近用echarts时和json打交道比较多，在此记录一下关于json的一些事情。 什么是JSONw3school上给出的描述是： JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 * JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON数据书写格式是： 1name : value 其中value的值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON对象与JSON数组JSON对象JSON对象在{}中书写，对象可以包含多个键值对； 1&#123;"firstName":"John" , "lastName":"Doe"&#125; 一般JSON对象中有多个键值对时，用,隔开，最后一个键值对结束时可以不写,。 JSON数组JSON数组在[]中书写，数组可以包含多个对象。 举个栗子： 1234567&#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ]&#125; &quot;employees&quot;这个json对象包含了三个json对象的数组。 JSON的操作获取value举个例子: 12345var employees = [&#123; "firstName":"Bill" , "lastName":"Gates" &#125;,&#123; "firstName":"George" , "lastName":"Bush" &#125;,&#123; "firstName":"Thomas" , "lastName": "Carter" &#125;]; 如果要得到Bill的firstName，可以这样写： 1employees[0].firstName; 因为employees是数组，首先通过employees[0]来获取第一个对象，然后用.加要访问的字段名称，就可以获取该字段对应的值。 添加和删除JSON对象1234567var json = &#123;&#125;; //空json对像 json['firstname'] = "cheng"; //添加二个元素 json['lastname'] = "tang"; console.log(json); delete json['lastname']; //删除json中的某个元素 console.log(json); JSON数组123456789var json1 = [&#123;"name":"tang","total":"1"&#125;,&#123;"name":"zhou","total":"2"&#125;,&#123;"name":"he","total":"3"&#125;]; var add = &#123;"name":"may"&#125;; json1.push(add); //添加一个元素 console.log(json1); delete json1[2]; //删除一个元素 console.log(json1); 遍历JSON对象假设有一个JSON对象： 1var data=&#123;'a':10,'b':20,'c':30,'d':40&#125;; 怎么遍历这个对象呢，可以用for-in: 1234567for(var n in data)&#123; console.log(n); //输出 a，b，c，d console.log(data[n]); //输出 10，20，30，40&#125; 在JavaScript中[]等同于. ，所以 data[n]可以理解为data.n，只不过n是变量，用.获取不到对应的值。 JSON数组假设有一个JSON数组： 1var data=[&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125;]; 遍历这个数组： 12345678910for(var n in data)&#123; console.log(n); //输出：0，1，2，3 console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; 或者： 1234567for (var n = 0;n &lt; data.length; n++)&#123; console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; eval()与JSON.parse()eval()可以将字符串转换为 JavaScript 对象： 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = eval('('+test+')'); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 通过这个方法我们就可以动态设置key的值。但是使用这个方法会存在潜在的安全问题，所以可以用JSON.parse()，这个方法需要较高版本的浏览器支持。 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = JSON.parse(test); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 接下来就可以通过json[key] = value来设置key对应的value值。 Object.keys() Object.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。 123456789101112var bookAuthors = &#123; "Farmer Giles of Ham": "J.R.R. Tolkien", "Out of the Silent Planet": "C.S. Lewis", "The Place of the Lion": "Charles Williams", "Poetic Diction": "Owen Barfield"&#125;;var arr = Object.keys(bookAuthors);console.log(arr);//输出: Array [ "Farmer Giles of Ham", "Out of the Silent Planet", "The Place of the Lion", "Poetic Diction" ]console.log(arr.length);//输出: 4 用这个方法可以把json对象转换成数组，这样可以方便的对这个数组进行一些操作。 1234567var test = &#123; "name ": "tangcheng", "value": [1,2,3,4,5]&#125;var arr = Object.keys(test);console.log(arr.length); //输出： 2console.log(test.length) //输出：undefined Object.keys()方法，只能使用在高版本浏览器，IE8及以下是不支持的，如果想支持IE低版本，可以参考Javascript 计算Object的长度中提供的方法。 参考文章： JSON中让key作为参数传入的方法； Javascript 计算Object的长度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰Git教程学习笔记]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%BB%96%E9%9B%AA%E5%B3%B0Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[粗略看过git方面的视频，工作之前自己写的代码量少，管理方便，git方面的知识也够用。但是最近工作的时候用git总是有各种问题，于是拿起廖雪峰老师的教程，开始撸一遍完整的。 创建版本库git创建版本库很简单，只要用以下命令即可 123$ mkdir tangcheng //创建文件夹$ cd tangcheng $ git init //创建版本库 完成后文件夹下面会有一个.git的隐藏目录，这是git的版本库。 版本库管理工作区与暂存区 廖老师的这个图很清楚，工作区就是tangcheng这个文件夹，这个文件夹里面的.git隐藏目录就是版本库。 通过git add告诉git把文件添加到仓库，然后用git commit把文件提交到仓库。 git commit成功后git会记录你的修改，如果不add到暂存区，那就不会加入到commit中。可以多次git add文件，git commit一次提交多个文件。 Git基本命令git status可以参看仓库状态; git diff可以参看difference，显示格式是Unix通用的diff格式; git log可以显示从近到远的提交日志，日志中的一大串字母和数字的组合就是版本号。 git reset --hard HEAD^表示回退版本，上一个版本是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。如果回退到上一个旧版本，当前的版本则会在log中删除，若要从上一个版本回退到已经删除的版本，需要在用回退命令的命令窗口中，通过版本号找回，例如$ git reset --hard 3628164，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 若上一段中的用回退命令的命令窗口已经关闭，可以用git reflog来查看你每一次的命令和对应操作的版本号。 git checkout -- tangcheng.txt意思就是，把tangcheng.txt文件在工作区的修改（包括删除文件的操作）全部撤销，就是让这个文件回到最近一次git commit或git add时的状态。命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。 git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区 git rm从版本库中删除文件。 远程仓库把本地仓库的内容推送到GitHub仓库，在本地的tangcheng仓库下运行命令： 1$ git remote add origin git@github.com:tangcheng/tangcheng.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 $ git push -u origin master是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 1$ git clone git@github.com:tangcheng/tangcheng.git 克隆一个本地库。GitHub给出的地址不止一个，还可以用https://github.com/tangcheng/tangcheng.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理1$ git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 12$ git branch dev$ git checkout dev 用git branch命令查看当前分支。 git branch命令会列出所有分支，当前分支前面会标一个*号。 git merge dev```把`dev`分支的工作成果合并到`master`分支上，`git merge`命令用于合并指定分支到当前分支。1234567删除`dev`分支:```sh$ git branch -d dev 当Git无法自动合并分支时，就必须首先解决冲突。Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 1$ git merge --no-ff -m "merge with no-ff" dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 要查看远程库的信息，用git remote或者，用git remote -v显示更详细的信息。 推送分支： 1$ git push origin master //把master推送到远程分支 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 标签管理git tag &lt;name&gt;就可以打一个新标签。有commit为什么还要标签呢，因为commit是很长一串数字和字母的组合，阅读性差。commit和tag的关系类似于ip和域名。 用命令git tag查看所有标签。默认标签是打在最新提交的commit上的。标签不是按时间顺序列出，而是按字母排序的。 对特定的commit id打标签： 1$ git tag v0.9 6224937 可以用git show查看标签信息 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m "version 0.1 released" 3628164 如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag 'v0.1' (was e078af9) 如果要推送某个标签到远程，使用命令git push origin： 1$ git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1$ git push origin --tags 命令git push origin :refs/tags/可以删除一个远程标签。 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理。 你确实想添加该文件，可以用-f强制添加到Git： 1$ git add -f App.class .gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查 配置别名我们只需要敲一行命令，告诉Git，以后st就表示status： 1$ git config --global alias.st status 这样以后敲git st就表示git status --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 每个仓库的Git配置文件都放在.git/config文件中，别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。 配置一个git last，让其显示最后一次提交信息： 1$ git config --global alias.last 'log -1' 这样，用git last就能显示最近一次的提交： 1234567$ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS2中一种button切换效果的实现]]></title>
      <url>%2F2016%2F12%2F08%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[最近在AngularJS2中要实现一个按钮切换的效果，我采用三目表达式和ng-class的方式来实现了这一效果，比较简单粗暴。 首先，我的项目的XX.Component.ts中的template有个button标签： 12&lt;button type="submit"&gt;列表&lt;/button&gt;&lt;button type="submit"&gt;折线图&lt;/button&gt; 创建XX.Component.css，为标签添加简单的样式（我只是举个例子，这个样式的定义还可以再优化一下）： 12345678910111213141516171819.active &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: #0086FD; padding: 5px; outline: none; width: 55px;&#125;.btn-lt &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: gray; padding: 5px; outline: none; width: 55px;&#125; 然后我需要实现的效果是：加载完页面后，两个按钮都是灰色的，当你点击其中一个按钮时，按钮变成蓝色。 为了实现这个效果，我引入了begin和blue两个变量，分别控制起始状态和点击时的状态。当blue为true且begin===1时按钮变蓝色；当blue为false时或者begin！= 1时按钮变灰色。代码如下： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 这个方法还可以组合出其他不同的效果，比如说点击后当前按钮变灰： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 比如把begin去掉，可以实现加载完成后有一个按钮处于激活状态，这里我就不做gif了，可以自己尝试一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Echarts使用小结]]></title>
      <url>%2F2016%2F12%2F04%2FEcharts%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[这周项目上写了一个基于Angular2.0的Echarts3组件，踩了好几个坑，也算有一点使用心得了。 Echarts是什么鬼 ECharts 是指 Enterprise Charts（商业产品图表库），提供商业产品常用图表库，底层基于 ZRender，创建了坐标系，图例，提示，工具箱等基础组件，并在此上构建出折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、地图、力导向布局图，同时支持任意维度的堆积和多图表混合展现。 Echarts提供了多种图表展示方式： Echarts提供了包括值域漫游、大规模散点图、数据动态添加、数据区域漫游、图例开关、动态类型切换等在内的多种数据操作方式。Echarts升级到3.0后，增加了对移动端的支持，而且体积更小，实乃数据分析必备良药。 Echarts正确打开方式首先来看官方案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 怎么样，是不是觉得很好玩，当然这只是最基本的数据展示功能，下面我们来玩一个进阶一点的Demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="gb2312"&gt; &lt;title&gt;echarts3&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;echarts3 demo&lt;/h1&gt; &lt;!--定义有大小的DOM容器--&gt; &lt;div id="barChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="lineChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="radarChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="pieChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="dotChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;!--导入js代码--&gt; &lt;script type="text/javascript" src='./jquery.js'&gt;&lt;/script&gt; &lt;script type="text/javascript" src='./echarts.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //界面最先运行这个代码块 $(document).ready(function() &#123; initBarEcharts(); initLineEcharts(); initRadarEcharts(); initPieEcharts(); initDotEcharts(); &#125;); //初始化柱状图 function initBarEcharts() &#123; var myChart = echarts.init(document.getElementById('barChart')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, dataZoom: &#123; type: 'slider', show: true, start: 1, end: 35 &#125;, tooltip: &#123;&#125;, toolbox: &#123; show: true, feature: &#123; saveAsImage: &#123; show: true, type: 'jpeg', &#125;, restore: &#123; show: true, &#125;, dataView: &#123; show: true, &#125;, magicType: &#123; show: true, &#125; &#125;, &#125;, legend: &#123; data: ['销量'] &#125;, xAxis: &#123; //x轴数据，数组形式 data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化折线图图 function initLineEcharts() &#123; var myChart = echarts.init(document.getElementById('lineChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '堆叠区域图' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎'] &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis: [&#123; type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] &#125;], yAxis: [&#123; type: 'value' &#125;], series: [&#123; name: '邮件营销', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: '联盟广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: '视频广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: '直接访问', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [320, 332, 301, 334, 390, 330, 320] &#125;, &#123; name: '搜索引擎', type: 'line', stack: '总量', label: &#123; normal: &#123; show: true, position: 'top' &#125; &#125;, areaStyle: &#123; normal: &#123;&#125; &#125;, data: [820, 932, 901, 934, 1290, 1330, 1320] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化雷达图 function initRadarEcharts() &#123; var myChart = echarts.init(document.getElementById('radarChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '基础雷达图' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['预算分配（Allocated Budget）', '实际开销（Actual Spending）'] &#125;, radar: &#123; // shape: 'circle', indicator: [&#123; name: '销售（sales）', max: 6500 &#125;, &#123; name: '管理（Administration）', max: 16000 &#125;, &#123; name: '信息技术（Information Techology）', max: 30000 &#125;, &#123; name: '客服（Customer Support）', max: 38000 &#125;, &#123; name: '研发（Development）', max: 52000 &#125;, &#123; name: '市场（Marketing）', max: 25000 &#125;] &#125;, series: [&#123; name: '预算 vs 开销（Budget vs spending）', type: 'radar', // areaStyle: &#123;normal: &#123;&#125;&#125;, data: [&#123; value: [4300, 10000, 28000, 35000, 50000, 19000], name: '预算分配（Allocated Budget）' &#125;, &#123; value: [5000, 14000, 28000, 31000, 42000, 21000], name: '实际开销（Actual Spending）' &#125;] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化饼图 function initPieEcharts() &#123; var myChart = echarts.init(document.getElementById('pieChart')); // 指定图表的配置项和数据 option = &#123; backgroundColor: '#2c343c', title: &#123; text: 'Customized Pie', left: 'center', top: 20, textStyle: &#123; color: '#ccc' &#125; &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, visualMap: &#123; show: false, min: 80, max: 600, inRange: &#123; colorLightness: [0, 1] &#125; &#125;, series: [&#123; name: '访问来源', type: 'pie', radius: '55%', center: ['50%', '50%'], data: [&#123; value: 335, name: '直接访问' &#125;, &#123; value: 310, name: '邮件营销' &#125;, &#123; value: 274, name: '联盟广告' &#125;, &#123; value: 235, name: '视频广告' &#125;, &#123; value: 400, name: '搜索引擎' &#125;].sort(function(a, b) &#123; return a.value - b.value &#125;), roseType: 'angle', label: &#123; normal: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125;, smooth: 0.2, length: 10, length2: 20 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#c23531', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化散点图 function initDotEcharts() &#123; var myChart = echarts.init(document.getElementById('dotChart')); // 指定图表的配置项和数据 var data = [ [ [28604, 77, 17096869, 'Australia', 1990], [31163, 77.4, 27662440, 'Canada', 1990], [1516, 68, 1154605773, 'China', 1990], [13670, 74.7, 10582082, 'Cuba', 1990], [28599, 75, 4986705, 'Finland', 1990], [29476, 77.1, 56943299, 'France', 1990], [31476, 75.4, 78958237, 'Germany', 1990], [28666, 78.1, 254830, 'Iceland', 1990], [1777, 57.7, 870601776, 'India', 1990], [29550, 79.1, 122249285, 'Japan', 1990], [2076, 67.9, 20194354, 'North Korea', 1990], [12087, 72, 42972254, 'South Korea', 1990], [24021, 75.4, 3397534, 'New Zealand', 1990], [43296, 76.8, 4240375, 'Norway', 1990], [10088, 70.8, 38195258, 'Poland', 1990], [19349, 69.6, 147568552, 'Russia', 1990], [10670, 67.3, 53994605, 'Turkey', 1990], [26424, 75.7, 57110117, 'United Kingdom', 1990], [37062, 75.4, 252847810, 'United States', 1990] ], [ [44056, 81.8, 23968973, 'Australia', 2015], [43294, 81.7, 35939927, 'Canada', 2015], [13334, 76.9, 1376048943, 'China', 2015], [21291, 78.5, 11389562, 'Cuba', 2015], [38923, 80.8, 5503457, 'Finland', 2015], [37599, 81.9, 64395345, 'France', 2015], [44053, 81.1, 80688545, 'Germany', 2015], [42182, 82.8, 329425, 'Iceland', 2015], [5903, 66.8, 1311050527, 'India', 2015], [36162, 83.5, 126573481, 'Japan', 2015], [1390, 71.4, 25155317, 'North Korea', 2015], [34644, 80.7, 50293439, 'South Korea', 2015], [34186, 80.6, 4528526, 'New Zealand', 2015], [64304, 81.6, 5210967, 'Norway', 2015], [24787, 77.3, 38611794, 'Poland', 2015], [23038, 73.13, 143456918, 'Russia', 2015], [19360, 76.5, 78665830, 'Turkey', 2015], [38225, 81.4, 64715810, 'United Kingdom', 2015], [53354, 79.1, 321773631, 'United States', 2015] ] ]; option = &#123; backgroundColor: new echarts.graphic.RadialGradient(0.3, 0.3, 0.8, [&#123; offset: 0, color: '#f7f8fa' &#125;, &#123; offset: 1, color: '#cdd0d5' &#125;]), title: &#123; text: '1990 与 2015 年各国家人均寿命与 GDP' &#125;, legend: &#123; right: 10, data: ['1990', '2015'] &#125;, xAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125; &#125;, yAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125;, scale: true &#125;, series: [&#123; name: '1990', data: data[0], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(120, 36, 50, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(251, 118, 123)' &#125;, &#123; offset: 1, color: 'rgb(204, 46, 72)' &#125;]) &#125; &#125; &#125;, &#123; name: '2015', data: data[1], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(25, 100, 150, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(129, 227, 238)' &#125;, &#123; offset: 1, color: 'rgb(25, 183, 207)' &#125;]) &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Echarts与Angular2.0我做组件的时候定义了ky-line标签，通过&lt;ky-line [data]=&quot;myoption&quot;&gt;&lt;/ky-line&gt;里的data属性来传递option的数据，这样拿到后端的数据后，往myoption里面push数据，并通过ky-line标签，把数据传递给Echarts中的option，这样就可以实现给echarts动态写入数据。不过要注意的是，给echarts中动态增加数据的时候，首先要搞清楚json对象和json数组的概念，不然容易出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oh_My_Zsh-终端改造]]></title>
      <url>%2F2016%2F11%2F28%2FOh-My-Zsh-%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
      <content type="text"><![CDATA[周末的时候无意中看到一篇文章终极 Shell，介绍的就是今天讲的主角Oh My Zsh 。 什么是Oh My Zsh Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 Oh My Zsh这个名字听起来就很有意思，它是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。 Oh My Zsh只是一个对zsh命令行环境的配置包装框架，但它不提供命令行窗口，更不是一个独立的APP。 更详细介绍可到官网了解，Oh My Zsh官网：http://ohmyz.sh 安装Oh My Zsh前提条件：必须已安装ZSH 我们可以在命令行中输入这个命令来查看我们的电脑上是否安装了zsh命令行 1$ zsh --version 如果安装了，这个命令就会输出zsh当前的版本号。确定 zsh 已经安装后，我们就可以继续安装Oh My Zsh了。 安装Oh My Zsh Oh My Zsh 的安装方式非常简单，可以通过curl或wget的方式，用一条命令即可安装。 curl 方式 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; wget 方式 1$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装过程中输出如下 12345678910111213141516171819202122Cloning Oh My Zsh...Cloning into &apos;/root/.oh-my-zsh&apos;...remote: Counting objects: 712, done.remote: Compressing objects: 100% (584/584), done.remote: Total 712 (delta 15), reused 522 (delta 4), pack-reused 0Receiving objects: 100% (712/712), 443.58 KiB | 27.00 KiB/s, done.Resolving deltas: 100% (15/15), done.Checking connectivity... done.Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrcCopying your current PATH and adding it to the end of ~/.zshrc for you.Time to change your default shell to zsh! __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 到这里，Oh My Zsh 就安装成功了。 设置主题安装完毕后，我们就可以使用了，咱们先来简单配置一下。Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格，主题的配置在 ~/.zshrc 文件中可以看到，用一个自己熟悉的编辑器打开这个文件，可以找到这一项： 1ZSH_THEME=&quot;robbyrussel&quot; 可以看到，我们默认使用的主题叫做robbyrussel。 Oh My Zsh默认自带了一些默认主题，存放在~/.oh-my-zsh/themes目录中。我们可以查看这些主题 12345678910111213$ ls ~/.oh-my-zsh/themes3den.zsh-theme essembeh.zsh-theme junkfood.zsh-theme rgm.zsh-themeSoliah.zsh-theme evan.zsh-theme kafeitu.zsh-theme risto.zsh-themeadben.zsh-theme example.zsh-theme kardan.zsh-theme rixius.zsh-themeaf-magic.zsh-theme fino-time.zsh-theme kennethreitz.zsh-theme rkj-repos.zsh-themeafowler.zsh-theme fino.zsh-theme kiwi.zsh-theme rkj.zsh-themeagnoster.zsh-theme fishy.zsh-theme kolo.zsh-theme robbyrussell.zsh-themealanpeabody.zsh-theme flazz.zsh-theme kphoen.zsh-theme sammy.zsh-themeamuse.zsh-theme fletcherm.zsh-theme lambda.zsh-theme simonoff.zsh-themeapple.zsh-theme fox.zsh-theme linuxonly.zsh-theme simple.zsh-themearrow.zsh-theme frisk.zsh-theme lukerandall.zsh-theme skaro.zsh-theme.... 这么多的主题可以满足你的各种偏好了，我们只需在./zshrc文件中配置需要的主题即可，比如我们想用lambda.zsh-theme这个主题，我们只要这样配置 1ZSH_THEME=lambda 请注意好多教程上这边都有&quot;&quot;，但是请把双引号去掉，不然可能安装不成功，这也算是一个小坑。 然后保存这个文件文件，再打开一个新的命令行窗口即可看到效果了。那么这么多的主题如何快速找到哪些是我们喜欢的呢，我们还可以这样设置 1ZSH_THEME=&quot;random&quot; 我们将主题设置为随机，这样在我们每次打开命令行窗口的时候，都会随机在默认主题中选择一个。这样我们如果觉得当前的主题比较喜欢，可以直接使用 echo 命令输出当前主题的名称 1$ echo $ZSH_THEME 然后再将他设置到配置文件中即可。 我使用的ys这款主题，该有的信息都能展示出来，界面如下： 启用插件Oh My Zsh 默认自带了一些默认主题，存放在~/.oh-my-zsh/plugins目录中。我们可以查看这些插件 1plugins=(git) 如需启用更多插件，可加入需启用插件的名称。如下 1plugins=(git wd web-search history history-substring-search) 更新设置自动更新oh-my-zsh 默认情况下，当oh-my-zsh有更新时，都会给你提示。如果希望让oh-my-zsh自动更新，在~/.zshrc 中添加下面这句 1DISABLE_UPDATE_PROMPT=true 要手动更新，可以执行 1$ upgrade_oh_my_zsh 卸载直接在终端中，运行uninstall_oh_my_zsh既可以卸载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo在遇到“{{”符号时出现解析报错]]></title>
      <url>%2F2016%2F11%2F24%2Fhexo%20%E5%9C%A8%E9%81%87%E5%88%B0%20%E2%80%9C%7B%7B%E2%80%9D%20%E7%AC%A6%E5%8F%B7%E6%97%B6%E5%87%BA%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99%2F</url>
      <content type="text"><![CDATA[刚刚生成了一篇文章， hexo g 时会报错， 错误信息大致如下： 123FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 128, Column 48]unexpected token: . 估计是文章的原因，试了一下，把文章移除后一切又正常了，但是就是不知道文章中哪里出错了。 网上搜了好久，发现了这篇文章：hexo 在遇到 “}}” 符号时出现解析报错。 查找资料发现有人遇到和我类似的问题，但报的是 `unexpected token: }}的错误。搜索一下我那篇文章，果然有好几处带有 }} 符号。尝试着把几处符号删除，果然正常了。看来问题真的出在 }}上面。 直接说解决方案吧，参考别人的解决方法是在 }}中间加一个空格，但因为我的是有部分教程含义的文章，所以并不想这样误导人。于是去 github 上找解决方案。 github 上给出的方法是在需要显示 }}符号的地方加上 12&gt; &#123;% raw %&#125;&#123;% endraw %&#125;&gt; &gt; 标签，标记这部分不需要解析。例如文章中可能会出现 { { something } } 的片段，写成 12&gt; &#123;% raw %&#125;&#123;&#123; something &#125;&#125;&#123;% endraw %&#125;&gt; &gt; 就可以了。 虽然有点麻烦，但也算临时解决了这个问题，这是个已知 bug ，希望后续的版本能修复吧，毕竟使用太多 hexo 专属的标签对博客以后的迁移、改版什么的来说还是很麻烦的。 但是 1&#123;% raw %&#125;&#123;% endraw %&#125; 标签在代码块中会显示出来，前一篇文章的代码块中的}}符号我就用空格隔开了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《AngularJS实战》学习笔记]]></title>
      <url>%2F2016%2F11%2F24%2F%E3%80%8AAngularJS%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[快速上手Angular核心特征–MVCMVC:model,view,controller Model：数据模型层 view：视图层、负责展示 Controller：业务逻辑与控制逻辑 MVC是一种架构模式，是三种设计模式的合体，故没有把它当做一种设计模式。 GoF (Gang of Four，四人组， 《Design Patterns: Elements of Reusable Object-Oriented Software》/《设计模式》一书的作者：Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)并没有把MVC提及为一种设计模式，而是把它当做“一组用于构建用户界面的类集合”。在他们看来，它其实是其它三个经典的设计模式的演变：观察者模式(Observer)(Pub/Sub), 策略模式(Strategy)和组合模式(Composite)。根据MVC在框架中的实现不同可能还会用到工厂模式(Factory)和装饰器(Decorator)模式。我在另一本免费的书“JavaScript Design Patterns For Beginners”中讲述了这些模式，如果你有兴趣可以阅读更多信息。 正如我们所讨论的，models表示应用的数据，而views处理屏幕上展现给用户的内容。为此，MVC在核心通讯上基于推送/订阅模型(惊讶的是 在很多关于MVC的文章中并没有提及到)。当一个model变化时它对应用其它模块发出更新通知(“publishes”)，订阅者 (subscriber)——通常是一个Controller，然后更新对应的view。观察者——这种自然的观察关系促进了多个view关联到同一个 model。 对于感兴趣的开发人员想更多的了解解耦性的MVC(根据不同的实现)，这种模式的目标之一就是在一个主题和它的观察者之间建立一对多的关系。当这个 主题改变的时候，它的观察者也会得到更新。Views和controllers的关系稍微有点不同。Controllers帮助views对不同用户的输 入做不同的响应，是一个非常好的策略模式列子。 Angular核心2–模块化html代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html ng-app="HellloAngular"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="helloAngular"&gt; &lt;!--控制器--&gt; &lt;p&gt;&#123; &#123; greeting.text&#125; &#125;,Angular&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;script src="HelloAngular_MVC.js"&gt;&lt;/script&gt;&lt;/html&gt; JS代码： 123456789var myModule = angular.module("HellloAngular", []); //创建模块myModule.controller("helloAngular", ['$scope', //创建控制器，并注入$scope function HelloAngular($scope) &#123; $scope.greeting = &#123; text: 'Hello' &#125;; &#125;]); 只有把模块创建出来以后，才能调用模块下面的方法。 1&lt;html ng-app="moduleName"&gt; Angular核心特征3–指令系统指令系统可以自定义标签： 123456789var myMoudle=angular.module("MyMoudle",[]);myMoudle.directive("hello",function () &#123; return &#123; restrict: 'E', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', //模板，替换了&lt;hello&gt; replace: true &#125;&#125;); 123456789101112&lt;!DOCTYPE html&gt;&lt;html ng-app="MyMoudle"&gt; &lt;!--ng-app相当于java中的main方法，表示从ng-app开始下面所有内容归angularjs管理--&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hello&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;script src="Hello.js"&gt;&lt;/script&gt;&lt;/html&gt; Angular核心特征4–双向数据绑定 数据更新View自动更新，view更新数据也跟着更新。 只用一个html文件实现输入的文字立刻出现在下方。（第一次看到时第一反应是，这货是黑科技~） 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;input ng-model="greeting.text"/&gt; &lt;!--生成数据模型--&gt; &lt;p&gt;&#123; &#123; greeting.text&#125; &#125;,AngularJS&lt;/p&gt; &lt;!--双括号在Angular中表示取值--&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;/html&gt; 开发、调试、测试工具 代码编辑工具：sublime、webstorm 断点调试工具：chrome插件batarang 版本管理工具：git、git小乌龟 代码合并和混淆工具：grunt 依赖管理工具：bower 单元测试工具：karma、jasmine 集成测试工具：protractor（专为AngularJS定制的测试工具） app放源代码 test下面分集成测试e2e和单元测试unit两个目录 基本概念和用法MVC MVC只是手段，终极目标是模块化和复用 AngularJS中Controller的实现方式 不要试图去复用Controller，一个控制器一般只负责一小块视图 不要在Controller中操作DOM，这不是控制器的职责 不要在Controller里面做数据格式化，ng有很好用的表单控件 不要在Controller里面做数据过滤操作，ng有$filter服务 一般来说，Controller是不会互相调用的，控制器之间的交互会通过事件进行 利用Directive实现View的复用。 AngularJS的MVC是借助于$scope实现的: $scope是一个POJO（Plain Old JavaScript Object） $scope提供了一些工具方法$watch()/$apply() $scope是表达式的执行环境（或者叫作用域） $scope是一个树形结构，与DOM标签平行 子$scope对象会继承父$scope上的属性和方法 每一个angular应用只有一个根$scope对象（一般位于ng-app上） $scope可以传播事件，类似DOM事件，可以向上也可以向下 $scope不仅是MVC的基础，也是后面实现双向数据绑定的基础 可以用angular.element($0).scope()进行调试 路由、模块、依赖注入 使用ngRoute进行视图之间的路由： 1234567891011121314151617 //创建模块，并指定模块依赖var bookStoresApp = angular.module('bookStoreApp',[ 'ngRoute','ngAnimate','bookStoreCtrls','bookStoreFilters', 'bookStoreServices','bookStoreDirectives']);bookStoreApp.config(function($routePrivider)&#123; //根据url后缀的不同，加载不同的模板，并且用不同的控制器控制 $routePrivider.when('/hello',&#123; templateUrl: 'tpls/hello.html', controller: 'HelloCtrl' &#125;).when('/list',&#123; templateUrl: 'tpls/booklist.html', controller: 'BookListCtrl' &#125;).otherwise(&#123; redirectTo: '/hello' &#125;)&#125;); ng官方推荐的模块切分方式： 任何一个ng应用都是由控制器、指令、服务、路由、过滤器、等有限的模块类型构成 控制器、指令、服务、过滤器分别放在一个模块里面（可借助与Grunt合并） 用一个总的app模块作为入口点，它依赖其他所有模块 双向数据绑定举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="UserInfoModule"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="Form.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt;双向数据绑定&lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;form class="form-horizontal" role="form" ng-controller="UserInfoCtrl"&gt; &lt;!--controller--&gt; &lt;div class="form-group"&gt; &lt;label class="col-md-2 control-label"&gt; 邮箱： &lt;/label&gt; &lt;div class="col-md-10"&gt; &lt;input ng-model="userInfo.email" placeholder="推荐使用126邮箱" type="email" class="form-control"&gt;&lt;!--调用userInfo中的email值--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-md-2 control-label"&gt; 密码： &lt;/label&gt; &lt;div class="col-md-10"&gt; &lt;input ng-model="userInfo.password" type="password" class="form-control" placeholder="只能是数字、字母及下划线"&gt; &lt;!--调用userInfo中的password值--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-offset-2 col-md-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" ng-model="userInfo.autoLogin"&gt;自动登录 &lt;!--调用userInfo中的checkbox值--&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-offset-2 col-md-10"&gt; &lt;button class="btn btn-default" ng-click="getFormData()"&gt;获取form表单的值&lt;/button&gt; &lt;button class="btn btn-default" ng-click="setFormData()"&gt;设置form表单的值&lt;/button&gt; &lt;button class="btn btn-default" ng-click="restFormData()"&gt;重置form表单的值&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930var userInfoModule = angular.module('UserInfoModule', []);userInfoModule.controller('UserInfoCtrl', ['$scope', function ($scope) &#123; //初始化userInfo数据 $scope.userInfo = &#123; email: '111@126.com', password: '112231', autoLogin: true &#125;; //获取表单中的数据 $scope.getFormData = function () &#123; console.log($scope.userInfo); &#125;; //设置表单中的数据 $scope.setFormData = function () &#123; $scope.userInfo = &#123; email: 'dddd@126.com', password: '11111', autoLogin: false &#125; &#125;; //重置表单数据 $scope.restFormData = function () &#123; $scope.userInfo = &#123; email: '111@126.com', password: '112231', autoLogin: true &#125;; &#125;&#125;]); ng-class可以做一些样式控制，比如 &lt;div ng-class=&#39;{error:isError,warning:isWaring}&#39;&gt;{ { messageText} }&lt;/div&gt; ng-show=&#39;menuState.show&#39;可以通过$scope.menuState={show:false};控制显示或者隐藏，show的值为false时隐藏，true时显示。通过ng-hide=&quot;&quot;也可以达到同样的效果。 路由可以用UI-Router来代替Angular自带的router功能。 前端路由的基本原理： 哈希# 点击后不会跳转，相当于设置了锚点，只在页内跳转 HTML5中新的historyAPI 通过js代码修改浏览器地址栏中的地址，会在浏览器中留下历史记录，但是页面不会跳转 路由的核心是给应用定义“状态” 使用路由机制会影响到应用的整体编码方式（需要预先定义好状态） 考虑兼容性问题和“优雅降级” 指令123456789101112&lt;!DOCTYPE html&gt;&lt;html ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hello&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script src="../Demo4-TwowayDataBinding/angular.min.js"&gt;&lt;/script&gt;&lt;script src="Hello.js"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myMoudle=angular.module("MyMoudle",[]);myMoudle.directive("hello",function () &#123; return &#123; restrict: 'E', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', //模板，替换了&lt;hello&gt; replace: true &#125;&#125;); restrict表示匹配模式，共有AEMC四个选项: A表示属性,&lt;div hello&gt;，是默认的匹配模式 E表示元素,&lt;hello&gt;， M表示注释,&lt;!-- directive:hello --&gt; &lt;div&gt;&lt;/div&gt;，(注意注释中的空格) C表示CSS的样式类,&lt;div class=&#39;hello&#39;&gt; A和E两种匹配模式比较常用，当需要创建带有自己的模板的指令时，使用元素名称的方式创建指令；当需要为已有的HTML标签增加功能时，使用属性的方式创建指令。 template表示模板，这里可以用templateURL来实现（需要导入templateUrl.js），即templateUrl: &#39;hello.html&#39;把已有的模板写在单独的html文件中。templateCache可以让模板不仅在一个地方使用，还可以在其他地方使用，Angular会把模板缓存起来，以便后续使用。 12345678910111213var myModule=angular.module('MyModule',[]);//run方法表示注射器加载完所有的模块时，此方法执行一次myModule.run(function($templateCache)&#123; $templateCache.put("hello.html","&lt;div&gt;Hello everyone&lt;/div&gt;")&#125;);myModule.directive("hello",function($templateCache)&#123; return&#123; restrict: 'AECM', template: $templateCache.get("hello.html"), replace:true &#125;&#125;) replace表示标签里面嵌套的内容被模板全部替换 transclude表示保留标签里面的内容: 12345678var myModule=angular.module('MyModule',[]);myModule.directive("hello",function()&#123; return&#123; restrict: "AE", transclude: true, template: "&lt;div&gt;Hello everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;" &#125;&#125;) ng-transclude表示原来标签里面嵌套的内容放在此处。 指令执行的机制 compile函数用来对模板自身进行转换，而link函数负责在模型和视图之间进行动态关联； 作用域在链接阶段才会被绑定到编译之后的link函数上； compile函数仅仅在编译阶段运行一次，而对于指令的每一个实例，link函数都会执行一次； compile函数可以返回prelink和postlink函数，而link函数只会返回postlink函数； 如果需要修改DOM结构，应该在postlink中来做这件事情，而如果在prelink中做这件事情会导致错误； 大多数时候我们只要编写link函数即可 指令和控制器之间的交互1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="Myctrl"&gt; &lt;loader&gt;滑动加载&lt;/loader&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="Directive.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819var myModule=angular.module("MyModule",[]);myModule.controller("MyCtrl",["$scope",function ($scope) &#123; $scope.loadData=function () &#123; console.log("加载数据中"); &#125;&#125;]);myModule.directive("loader",function () &#123; return&#123; restrict: "AE", link: function (scope,element,attrs) &#123; //用link来实现监听事件 element.bind("mouseenter",function () &#123; // scope.loadData(); //第一种写法 scope.$apply('loadData()'); //第二种写法 &#125;) &#125; &#125;&#125;); 若需要根据不同的控制器调用不同的方法，需要用到指令上定义的属性。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="Myctrl"&gt; &lt;loader howToLoad="loadData()"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller="Myctrl2"&gt; &lt;loader howToLoad="loadData2()"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="Directive.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819202122232425var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.loadData=function () &#123; console.log("加载数据中"); &#125;&#125;]);myModule.controller("Myctrl2",["$scope",function ($scope) &#123; $scope.loadData2=function () &#123; console.log("加载数据中。。。"); &#125;&#125;]);myModule.directive("loader",function () &#123; return&#123; restrict: "AE", link: function (scope,element,attrs) &#123; element.bind("mouseenter",function (event) &#123; //前面howtoload是按驼峰法则写的，但这边需要写成小写，这是一个坑，要注意。还有howtoload不要写成函数调用形式。 scope.$apply(attrs.howtoload); &#125;); &#125; &#125;&#125;); 上述代码实现了指令的复用，指令load通过howtoload属性实现了与控制器的交互，通过不同的控制器控制不同的属性，实现load输出的不同，可以简单的理解为标签load通过自身的howtoload属性，调用不同的控制器，实现不同的输出。 指令之间的交互123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="superman.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman strength&gt;动感超人-力量&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman speed strength&gt;动感超人2-力量+敏捷&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman light speed strength&gt;动感超人3-力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var myMoudle = angular.module("MyMoudle", []);myMoudle.directive("superman", function () &#123; return &#123; scope: &#123;&#125;, //创建独立的作用域 restrict: "AE", controller: function ($scope) &#123; /*指令内部的controller，用来暴露一组public的方法给外面调用*/ $scope.abilities = []; this.addStrength = function () &#123; $scope.abilities.push("strength"); &#125;; this.addSpeed = function () &#123; $scope.abilities.push("speed"); &#125;; this.addLight = function () &#123; $scope.abilities.push("light"); &#125;; &#125;, //link是用来处理指令内部的事物（绑定事件等），controller是暴露方法给外面调用 link: function (scope, element, attrs) &#123; element.addClass('btn btn-primary'); element.bind("mouseenter", function () &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myMoudle.directive("strength", function () &#123; return &#123; //require表示指令依赖于Superman require: '^superman', //Angular处理的时候会把supermanCtrl注入link中，这样就可以调用superman的addStrength()函数 link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myMoudle.directive("speed", function () &#123; return &#123; require: '^superman', link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myMoudle.directive("light", function () &#123; return &#123; require: '^superman', link: function (scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); 指令之间的交互方式是通过指令内部controller暴露出来的方法，来给外部调用。 若没有独立scope，scope之间会相互影响。 scope的绑定策略： @:把当前属性作为字符串传递。你还可以绑定来自外层scope的值，在属性值中插入{ { } }即可 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; &lt;drink flavor="&#123; &#123; ctrlFlavor&#125; &#125;"&gt;&lt;/drink&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scopeAT.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.ctrlFlavor="bb";&#125;]);myModule.directive("drink",function () &#123; return&#123; restrict: 'AE', template: '&lt;div&gt;&#123; &#123; flavor&#125; &#125;&lt;/div&gt;', scope: &#123; //作用等价于下面的link,获取控制器中的flavor flavor: '@' &#125;/*, link: function (scope,element,attrs) &#123; scope.flavor=attrs.flavor; &#125;*/ &#125;&#125;); =：与父scope中的属性进行双向绑定 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; Ctrl: &lt;br&gt; &lt;input type="text" ng-model="ctrlFlavor"&gt; &lt;br&gt; Directive: &lt;br&gt; &lt;drink flavor="ctrlFlavor"&gt;&lt;/drink&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scope-equal.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.ctrlFlavor="bb";&#125;]);myModule.directive("drink",function () &#123; return&#123; restrict: 'AE', template: '&lt;input type="text" ng-model="flavor"/&gt;', //控制器和指令中的内容同步 scope: &#123; flavor: '=' &#125; &#125;&#125;); ​ &amp;：传递一个来自父scope的函数，稍后调用 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="Myctrl"&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt;&lt;script src="scope-and.js"&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112131415var myModule=angular.module("MyMoudle",[]);myModule.controller("Myctrl",["$scope",function ($scope) &#123; $scope.sayHello=function (name) &#123; alert("Hello"+name); &#125;&#125;]);myModule.directive("greeting",function () &#123; return&#123; restrict: 'AE', template: '&lt;input type="text" ng-model="userName"/&gt;&lt;br&gt;'+'&lt;button class="btn btn-default" ng-click="greet(&#123;name:userName&#125;)"&gt;Greeting&lt;/button&gt;&lt;br&gt;',//这边的name绑定到上面的userName scope: &#123; greet: '&amp;' &#125; &#125;&#125;); AngularJS内置的指令 form指令 html原生form表单是不能嵌套的，而Angular封装之后的form可以嵌套； Angular为form扩展了自动校验、防止重复提交等功能； Angular对input元素的type进行了扩展，一共提供了以下10种类型：text、number、url、email、radio、checkbox、hidden、button、submit、reset； Angular为表单内置了4种CSS样式：ng-valid、ng-invalid、ng-pristine、ng-dirty； 内置校验器：require、minlength、maxlength。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="form.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name="myForm" ng-submit="save()" ng-controller="TestFormModule"&gt; &lt;input type="text" name="userName" ng-model="user.userName" required/&gt; &lt;!--required表示自动校验--&gt; &lt;input type="password" name="password" ng-model="user.password" required/&gt; &lt;input type="submit" ng-disabled="myForm.$invalid"/&gt; &lt;!--绑定到$invalid的属性上--&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910var appModule=angular.module('MyMoudle',[]);appModule.controller('TestFormModule',function ($scope) &#123; $scope.user=&#123; userName: 'aaaaa', password: '' &#125; ; $scope.save=function () &#123; alert("保存数据"); &#125;&#125;); expander指令 expander指令是自定义指令 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="expander.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="SomeController"&gt; &lt;expander class="expander" expander-title="title"&gt; &#123; &#123; text&#125; &#125; &lt;/expander&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425var appModule = angular.module('MyMoudle', []);appModule.directive('expander', function () &#123; return &#123; restrict: 'AE', replace: true, transclude: true, scope: &#123; title: '=expanderTitle' &#125;, template: '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123; &#123; title&#125; &#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', /*ng-show决定了是否显示*/ link: function (scope, element, attrs) &#123; scope.showMe = false; scope.toggle = function () &#123; scope.showMe = !scope.showMe; &#125; &#125; &#125;&#125;);appModule.controller('SomeController', function ($scope) &#123; $scope.title = '点击展开'; $scope.text = '这里是内部内容';&#125;); according指令 封装一个比较复杂的according指令 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="according.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller="SomeController"&gt;&lt;div&gt; &lt;according&gt; &lt;expander class="expander" expander-title="expander.title" ng-repeat="expander in expanders"&gt; &#123; &#123; expander.text&#125; &#125; &lt;/expander&gt; &lt;/according&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var appModule = angular.module('MyMoudle', []);appModule.directive('according',function () &#123; return&#123; restrict: 'AE', replace: true, transclude: true, template: '&lt;div ng-transclude&gt;&lt;/div&gt;', controller: function () &#123; var expanders=[]; this.gotOpened=function (selectedExpander) &#123; angular.forEach(expanders,function (expander) &#123; if (selectedExpander != expander)&#123; expander.showMe=false; &#125; &#125;) &#125;; this.addExpander=function (expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);appModule.directive('expander', function () &#123; return &#123; restrict: 'AE', replace: true, transclude: true, require: '^?according', scope: &#123; title: '=expanderTitle' &#125;, template: '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123; &#123; title&#125; &#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', /*ng-show决定了是否显示*/ link: function (scope, element, attrs,accordingController) &#123; scope.showMe = false; accordingController.addExpander(scope); scope.toggle = function () &#123; scope.showMe = !scope.showMe; accordingController.gotOpened(scope); &#125; &#125; &#125;&#125;);appModule.controller('SomeController', function ($scope) &#123; $scope.expanders=[&#123; title: 'Click me to expander', text: 'Hi' &#125;,&#123; title: 'Click this', text: 'Yes' &#125;,&#123; title: 'Test', text: 'test' &#125;];&#125;); angular-ui提供了现成的指令库，可直接使用。 以miniui为例子 Service与Provider使用$HTTP服务类似Ajax 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="http.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="LoadDataCtrl"&gt; &lt;ul&gt; &lt;li ng-repeat="user in users"&gt; &#123; &#123; user.name&#125; &#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314var myModule=angular.module('MyMoudle',[]);myModule.controller('LoadDataCtrl',['$scope','$http',function ($scope,$http) &#123; $http(&#123; method: 'GET', url: 'data.json' &#125;).success(function (data,status,header,config) &#123; console.log("success"); console.log(data); $scope.users=data; &#125;).error(function (data,status,header,config) &#123; console.log("error"); &#125;)&#125;]); Service的特性 Service都是单例的 Service由$injector负责实例化,不需要new Service在整个应用的生命周期中存在，可以用来共享数据 在需要使用的地方利用依赖注入机制注入Service 自定义的Service需要写在内置的Service后面 内置Service的命名以$符号开头，自定义的Service应该避免 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="http://lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.css"&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="MyService1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="LoadDataCtrl"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type="text" ng-model="username" placeholder="请输入用户名"/&gt; &lt;pre ng-show="username"&gt;&#123; &#123; users&#125; &#125;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132var myModule=angular.module('MyMoudle',[]);myModule.factory('userListService',['$http',function ($http) &#123; var doRequest=function (username,path) &#123; return $http(&#123; method: 'GET', url: 'users.jon' &#125;); &#125; return &#123; userList: function (username) &#123; return doRequest(username,'userList'); &#125; &#125;;&#125;]);//自定义的服务放在最后myModule.controller('serviceController',['$scope','$timeout','userListService',function ($scope,$timeout,userListService) &#123; var timeout; //防止频繁向后台请求，导致页面抖动，350ms不按键就传输数据 $scope.$watch('username',function (newUserName) &#123; if (newUserName)&#123; if(timeout)&#123; $timeout.cancel(timeout); &#125; timeout=$timeout(function () &#123; userListService.userList(newUserName).success(function (data,status) &#123; $scope.users=data; &#125;); &#125;,300); &#125; &#125;);&#125;]); Service、Provide、Factory本质都是Provider Provider模式是“策略模式”+“抽象工厂模式”的混合体 使用$filter服务 $filter是用来进行数据格式化的专用服务 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="MyMoudle"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="../Demo6-service/angular-1.3.0.js"&gt;&lt;/script&gt; &lt;script src="filter.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--利用内置的filter把毫秒转化成日期--&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date &#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date:"MM/dd/yyyy@h:mma"&#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&#123;% raw %&#125;&#123; &#123; 1304375948024 | date:"yyyy-MM-dd hh:mm:ss"&#125; &#125;&#123;% endraw %&#125;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 1var myModule=angular.module('MyMoudle',[]); AngularJS内置了9个filter：currency（用来格式化货币），date（用来格式化日期），json，limitTo，lowercase，number，oderBy（排序），uppercase filter可以嵌套使用（用管道符号|分隔） filter是可以传递参数的 用户可以定义自己的filter 其他常用的Service内置的共有24个 $compile：编译服务 $filter：数据格式化工具，内置8个 $interval $timeout $locale：用来做国际化 $location：监控浏览器地址栏中的变化 $log：提供日志 $parse $http：封装了Ajax]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小记]]></title>
      <url>%2F2016%2F11%2F14%2F%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[工作终于有了着落，也算半只脚跨入了心仪已久的行业。 因为行业跨度太大，一路走来承受了很多压力，也很庆幸自己真的走过来了。 这几个月经常为了一个问题弄到凌晨三四点，每天一成不变的白米饭加老干妈。自己也迷茫过、质疑过、崩溃过，但是既然自己选择了这条路，那就要走到底。 感谢女朋友的陪伴，在我迷茫、崩溃的时候依然愿意在我身边。 感谢汪汪和田野的帮助，给了我那么一大箱的书，耐心解答我的问题，把我这个门外汉一步步领进门。 很庆幸，在年轻的时候能尝试去做自己想做的事情，尽管前路漫漫，充满更多的未知。 希望多年后，自己依然对技术保持一颗火热的心，依然充满激情。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于有自己的域名啦]]></title>
      <url>%2F2016%2F11%2F12%2F%E7%BB%88%E4%BA%8E%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E5%95%A6%2F</url>
      <content type="text"><![CDATA[双十一大家都在买买买的时候，有一个小码农也不甘寂寞，默默地在Namecheap上买了一个域名，完成了双十一的剁手之旅。 剁手之旅参照了新版Namecheap注册域名详细教程，还是比较简单的。不过我的域名解析用的是DNSPOD，没有用Namecheap的域名解析，这样国内的用coding访问，国外用github访问，可以加快网站访问速度。 Github的设置比较简单，在/hexo/source中添加一个CNAME文件，注意不需要后缀名，里面内容就写tc9011.com，不要写www。然后去github page上绑定一下域名，DNS解析的话我是这样设置的： 下面说一下新版的coding绑定域名的问题，我发现这是一个大坑啊~~ 我直接访问tc9011.github.io地址会跳转到tc9011.com,我直接访问tc9011.coding.me发现不会跳转到tc9011.com这个域名，原因我搜了一下，答案如下： github只能绑定一个域名，所以访问tengj.github.io时，github的服务器知道要往tengj.top跳转。coding可以绑定多个域名，当绑定多个域名时，访问tengj.coding.me,coding的服务器不知道要往哪里跳转，所以干脆就不跳转了。但是当绑定一个时，为什么不跳转，可能是coding觉得麻烦，就不跳转了。这些都是coding定的，我们没办法改变。 你先想一个问题：那么多人都要在github上搞博客，还要自定义域名。github哪来这么多ip给你们用？所以办法就是仅仅提供一个ip，这样必然导致这个服务器上发着所有人的博客文件，那么如何区分特定的域名应该展示谁的博客呢？答案就是在仓库里面新建一个CNAME文件，里面写上你博客想用的域名，github的服务器会根据当前http请求的Host头部（即域名），查找对应的包含相同的CNAME内容的目录，从而显示其中的页面。这就是为什么要在仓库里面创建一个CNAME原因。 不过，事情还没完，一个ip的问题是世界各地不同地点的访问速度不同，有些地方可能很慢，所以需要一组ip来分担一下。最早github好像只有2个ip，后来ip变多了。再后来，github支持域名解析的时候，通过alias来。比如在域名商那边设置成www.tengj.com ---&gt; tengj.github.io，由于github无法控制你如何配置域名和ip的关系，但他可以控制tengj.github.io的最终ip解析，所以github推荐大家使用alias解析，可以为博主提供就近ip访问。这就是你在域名商那边配置CNAME或者alias的原理。这里的CNAME跟上面提到的CNAME作用不同，不是一个概念，不要混淆。 还有就是coding.me的现在是指向国外的，不像以前是指向国内的，我也是醉了~ 要把博客同步到coding，首先要在coding里面新建一个与你Global Key（也就是个性后缀）一样的项目，然后修改博客根目录下面的_config.yml文件中的deploy如下（注意缩进）： 和github一样配置ssh，过程就不详细说了，比较简单。比较重要的是，在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 12cd source/touch Staticfile #名字必须是Staticfile 接下来在coding pages服务中绑定域名，注意分支一定要写master。 最后去DNSPOD上设置一下域名解析： 然后检测一下域名解析是否正确，国内解析到coding，国外解析到github，后面国外的解析很多是解析到美国 Fastly公司CDN网络节点，这个就是github的解析，所以国内的解析估计就是coding了，虽然也是指向国外，ORZ。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[近期对HEXO博客的一些优化]]></title>
      <url>%2F2016%2F11%2F08%2F%E8%BF%91%E6%9C%9F%E5%AF%B9HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前几天参加了一场面试，面试时展示我的博客时，发生了一个比较尴尬的事情：博客打开页面空白，此时我内心是崩溃的，明明昨天晚上还好好的。。。 回来后我就开始着手对我的博客进行bug调试和优化。 CSS JS 404导致博客页面空白首先解决这个问题，，在上网简单搜索了一下，导致这个结果的原因应该是： GitHub Pages 过滤掉了 source/vendors 目录的访问，所以next主题下的source下的vendors目录不能够被访问到，所以就出现了本地hexo s能够正常访问，但是deploy到github就是一片空白，按f12，可以看到大量来自source/vendors的css和js提示404 参考回答 解决方案正如github里面说说的： 找到解决方案了。。 @BBBOND @monsterLin @SpadeRoy 根据作者的提示 @iissnan ，首先修改source/vendors为source/lib，然后修改_config.yml， 将 _internal: vendors修改为_internal:lib 然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。 然而我觉得这个太麻烦了，毕竟要改很多东西，既然新版本已经修复这个问题了，那我就重新安装吧。安装前先把文件先备份了一下，然后就按照Next官网的说明，使用git来clone最新版本（之前我是下载安装）。 在终端窗口下，用cd定位到Hexo站点目录，然后clone，具体代码如下： $ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next cd后面的“your-hexo-site”改成你自己的hexo路径。 安装完了把主题目录下的_config.yml文件替换成更新前的文件，其中的_internal: vendors修改为_internal:lib （大概在347行的地方），然后这个bug就可以解决了。 使用google字体影响网页加载效率对网页加载进行分析后，发现有三个东西影响网页加载效率： 首先是Swiftype 搜索，这个是因为墙的原因，但是我又不想替换成localsearch，所以这个问题就先略过； 第二个是不蒜子统计，本来想替换成腾讯分析，但是貌似需要先给博客买个域名，然后腾讯分析才能识别，不然光是tc9011.github.io是识别不到的，这个涉及到购买域名，域名解析等问题，所以我暂时忍一下（其实是没钱了T^T）； 最后一个就是google字体，其实国内可以通过360cdn来访问。具体方法如下： 找到\themes\next\layout_partials\head\external-fonts.swig文件，把里面的fonts.googleapis.com 改成fonts.useso.com 实践证明，改过后速度更慢了，于是我又改回了fonts.googleapis.com，ORZ 添加留言本页面之前添加了多说评论，无意中看到别人家的博客中有留言本功能，于是我也想整一个。其实方法也是蛮简单的。 1、添加留言本page先cd到博客根目录，然后运行： hexo new page guestbook 2、在留言本页面中添加多说代码进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件添加以下代码： &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 然后登陆自己多说站点，进入设置-&gt;自定义CSS，添加 123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置头像长宽*/ border-radius: 27px; /*设置头像圆角效果*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置头像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隐藏多说版权*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 3、菜单中设置留言本找到NexT主题设置的_config.yml文件里面的menu项 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 在menu_icons下为留言本设定图标： 1234567891011menu_icons: enable: true#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat search: search guestbook: book 我用的是 book 这个图标，如果想要设定为其他图标，请访问：Font Awesome Icons，找到喜欢的图标，记录下图标后的关键字再填写到 menu_icons 下。 4、添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言 SEO优化1、添加robots.txt可以参考我的robots.txt，代码如下 1234567891011121314# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://tc9011.github.io/sitemap.xmlSitemap: https://tc9011.github.io/baidusitemap.xml 把robots.txt放在你的hexo站点的source文件下即可。 2、添加sitemap网站地图之前学了SEO，尝试也给自己网站做一下SEO，具体方法如下： 安装hexo的sitemap网站地图生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码 123# hexo sitemap网站地图sitemap:path: sitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。​ 3、给非友情链接的出站链接添加“nofollow”标签以hexo的NexT主题为例，需要修改两处 找到footer.swig,路径在your-hexo-site\themes\next\layout\_partials，将下面代码 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 改成 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io" rel="external nofollow"&gt;Hexo&lt;/a&gt;') &#125;&#125; 将下面代码 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 改成 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout\_macro，将下面代码 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" rel="external nofollow"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank"&gt; 改成 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank" rel="external nofollow"&gt; 这是根据动动手指，不限于NexT主题的Hexo优化（SEO篇来进行优化的，优化过程中发现，还是需要有自己的域名，不然百度抓不到你的数据，哎~等工作了一定要买一个域名（奋斗脸）。 多说评论不稳定，加载速度慢优化加载多说的时候，因为对方服务器的原因，很不稳定，经常刷不出多说评论，所以决定优化一下，多说评论不稳定，加载速度慢优化方法，主要参考这篇文章进行了优化，具体方法： 在七牛镜像储存中，镜像源地址填写http://static.duoshuo.com，然后保存。 加速成功后，可以通过七牛提供的空间访问域名访问到多说镜像网站，例如我的默认域名是http://og9ocpmwk.bkt.clouddn.com/，直接可以链接到多说的镜像网站。 下载多说核心脚本embed.js，需要更改一处地方代码， 1function n(e)&#123;j.theme=e,"none"!=e&amp;&amp;o.injectStylesheet(j.STATIC_URL+"/styles/embed"+(e?"."+e+".css?"+R[e]:"."+short_name)+".css")&#125; 上面代码应该是调用多说样式embed.xxx.css，我们需要修改成我们七牛镜像的多说样式，只需把j.STATIC_URL更改成七牛空间访问域名，例如我修改成&quot;http://og9ocpmwk.bkt.clouddn.com&quot;。更改后另存为dsembed.js（重命名主要防止与七牛镜像中的embed.js冲突）。最后上传到七牛空间里。现在你可以通过地址/dsembed.js访问经过七牛CDN加速后的多说核心脚本。 把多说默认引入static.duoshuo.com域名下的embed.js更改成七牛空间更改后的dsembed.js即可。 这里以多说通用代码为例， 12345678910111213141516&lt;!-- 多说评论框 start --&gt; &lt;div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type="text/javascript"&gt;var duoshuoQuery = &#123;short_name:"araolin"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; embed.js引入的代码是 1ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; 这里需要更改成 1ds.src = '这里是你的七牛空间embed.js的地址'; 以我的为例，我更改成了 1ds.src = 'http://og9ocpmwk.bkt.clouddn.com/dsembed.js'; 如果你是hexo Next主题的话，需要更改的文件是duoshuo.swig，具体路径在your-hexo-site\themes\next\layout\_scripts\comments目录里。​ 最后值的注意的是，因为我的网站是https://tc9011.github.io，上面的链接若写成http的话，也会加载不了多说评论。所以下面是针对https的一些修改： 首先给七牛账户充值11块钱，不然这个功能木有办法用~ 进入存储资源列表，然后点击下图所示的https域名，七牛会自动生成一个域名； 在内容管理里面选择刚刚生成的域名作为默认外链域名，记得保存。 把内容管理里面的文件先全部删掉，把上面dsembed.js文件重命名一下，主要防止没有覆盖旧文件，比如我命名为dembed.js，再把文件中添加http://og9ocpmwk.bkt.clouddn.com的地方都改成新的外链地址，比如我的https://ogddl0byd.qnssl.com，然后保存，上传七牛。 把duoshuo.swig中的src替换成新的域名。 1ds.src = 'https://ogddl0byd.qnssl.com/dembed.js'; ​ 最后其实博客还有优化空间，比如有几个js加载速度简直是慢的令人发指，尝试了压缩代码，还是不行，感觉还是要把他们托管到其他地方，这个以后慢慢优化，可能以后买个域名，把博客同时托管到coding和github，国内访问coding，国外访问github，具体怎么操作，请听下回分解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEO与Yahoo军规]]></title>
      <url>%2F2016%2F11%2F01%2FSEO%E4%B8%8EYahoo%E5%86%9B%E8%A7%84%2F</url>
      <content type="text"><![CDATA[《SEO在网页制作中的应用》与《Yahoo军规》课程总结 SEO与搜索引擎首先SEO是什么： SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化（比如网站结构调整、网站内容建设、网站代码优化等）以及站外优化（比如网站站外推广、网站品牌建设等），使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。 根据课程内容我自己画了上面这张图，这里以百度搜索引擎为例子说明一下，百度搜索引擎数据库通过百度蜘蛛爬取互联网上数据，这些数据是搜索引擎数据库中没有的，且有用的数据，理想状态下，用户输入关键字搜索，百度通过搜素引擎数据库中与关键字最匹配的结果返回给用户。 百度蜘蛛怎么才能更好的爬取数据呢，这就要通过网站的SEO，让网站用百度蜘蛛听得懂的语言和它交流，让它能更了解你的网站。SEO分为白帽SEO和黑帽SEO。黑帽SEO通过伪装让搜索引擎以为网站和某个关键字有联系，但实际上并没有；白帽SEO则通过上图列出的方法，让网站用百度蜘蛛听得懂的语言更好的去与搜索引擎交流。 网站结构与代码优化 结构布局优化：用扁平化结构 网站结构层次越少越容易被蜘蛛获取，中小型网站，目录层次结构超过3层，蜘蛛就不愿意往下爬。 控制首页链接数量 首页链接数量不能太少也不能太多，中小型企业首页链接在100个以内，例如：页面导航、底部导航、锚文字链接等。 扁平化目录层次 网站的设计不要用纵线性的结构。 导航SEO优化 尽量用文字，如果是图片，alt和title必须要有，面包屑导航（一般页面左上角的XX&gt;&gt;XX&gt;&gt;XX就是，便于了解当前位置和返回）。 页码 页码尽量用 首页 1 2 3 下一页 或者 首页 1 2 3 4 下拉菜单 这样方便蜘蛛抓取内容。 页面布局 左边正文，右边放热门文章和相关文章。 网速 控制页面不要超过100k，不然加载太慢。 网页代码 &lt;title&gt;标题 &lt;meta keywords&gt;关键词 &lt;meta description&gt;网页描述 HTML标签语义化 &lt;a&gt;要有title，对于指向其他网站的链接要写rel=&quot;nofollow&quot; &lt;h1&gt;用于正文标题，副级标题用&lt;h2&gt; &lt;table&gt;标签要写&lt;caption&gt;表格标题&lt;/caption&gt; &lt;img&gt;标签应使用alt说明 &lt;strong&gt;的权重&gt;&lt;em&gt;的权重，如果只为加粗斜体效果建议用&lt;b&gt;和&lt;i&gt;标签 重要内容HTML代码放在最前面 重要内容不要用JS输出 尽少使用iframe框架 谨慎使用display:none，不想显示的内容可以用z-index或者显示在浏览器显示范围之外。蜘蛛会过滤掉display:none中的内容 Yahoo军规 尽量减少HTTP的请求数 可以将图片合并、JavaScript代码合并、css样式合并 使用CDN（内容分发网络） CDN:内容分发网络。意思是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 用简单的话说就是，在离你最近的地方，放置一台性能好链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 添加Expire/Cache-Control头 expire头的内容是一个时间值，值就是资源在本地的过期时间、存在本地。在本地缓存阶段，找到一个对应的资源值，当前时间还没超过资源的过期时间，就直接使用这一个资源，不会发送http请求。 Cache-Control是http协议中常用的头部之一，顾名思义，他是负责控制页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，也有更多的处理方式 启用Gzip压缩 将HTML、JavaScript、CSS、PHP等文件进行Gzip压缩，可以显著减小文件的体积。 将CSS放在页面最上方 避免页面出现空白或者闪烁，提高浏览器的渲染性能。 将Script放在页面最下面 先将内容呈现出来，不会让用户等太久。 避免在CSS中使用Expressions 在CSS中用了JavaScript的计算式，在页面显示和缩放、页面滚动、移动鼠标时CSS Expressions都会重新计算一次，严重影响性能。 把JS和CSS都放到外部文件中 JS和CSS单独提取出来，提高了JS和CSS的复用性，减少页面体积，提高了JS和CSS的可维护性；JS和CSS内置可以减少页面请求，提高页面渲染，若JS和CSS很少、只应用于一个页面或者不经常被访问到时可以这样使用。两者各有优势，灵活取用。 减少DNS查询 当缓存时间长时，减少DNS的重复查找，节省时间；当缓存时间短时，及时的检测网站服务器的变化，保证准确性。 压缩JavaScript和CSS 可以去除不必要的空白符、格式符、注释符，简写方法名、参数名压缩JS脚本。 避免重定向 重定向：用户的原始请求被重新转向到了其他请求 重定向状态码：301 Moved Permanently，表示用户请求的页面被移动到了另一个位置，客户端收到这个后会重新发起一次请求，是永久重定向；302 Found，表示用户请求的页面被找到了，但不在原始位置，服务器会返回一个地址，客户端会重新发起一次请求，是临时重定向。 用301重定向可以使搜索引擎识别，更新新的地址；用302总是会先找到旧地址再跳到新地址。 移除重复的脚本 配置实体标签（ETag） ETag属于HTTP协议，是使用特殊的字符串来标识某个请求资源版本，如果客户端缓存中的版本和服务器中的版本一致，服务器就不需要再传递。 使用AJAX缓存 post请求每次都执行，不被缓存；get请求时同一地址不重复执行，可以被缓存。 看完这两课觉得以前自己码的东西还有很多要修改的，前端之路，任重而道远。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Github和Hexo的个人博客搭建]]></title>
      <url>%2F2016%2F10%2F31%2F%E5%9F%BA%E4%BA%8EGithub%E5%92%8CHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[花了两天终于把基于Github和Hexo的个人博客搭建好了，期间踩了不少坑，在此作为第一篇正式博文记录一下。 Hexo这里还是要说一下Hexo，它是一款基于Node.js的静态博客框架，可以换不同主题，自定义各种样式，个人觉得还是蛮不错的（因为你只用过这一个，呵呵）。 Hexo特性： Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 支持GitHub Flavored Markdown和所有Octopress的插件。 Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。 Hexo官网 ，官网也是基于Github构件的网站。 配置环境及安装Git的安装就跳过了，比较简单。下面说一下Node.js安装。 可以去node.js Git和Node.js安装完了就可以用npm安装Hexo，在mac的终端内输入下面的命令： 1$ npm install -g hexo-cli 然后Hexo就安装完成啦。安装好后，需要对Hexo初始化，在终端中挨个执行下面的命令，其中用指定的文件夹路径代替，一定要cd，不要问我为什么，都是血的教训： 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 至此，所有的安装工作都完成，撒花~ 完成后，目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 建站及部署安装完成后就可以通过下面的命令生成静态页面 hexo g 然后启用本地服务 hexo s 进入浏览器输入http://localhost:4000 就可以看到网站的效果，当然刚开始是默认样式。 下面我们就把网站部署到Github（此处我当你已经弄好github的ssh了） 登陆Github后创建一个名字为your_name.github.io（your_name替换成你的用户名）的仓库； 然后打开hexo下面的_config.yml，翻到最后面， 将下面的信息补充完整（your_name都换成你自己的用户名），注意Hexo 5.0以后type应该写成git而不是github，这又是一处血的教训（姚明脸）。 123type: git repository: https://github.com/your_name/your_name.github.io branch: master 然后分别执行以下命令部署本地博客到github 12hexo ghexo d 然后在浏览器里面输入your_name.github.io就可以访问你自己的博客啦！ NexT主题安装Hexo有好多主题，经过筛选，我选择了NexT，点击链接可以去官网看看，安装教程写的蛮详细的，我就不多说了。这里说一下一些要注意的地方吧，毕竟我踩的坑还是蛮多的，呵呵。 swiftype按照教程生成key后，那个框是不能下拉的，但是你的key却在你看不见的最底下，用command+A，然后command+C复制出来就行，key就是那一串大写字母，不要单引号，swiftype_key:后面记得加空格。 用LeanCloud来统计文章阅读次数，我是参考了这篇文章——&gt;&gt;最简便的方法搭建Hexo+Github博客,基于Next主题，记的在修改主题配置文件_config.yml时候，一定要把下面enable设置为true。 1234leancloud_visitors: enable: true app_id: ytnok33cvEchgidigtb0WumC-gzGzoHsz #&lt;AppID&gt; app_key: SrcG8cy1VhONurWBoEBGGHML #&lt;AppKEY&gt; 设置网站图标Favicon，用比特虫把图制作好后，上传到云存储空间（我用的是七牛），获取图片的网址，然后打开主题配置文件_config.yml，找到favicon字段，将图片网址粘贴在后面，即可。 其他东西跟着教程做起来都还好。]]></content>
    </entry>

    
  
  
</search>
